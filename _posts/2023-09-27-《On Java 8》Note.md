---
title: 《On Java 8》Note
date: 2023-09-27 14:12:07 +0800
categories: [Java, 笔记]
tags: [java]     # TAG names should always be lowercase
---



# [第一章 对象的概念](https://njuics.github.io/OnJava8/#/book/01-What-is-an-Object?id=第一章-对象的概念)

## 1. 抽象

> #### 所有编程语言都提供抽象机制。从某种程度上来说，问题的复杂度直接取决于抽象的类型(指抽象的内容)和质量。

> #### `“命令式”语言`根据计算机来描述问题，程序员必须在 机器模型 (“解决方案空间”)和 问题模型 (“问题空间”)之间建立关联。

> #### `OOP`根据问题来描述问题，我们将 问题空间中的元素以及它们在解决方案空间的表示称为 `"对象"`。更为简单的描述是：一个对象具有自己的 状态(内部数据) ，行为(方法) 和 标识 。



#### “纯粹”的面向对象程序设计方法的 五大基本特征：

- #### 万物皆对象

- #### 程序是一组对象，通过消息传递来告知彼此该做什么

- #### 每个对象都有自己的存储空间，可容纳其它对象

- #### 每个对象都有一种类型

- #### 同一类所有对象都能接收相同的消息





## 2. 接口

> #### `class` 和 `type` 通常可互换使用，有些人对它们进行了进一步区分，他们强调 `type` 决定了接口，而 `class` 是那个接口的一种特殊实现方式。
>
> #### 因此，在面向对象的程序设计中，尽管我们真正要做的是新建各种各样的数据“类型”（`Type`），但几乎所有面向对象的程序设计语言都采用了 `class` 关键字。

> #### 面向对象程序设计最大的挑战是 ———— 如何在 “问题空间”的元素 和 “方案空间”的元素 之间建立理想的一对一的映射关系 





## 3. 服务提供

> #### 软件设计的基本原则是 `高内聚` ：每个组件的内部作用明确，功能紧密相关。
>
> #### 在良好的面向对象设计中，每个对象功能 单一且高效 。这样的程序设计可以提高我们代码的复用性，同时也方便别人阅读和理解我们的代码。







## 4. 封装

> #### 可将编程的侧重领域划分为研发和应用：
>
> - #### 应用程序员调用研发程序员构建的基础工具类来做快速开发。
>
> - #### 研发程序员开发一个工具类，该工具类仅向应用程序员公开必要的内容并隐藏内部实现的细节。

> #### 使用访问控制的原因有以下两点：
>
> - #### 让应用程序员不要触摸他们不应该触摸的部分。
>
> - #### 使类库的创建者(即研发程序员)在不影响后者使用的情况下完善更新工具库。



### Java的访问权限：

- #### `public`：任何人都可以访问和使用该元素；

- #### `private`：除了类本身和类内部的方法，外界无法直接访问该元素；

- #### `protected`：子类可以访问 `protected` 的成员，但不能访问 `private` 成员；

- #### `default`：被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问；





## 5. 复用

> - #### `组合` ：用来表示 “拥有”关系 (has-a relationship) ； 用实心三角形箭头表示 ； 整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除 ； 多个整件不可以同时共享同一个部件
>
> - #### `聚合` ：是一种动态的 `组合` ； 用空心三角形箭头表示 ； 整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除 ； 多个整件可以共享同一个部件。
>
> - ##### 注释：组合和聚合都属于 关联关系 的一种，只是额外具有 整体-部分 的意义。至于是聚合还是组合，需要根据实际的业务需求来判断。

> #### 在创建新类时首先要考虑“组合”，因为它更简单灵活，而且设计更加清晰。







## 6. 继承

> #### 引入 继承 的目的：
>
> - #### 在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。但我们若能利用现成的数据类型，对其进行 `“克隆”` ，再根据情况进行添加和修改，情况就显得理想多了。

> - #### `基类` 包含派生自它的类型之间共享的所有特征和行为。
>
> - #### 创建基类以表示思想的核心。从基类中派生出其他类型来表示实现该核心的不同方式。
>
> - #### `派生类` 不仅包含现有类型的所有成员，而且复制了基类的接口。也就是说，基类对象接收的所有消息也能被派生类对象接收。

> - #### `是一个(is-a)关系` ： 派生类继承只覆盖基类的方法而不添加基类中没有的方法，因此基类和派生类就是相同的类型了(因为它们具有相同的接口)。
>
> - #### `像是一个(is-like-a)关系` ： 派生类继承了基类并添加了新的接口元素，从而扩展接口。虽然新类型可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法；
>
> - #### 用一个派生类对象完全替代基类对象的行为称为 “纯粹替代” ，也经常被称作 “替代原则” ；







## 7. 多态

> #### 我们在处理类的层次结构时，通常把一个对象看成是它所属的基类，而不是把它当成具体类。通过这种方式，我们可以编写出不局限于特定类型的代码。
>
> #### 这样的代码不会受添加的新类型影响，并且添加新类型是扩展面向对象程序以处理新情况的常用方法。

> - #### `早期绑定` ： 由非OOP编译器产生的函数调用会引起 “早期绑定” ， 即编译器生成的对特定函数名的调用，会被解析为将要执行的代码的绝对地址。
>
> - #### `后期绑定` ： 面向对象语言使用“后期绑定”的概念。当向对象发送信息时，被调用的代码直到 运行时 才确定。 编译器确保方法存在 ，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码。
>
> - #### 在 Java 中，动态绑定是默认行为，不需要额外的关键字来实现多态性。

> - #### `向上转型` ： 把子类当成其基类来处理

> - #### `多态性` ： 发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）。







## 8. 单继承结构

> #### 是否所有的类都应该默认从一个基类继承呢？这个答案在 Java 中是肯定的（实际上，除 C++ 以外的几乎所有OOP语言中也是这样）。在 Java 中，这个最终基类的名字就是 `Object`。

> #### 单继承的结构使得垃圾收集器的实现更为容易。
>
> #### 由于运行期的类型信息会存在于所有对象中，所以我们永远不会遇到判断不了对象类型的情况。这对于系统级操作尤其重要，例如 异常处理 。同时，这也让我们的编程具有更大的灵活性。







## 9. 集合

> #### 我们如何知悉程序在运行时需要分配的内存空间呢？在 `面向对象的设计` 中，问题的解决方案有些过于轻率：创建一个新类型的对象来引用、容纳其他的对象。

> #### `“集合”` 这种类型的对象可以存储任意类型、数量的其他对象。它能根据需要自动扩容，我们不用关心过程是如何实现的。



#### 选择集合的两个原因：

- #### 集合可以提供不同类型的接口和外部行为。

- #### 不同的集合对某些操作有不同的效率。



> - #### `“向下转型”` ： 使用强制类型转换将基类转换为更具体的类型。

> - #### 以某种方式创建集合，以确认保存元素的具体类型，减少集合元素“向下转型”的开销和可能出现的错误，这种解决方案就是： `参数化类型机制（Parameterized Type Mechanism）`
>
>     - #### 参数化类型机制 可以使得编译器能够自动识别某个 `class` 的具体类型并正确地执行。Java 5支持参数化类型机制，称之为 `“泛型”` 。







## 10. 对象创建与生命周期

> - #### 在 栈内存 开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。
>
> - #### 开辟 堆内存 空间的时间取决于内存机制的设计。
>
> - #### 在 栈内存 中创建对象，编译器能够确定该对象的生命周期并自动销毁它；然而如果你在 堆内存 创建对象的话，编译器是不知道它的生命周期的。







## 11. 异常处理

> #### 多数错误处理方案的主要问题是：它们依赖程序员之间的 约定俗成 而不是 语言层面的限制 。换句话说，如果程序员赶时间或没想起来，这些方案就很容易被忘记。

> #### 异常处理机制将程序错误直接交给 `编程语言` 甚至是 `操作系统` 。

> - #### `“异常”` ：是一个从出错点 “抛出” 后能被特定类型的异常处理程序 “捕获” 的一个 `对象` 。
>
> - #### 它不会干扰程序的正常运行，仅当程序出错的时候才被执行。异常的发生是 不会被忽略 的，它终究会在某一时刻被处理。
>
> - #### “异常机制”提供了一种可靠的 从错误状况中恢复的方法 ，使得我们可以编写出更健壮的程序。

> #### 值得注意的是， 异常处理并不是面向对象的特性 。尽管在面向对象的语言中异常通常由对象表示，但是在面向对象语言之前也存在异常处理。







## 12. 本章小结

> #### 面向过程程序包含 数据定义 和 函数调用 。
>
> #### 你看到的是对象的概念，这些概念是站在 “问题空间” 的（而不是站在计算机角度的 “解决方案空间” ），以及发送消息给对象以指示该空间中的活动。









# [第二章 安装Java和本书用例](https://njuics.github.io/OnJava8/#/book/02-Installing-Java-and-the-Book-Examples?id=第二章-安装java和本书用例)(略)









# [第三章 万物皆对象](https://njuics.github.io/OnJava8/#/book/03-Objects-Everywhere?id=第三章-万物皆对象)

## 1. 对象操作

> #### Java 利用 `万物皆对象` 的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的 `“引用”`





## 2. 对象创建

> #### “引用” 用来 关联 “对象”。在 Java 中，通常我们使用`new`操作符来创建一个新对象。





### (1) 数据存储

> #### 计算机有5个不同的地方可以存储数据：
>
> - #### `寄存器` ：最快的存储区域，位于CPU内部，数量十分有限，按需分配，没有直接控制权，也无法在自己的程序里找到寄存器存在的踪迹。
>
> - #### `栈内存` ：存在于常规内存RAM区域中，栈指针下移分配内存，上移释放内存。仅次于寄存器的快速有效的分配存储方式。
>
> - #### `堆内存` ：是一种通用的内存池(存在于RAM区域)，所有Java对象都存在于其中，与栈内存不同，编译器无需知道对象必须在堆内存上停留多长时间。
>
> - #### `常量存储` ：常量值通常直接放在程序代码中。因为它永远不会改变。如需严格保护，可以考虑将它们至于ROM中。
>
> - #### `非RAM存储` ：数据完全存在于程序之外，在程序未运行以及脱离程序控制之后依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于RAM的对象。
>
>     - ##### （1）`序列化对象` ：对象被转换为字节流，通常被发送到另一台机器；
>
>     - ##### （2）`持久化对象` ：对象被放置在磁盘上，即使程序终止，数据依然存在。







### (2) 基本类型的存储

> #### Java的基本类型不是通过new关键字来产生，因为new出来的对象保存在堆中，以此方式创建小而简单的变量是不划算的。所以Java使用一个“自动”变量，这个变量直接存储值并 置于栈中 ，因此更加高效。



```
/* 自动装箱 */
Character ch = 'x';
/* 自动拆箱 */
char c = ch;
```







### (3) 高精度数值

> #### `BigInteger` 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 `BigDecimal` 支持任意精度的定点数字。







### (4) 数组的存储

> #### 在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。
>
> #### 当我们创建 对象数组 时，实际上是创建了一个 引用数组 ，并且每个引用的初始值都为 **null** 。





## 3. 代码注释

```
/* 这是
* 跨越多行的
* 注释
*/
/* 这是跨越多
行的注释 */
// 这是单行注释
```





## 4. 对象清理

### (1) 作用域

> #### `作用域` 决定了在该范围内定义的变量名的 可见性 和 生存周期 。在 Java 中，作用域是由大括号 `{}` 的位置决定的。

```
/* Java 中，你不能执行以下操作，即使这在 C 和 C++ 中是合法的 */
{
    int x = 12;
    {
        int x = 96; // Illegal
    }
}
/* Java 的设计者认为隐藏变量会导致程序混乱 */
```



### (2) 对象作用域

> #### 当我们使用 `new` 关键字来创建 Java 对象时，它的生命周期将会 超出作用域 。







## 5. 类的创建

### (1) 类型

> #### 大多数面向对象的语言都使用 `class` 关键字类来描述一种新的对象。





### (2) 字段

> #### 创建一个类后，我们可以往类里存放两种类型的元素：方法 和 字段 。

> #### `类的字段` 可以是 基本类型 ，也可以是 引用类型 。通常，字段不在对象间共享。

```
class DataOnly {
    int i;
    double d;
    boolean b;
}
```





### (3) 基本类型默认值

| 基本类型 |    初始值     |
| :------: | :-----------: |
| boolean  |     false     |
|   char   | \u0000 (null) |
|   byte   |   (byte) 0    |
|  short   |   (short) 0   |
|   int    |       0       |
|   long   |      0L       |
|  float   |     0.0f      |
|  double  |     0.0d      |

> #### 这种默认值的赋予并不适用于 局部变量 —— 那些不属于类的字段的变量。如果我们忘记了初始化局部变量， Java 将会报错：“编译时错误，该变量可能尚未被初始化”。 这一点做的比 C++ 更好，在后者中，编译器只是提示警告，而在 Java 中则直接报错。





### (4) 方法使用

> #### 在 Java 中，我们使用术语 `方法` 来表示“做某事的方式”。在 Java 中，方法决定对象能接收哪些消息。
>
> #### Java 中的方法只能 作为类的一部分创建 ， 它只能 被对象所调用 。
>
> #### `调用方法` 的行为有时被称为 向对象发送消息 。

```
/* 方法格式 */
 [返回类型] [方法名](/*参数列表*/){
     // 方法体
 }
/* 调用对象的方法 */
[对象引用].[方法名](参数1, 参数2, 参数3);
```









### (5) 返回类型

> #### `方法的返回类型` 表明了当你调用它时会返回的结果类型。返回类型必须与接受变量的类型兼容。
>
> #### `return关键字` ：它意味着“方法执行结束” ； 如果方法有返回值，那么该值就紧跟 **return** 语句之后。





### (6) 参数列表

> #### `方法参数列表` 指定了传递给方法的信息。

> #### 方法名 和 参数列表 统称为 `方法签名` 。签名是方法的唯一标识。







## 6. 程序编写

### (1) 命名可见性

> #### Java 为一个类库生成一个明确的名称，Java 创建者希望我们 反向使用 自己的网络域名，因为域名通常是唯一的。如今 整个包名都是小写的。
>
> #### 此机制意味着所有文件都自动存在于自己的命名空间中，文件中的每个类都具有唯一标识符。

> #### 使用 反向 URL 将命名空间与文件路径相关联不会导致BUG，但它却给源代码管理带来麻烦。





### (2) 使用其他组件

> #### 必须通过使用 **`import`** 关键字来告诉 Java编译器 具体要使用的类。**`import`** 指示编译器导入一个包，也就是一个类库。





### (3) static 关键字

> #### 通常只有在使用 `new` 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的：
>
> - #### 有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。
>
> - #### 创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。

> #### 当我们说某个事物是 `静态` 时，就意味着 该字段或方法不依赖于任何特定的对象实例 。即使我们从未创建过该类的对象，也可以调用其 静态方法 或访问其 静态字段 。

> #### 我们可以在类的字段或方法前添加 `static` 关键字来表示这是一个静态字段或静态方法。引用静态变量有两种方法 ———— 对象引用 和 类名引用 。

> #### 正如我们所知，`static` 关键字的这些特性对于应用程序入口点的 `main()` 方法尤为重要。





## 7. 编码风格

> - #### `类名` 的首字母大写。如果类名是由多个单词构成的，则每个单词的首字母都应大写（不采用下划线来分隔）
>
> - #### 对于几乎所有其他 `方法` ，`字段` 和 `对象引用名` 都采用驼峰命名的方式，但是它们的首字母不需要大写。







# [第四章 运算符](https://njuics.github.io/OnJava8/#/book/04-Operators?id=第四章-运算符)

## 1. 开始使用

> #### 一些运算符可改变运算对象的值，这叫作 “副作用” 。

> #### 几乎所有运算符都只能操作基本类型。唯一的例外是 `=`、`==` 和 `!=`，它们能操作所有对象。除此以外，**String** 类支持 `+` 和 `+=`。





## 2. 优先级

> #### 运算符的优先级决定了存在多个运算符时一个表达式各部分的运算顺序。

> #### 在 `System.out.println()` 语句中使用了 `+` 运算符。 但是在这里 `+` 代表的意思是字符串连接符。编译器会将 `+` 连接的非字符串尝试转换为字符串。





## 3. 赋值

> #### 运算符的赋值是由符号 `=` 完成的。它代表着获取 `=` 右边的值并赋给左边的变量。 `右边` 可以是任何 常量 、 变量 或者 可产生一个返回值的表达式 。但 `左边` 必须是一个 明确的、已命名的变量 。

### (1) 方法调用中的别名现象

> #### 当我们把对象传递给方法时，会发生别名现象。

```
// operators/PassObject.java
// 正在传递的对象可能不是你之前使用的
class Letter {
    char c;
}
public class PassObject {
    static void f(Letter y) {
        y.c = 'z';
    }
    
    public static void main(String[] args) {
        Letter x = new Letter();
        x.c = 'a';
        System.out.println("1: x.c: " + x.c);
        f(x);
        System.out.println("2: x.c: " + x.c);
     }
}
```





## 4. 算数运算符

> #### +、-、*、/、%、op=



### 一元加减运算符

- #### 一元减号 可以得到数据的负值。 一元加号 的作用相反，不过它唯一能影响的就是把较小的数值类型自动转换为 **int** 类型。





## 5. 递增和递减

> - #### “前递增”表示 `++` 运算符位于变量或表达式的前面；“后递增”表示 `++` 运算符位于变量的后面。
>
> - #### “前递减”表示  `--` 运算符位于变量或表达式的前面；“后递减”表示  `--` 运算符位于变量的后面。
>
> - #### 对于前递增和前递减，会先执行递增/减运算，再返回值。而对于后递增和后递减，会先返回值，再执行递增/减运算。





## 6. 关系操作符

> #### 关系运算符会通过产生一个布尔结果来表示操作数之间的关系。

### (1) 测试对象等价

> #### 关系运算符 `==` 和 `!=` 同样适用于所有对象之间的比较运算。但 `==` 和 `!=` 比较的是对象引用。

> - #### 必须使用所有对象（不包括基本类型）中都存在的 `equals()` 方法才可以比较两个对象的 内容 是否相同。
>
> - #### 而且`equals()` 的默认行为是比较对象的引用而非具体内容。因此，除非你在新类中覆写 `equals()` 方法，否则我们将获取不到想要的结果。
>
> - #### 大多数 Java 库类通过覆写 `equals()` 方法比较对象的内容而不是其引用。





## 7. 逻辑运算符

> #### 每个逻辑运算符 `&&`、`||`和 `!`根据参数的逻辑关系生成布尔值 `true` 或 `false`。
>
> #### 在 Java 逻辑运算中，我们不能像 C/C++ 那样使用 非布尔值 ， 而仅能使用 **AND**、 **OR**、 **NOT**。

> #### 如果在预期为 **String** 类型的位置使用 **boolean** 类型的值，则结果会自动转为适当的文本格式。

### (1) 短路

> - #### `“短路”现象` ： 整个表达式会在运算到可以明确结果时就停止并返回结果，这意味着该逻辑表达式的后半部分不会被执行到。
>
> - #### 运用“短路”可以节省部分不必要的运算，从而提高程序潜在的性能。





## 8. 字面值常量

> #### 在文本值的后面添加字符可以让编译器识别该文本值的类型：
>
> - #### 对于 **Long** 型数值，结尾使用大写 `L` 或小写 `l` 皆可；
>
> - #### 对于 **float** 型数值，结尾使用大写 `F` 或小写 `f` 皆可；
>
> - #### 对于 **double** 型数值，结尾使用大写 `D` 或小写 `d` 皆可；
>
> - #### 十六进制 ，适用于所有整型数据类型，由前导 `0x` 或 `0X` 表示，后跟 0-9 或 a-f （大写或小写）；
>
> - #### 八进制 由 0~7 之间的数字和前导零 `0` 表示；
>
> - #### 二进制 由0/1的数字和前导 `0b` 或 `0B` 表示；

### (1) 下划线

> #### 我们可以在数字字面量中包含 下划线  `_` ，以使结果更清晰。
>
> - #### 仅限单 `_`，不能多条相连
>
> - #### 数值开头和结尾不允许出现 `_`
>
> - #### `F`、`D` 和 `L`的前后禁止出现 `_`
>
> - #### 二进制前导 `b` 和 十六进制 `x` 前后禁止出现 `_`



### (2) `%n`的使用

> #### Java 用 `%n` 实现的可以忽略平台间差异而生成适当的换行符，但只有当你使用 `System.out.printf()` 或 `System.out.format()` 时才可以使用 `%n`。
>
> #### 对于 `System.out.println()`，我们仍然必须使用 `\n`；如果你使用 `%n`，`println()` 只会输出 `%n` 而不是换行符。



### (3) 指数计数法

> #### Java 里用一种更精确的 **double** 值 **Math.E** 来表示 自然对数

```
float f4 = 1e-43f; //10 的幂数
```

> #### 编译器通常会将指数作为 **double** 类型来处理，所以假若没有这个后缀字符 `f`，编译器就会报错，提示我们应该将 **double** 型转换成 **float** 型。







## 9. 位运算符

> #### 位运算符允许我们操作一个整型数字中的单个二进制位。位运算符会对两个整数对应的位执行布尔代数，从而产生结果。

> #### `&` 、 `|`  、 `^`  、 `~` 、 `&=` 、 `|=` 、 `^=` 

> #### 对于 布尔值 ， 位运算符 具有与 逻辑运算符 相同的效果，只是它们 不会中途“短路” 。





## 10. 移位运算符

> - #### 左移位运算符 `<<` ： 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0 ）。
>
> - #### “分正负”的右移位运算符 `>>` ： 若值为正，则在高位插入 0 ；若值为负，则在高位插入 1 。
>
> - #### “不分正负”的右移位运算符 `>>>` ： 使用了“零扩展”——无论正负，都在高位插入 0 。

> #### 如果移动 **char** 、 **byte** 或 **short** ，则会在移动发生之前将其提升为 **int** ，结果为 **int**。

> #### 移位可以与等号 `<<=` 或 `>>=` 或 `>>>=` 组合使用。若将 `>>>=` 与 **byte** 或 **short** 一起使用的话，则结果错误。取而代之的是，它们被提升为 **int** 型并右移，但在重新赋值时被截断。





## 11. 三元运算符

> #### 也称条件运算符： **布尔表达式 ? 值 1 : 值 2** ；
>
> #### 与 **if-else** 不同的是，三元运算符是有返回结果的。





## 12. 字符串运算符

> #### 若表达式以一个 **String** 类型开头，那么后续所有运算对象都必须是字符串。这种转换与数据的位置无关，只要当中有一条数据是字符串类型，其他非字符串数据都将被转换为字符串形式并连接。

> #### 我们经常会看到一个空字符串 `""` 跟着一个基本类型的数据。这样可以隐式地将其转换为字符串，以代替繁琐的显式调用方法(.toString)





## 13. 常见陷阱

```
while(x = y) {
// ...
}
//该错误Java在试图运行前收到编译期错误，故天生避免了这种陷阱发生的可能性
//唯一有种情况例外：当变量 x 和 y 都是布尔值，例如 x=y 是一个逻辑表达式。
```





## 14. 类型转换

> #### `“类型转换”` 的作用是 “与一个模型匹配” 。
>
> - #### 在适当的时候，Java 会将一种数据类型 自动转换 成另一种。
>
> - #### 我们也可以在程序未自动转换时 显式、强制 地使此类型发生转换。

> - #### 为了 程序逻辑清晰 或 提醒自己留意 ，我们可以显式地类型转换。
>
> - #### 在其他情况下，类型转换只有在 代码编译 时才显出其重要性。
>
> - #### 在 Java 里，类型转换则是一种比较安全的操作。但是，若将数据类型进行 “向下转换” 的操作，可能会发生信息丢失的危险。

> - #### 除了 布尔类型 的数据，Java 允许任何 基本类型 的数据转换为另一种基本类型的数据。
>
> - #### 此外， 类 是不能进行类型转换的。

### (1) 截断和舍入

> #### 在执行 “向下转换” 时，必须注意数据的 截断和舍入 问题。

> - #### 从 **float** 和 **double** 转换为整数值时，小数位将被 `截断` 。
>
> - #### 若你想对结果进行 `四舍五入` ，可以使用 `java.lang.Math` 的 `round()` 方法 。



### (2) 类型提升

> #### 如果我们对小于 **int** 的基本数据类型执行任何算术或按位操作，这些值会在执行操作之前 `类型提升` 为 **int**，并且结果值的类型为 **int**。若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。







## 15. Java没有sizeof

> #### C/C++ 中使用 `sizeof()` 最有说服力的原因是为了移植性，同数据在不同机器上可能有不同的大小，所以在进行大小敏感的运算时，程序员必须对这些类型有多大做到心中有数。

> #### Java 不需要 `sizeof()` 方法来满足这种需求，因为所有类型的大小在不同平台上是相同的。Java 本身就是一种 “与平台无关” 的语言。





## 16. 运算符总结 (略)









# [第五章 控制流](https://njuics.github.io/OnJava8/#/book/05-Control-Flow?id=第五章-控制流)

> #### 在 Java 中，涉及的关键字包括 **`if-else` ，`while` ，`do-while` ，`for` ，`return` ，`break`** 和选择语句 **`switch`**。 Java 并不支持备受诟病的 **`goto`** 。

## 1. true 和 false

> #### 所有的条件语句都利用 条件表达式的“真”或“假” 来决定执行路径。





## 2. if-else

```
if(Boolean-expression) 
    “statement”
else
  “statement”
```





## 3. 迭代语句

> #### **while** ，**do-while** 和 **for** 用来控制循环语句（有时也称迭代语句）。只有控制循环的布尔表达式计算结果为 `false`，循环语句才会停止。

### (1) while

```
while(Boolean-expression) 
  statement
```

### (2) do-while

```
do 
    statement
while(Boolean-expression);
```

### (3) for

```
for(initialization; Boolean-expression; step)
  statement
```



### (4) 逗号操作符

> #### 逗号运算符在 **for** 循环的初始化和步进控制中定义多个变量。我们可以使用逗号分隔多个语句，并按顺序计算这些语句。**注意**：要求定义的变量类型相同。







## 4. for-in 语法

> #### *for-in* 无需你去创建 **int** 变量和步进来控制循环计数。*for-in* 循环适用于任何 可迭代的 对象。

> #### *for-in* 语法可以 节省我们编写代码的时间 。 提高代码可读性 以及 更好地描述代码意图 而不是详细说明操作细节。







## 5. return

> #### 在 Java 中，**return** ， **break** ， **continue** 代表 `无条件分支` ，这意味无需任何测试即可发生。

> #### `return 关键字` 有两方面的作用：
>
> - #### 指定一个方法返回值；
>
> - #### 退出当前方法，并返回方法返回值。







## 6. break 和 continue

> #### **break** 表示跳出当前循环体。而 **continue** 表示停止本次循环，开始下一次循环。







## 7. 臭名昭著的 goto

> #### 尽管 **goto** 仍是 Java 的一个保留字，但其并 未被正式启用 。可以说， Java 中并不支持 **goto**。

> #### `“标签”` 是后面跟一个冒号的标识符。
>
> #### **break** 和 **continue** 关键字通常只中断当前循环，但若搭配 标签 一起使用，它们就会中断并跳转到标签所在的地方开始执行。

```
label1:
outer-iteration { 
  inner-iteration {
  // ...
  break; // [1]  break 中断内部循环，并在外部循环结束。
  // ...
  continue; // [2] continue 移回内部循环的起始处。
  // ...
  continue label1; // [3] continue label1 却中断内部及外部循环，并移至 label1 处。继续从外部循环开始进入循环。
  // ...
  break label1; // [4]  break label1 也会中断所有循环，并回到 label1 处，但并不重新进入循环。
  } 
}
```

> - #### **continue** 会退回最内层循环的开头（顶部），并继续执行。
>
> - #### 带有标签的 **continue** 会到达标签的位置，并重新进入紧接在那个标签后面的循环。
>
> - #### **break** 会中断当前循环，并移离当前标签的末尾。
>
> - #### 带标签的 **break** 会中断当前循环，并移离由那个标签指示的循环的末尾。







## 8. switch

> #### 根据整数表达式的值，**switch** 语句可以从一系列代码中选出一段去执行。
>
> #### **switch** 语句是一种实现多路选择的干净利落的一种方式

```
switch(integral-selector) {
    case integral-value1 : statement; break;
    case integral-value2 : statement;    break;
    case integral-value3 : statement;    break;
    case integral-value4 : statement;    break;
    case integral-value5 : statement;    break;
    // ...
    default: statement;
}
```





## 9. switch 字符串

```
// control/StringSwitch.java
public class StringSwitch {
  public static void main(String[] args) {
    String color = "red";
    switch(color) {
      case "red":
        System.out.println("RED");
        break;
      case "green":
        System.out.println("GREEN");
        break;
      case "blue":
        System.out.println("BLUE");
        break;
      case "yellow":
        System.out.println("YELLOW");
        break;
      default:
        System.out.println("Unknown");
        break;
    }
  }
}
```





## 10. 本章小结

> #### 本章总结了我们对大多数编程语言中出现的基本特性的探索： 计算 ， 运算符优先级 ， 类型转换 ， 选择 和 迭代 。 现在让我们准备好，开始步入面向对象和函数式编程的世界吧。 下一章的内容涵盖了 Java 编程中的重要问题：对象的[初始化和清理](https://njuics.github.io/OnJava8/#/./06-Housekeeping)。紧接着，还会介绍[封装](https://njuics.github.io/OnJava8/#/./07-Implementation-Hiding)核心概念。









# [第六章 初始化和清理](https://njuics.github.io/OnJava8/#/book/06-Housekeeping?id=第六章-初始化和清理)

> #### Java 采用了 构造器 的概念，另外还使用了 垃圾收集器 去自动回收不再被使用的对象所占的资源。

## 1. 利用构造器保证初始化

> #### 在 Java 中，类的设计者通过 构造器 保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即 对象刚创建完成 ）自动调用对象的构造器方法，从而保证初始化。

> #### 从概念上来看，`initialize()` 方法应该与对象的创建分离。但在 Java 中，对象的 创建 与 初始化 是统一的概念，二者不可分割。





## 2. 方法重载

> #### 大多数人类语言都具有 "冗余"性 ，所以即使漏掉几个词，你也能明白含义。你不需要对每个概念都使用不同的词汇——可以从上下文推断出含义。
>
> #### 所以 `方法重载` 是必要的，它允许方法具有 相同的方法名  但 接收的参数不同 。

### (1) 区分重载方法

> #### 每个被重载的方法通过独一无二的参数列表进行区分。



### (2) 重载与基本类型

> #### 如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。



### (3) 返回值的重载

> #### 你可以调用一个方法且忽略返回值。这叫做调用一个函数的副作用，因为你不在乎返回值，只是想利用方法做些事。所以如果你直接调用 `f()`，Java 编译器就不知道你想调用哪个方法，阅读者也不明所以。







## 3. 无参构造器

> #### `无参构造器` 就是 不接收参数的构造器 ，用来创建一个 "默认的对象" 。

> #### 如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。
>
> #### 但是,一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。







## 4. this 关键字

> #### 方法中第一个参数 隐密地 传入了一个 指向操作对象的引用 。

> #### 假设现在在方法内部，你想获得对当前对象的引用。但是，对象引用是被秘密地传达给编译器——并不在参数列表中。
>
> - #### `this 关键字` 只能在 非静态方法 内部使用。当你调用一个对象的方法时，**this** 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。
>
> - #### `this 关键字` 只用在一些必须 显式使用当前对象引用 的特殊场合。

> #### 用法：
>
> - #### 用在 **return** 语句中返回对当前对象的引用。
>
> - #### 用于向其他方法传递当前对象。
>
> - #### 通过 `this.s` 表明你指的是成员变量 **s**，从而避免重复，引起混淆。

### (1) 在构造器中调用构造器

> #### 当你在一个类中写了多个构造器，有时你想 在一个构造器中调用另一个构造器 来避免代码重复。你通过 **this** 关键字 实现这样的调用。
>
> #### 必须首先调用构造器，否则编译器会报错。



### (2) static 的含义

> #### **static** 方法中不会存在 **this** 。不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。

> #### 使用静态方法，因为不存在 **this**，所以你没有向一个对象发送消息。







## 5. 垃圾回收器

> #### Java中有 垃圾回收器 回收无用对象占用的内存。但 垃圾回收器 只知道如何释放 用 `new` 创建 的对象的内存，所以他不知道如何回收不是new分配的内存。为了处理这种情况，Java允许在类中定义一个名为 `finalize()` 的方法。

> - #### 对象可能不被垃圾回收；
>
> - #### 垃圾回收不等同于析构；
>
> - #### 垃圾回收只与内存有关；
>
> - #### 在不再需要某个对象之前，如果必须执行某些动作，必须要自己去做。即在 `finalize()` 方法中加入某种删除功能，那么当“垃圾回收”发生时， `finalize()` 方法被调用，其对象就会被删除，若“垃圾回收”没有发生，其对象则会被保留。

> #### 这种情况主要发生在使用"本地方法"的情况下， `本地方法` 是一种用 Java 语言调用非 Java 语言代码的形式。本地方法目前只支持 C 和 C++，但是它们可以调用其他语言写的代码，所以实际上可以调用任何代码。

### (1) 你必须实施清理

> #### 在 Java 中，没有用于释放对象的 **delete**，因为垃圾回收器会帮助你释放存储空间。但如果希望进行 除释放存储空间之外的清理工作 ，还是得明确调用某个恰当的 Java 方法：这就等同于使用析构函数了，只是没有它方便。

> #### 无论是 "垃圾回收" 还是 "终结" ，都 `不保证一定会发生` 。如果 Java 虚拟机并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。



### (2) 终结条件

> #### `finalize()` 还有一个有趣的用法，它不依赖于每次都要对 `finalize()` 进行调用，这就是 对象终结条件的验证 。
>
> #### `finalize()` 可以用来最终发现 由于“对象中存在没有被适当清理的部分” 而导致的隐晦的bug 。尽管它并不总是被调用。

```
// housekeeping/TerminationCondition.java
// Using finalize() to detect a object that
// hasn't been properly cleaned up

import onjava.*;

class Book {
    boolean checkedOut = false;

    Book(boolean checkOut) {
        checkedOut = checkOut;
    }

    void checkIn() {
        checkedOut = false;
    }

    @Override
    protected void finalize() throws Throwable {
        if (checkedOut) {
            System.out.println("Error: checked out");
        }
        // Normally, you'll also do this:
        // super.finalize(); // Call the base-class version
    }
}

public class TerminationCondition {

    public static void main(String[] args) {
        Book novel = new Book(true);
        // Proper cleanup:
        novel.checkIn();
        // Drop the reference, forget to clean up:
        new Book(true);
        // Force garbage collection & finalization:
        System.gc();
        new Nap(1); // One second delay
    }
}
```

> - #### `@` 意味着这是一个注解， `注解` 是关于代码的额外信息。
>
> - #### `System.gc()` 用于强制进行终结动作。



### (3) 垃圾回收器如何工作

> #### 垃圾回收器能很明显地提高对象的创建速度。

> - #### 可以把 C++ 里的堆想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间后，对象可能被销毁，但地盘必须复用。
>
> - #### Java 虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个新对象，它就向前移动一格。这意味着对象存储空间的分配速度特别快。
>
>     - ##### Java 的"堆指针"只是简单地移动到尚未分配的区域，所以它的效率与 C++ 在栈上分配空间的效率相当。当然实际过程中，在 簿记工作 方面还有少量额外开销，但是这部分开销比不上查找可用空间开销大。

> - #### 垃圾回收器的介入，它一边 回收内存 ，一边 使堆中的对象紧凑排列 ，这样 “堆指针” 就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误
>
> - #### 垃圾回收器通过 重新排列对象 ，实现了一种 高速的 、有 无限空间 可分配的堆模型。



#### 垃圾回收机制：

- #### *`引用计数`* ： 简单但速度很慢，而且无法处理循环引用现象。

    - #### 每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加1 ； 当引用离开作用域或被置为 **null** 时，引用计数减1。

    - #### 垃圾回收器会遍历含有全部对象的列表，当发现某个对象的引用计数为 0 时，就释放其占用的空间。

- #### *`自适应`*： 可以解决循环引用问题

    - #### 从栈或静态存储区出发，遍历所有的引用，对于发现的每个引用，必须追踪它所引用的对象(堆区中)；

    - #### 然后是该对象包含的所有引用，如此反复进行，直到访问完"根源于栈或静态存储区的引用"所形成的整个网络；

    - #### 这样可以保证所访问过的对象一定是"活"的；

    - #### 停止-复制 ： 代价大、少量垃圾时会产生浪费； 若没有新垃圾产生，转换到 标记-清扫 模式 ： 速度慢，但少量垃圾其速度相较而言就快了

> #### Java 虚拟机会监视，如果所有对象都很稳定，垃圾回收的效率降低的话，就切换到"标记-清扫"方式。同样，Java 虚拟机会跟踪"标记-清扫"的效果，如果堆空间出现很多碎片，就会切换回"停止-复制"方式。



#### Java虚拟机加速方法：

- #### `"即时"编译器技术` ： 把程序全部或部分翻译成本地机器码，所以不需要 JVM 来进行翻译，因此运行得更快。

    - #### 这种加载动作贯穿整个程序生命周期内，累加起来需要花更多时间；

    - #### 会增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这会导致页面调度，从而一定程度上降低程序速度。

- #### `惰性评估技术` ： 即时编译器只有在必要的时候才编译代码。新版 JDK 中的 Java HotSpot 技术就采用了类似的做法， 代码每被执行一次就优化一些 ，所以执行的次数越多，它的速度就越快。







## 6. 成员初始化

> #### Java 尽量保证所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，这种保证会以编译时错误的方式呈现。

### (1) 指定初始化

> - #### 很直接的方法是在定义类成员变量的地方为其赋值。
>
> - #### 也可以通过调用某个方法来提供初值。







## 7. 构造器初始化

> #### 构造器初始化提供了更大的灵活性，因为可以在运行时调用方法进行初始化。但这无法阻止自动初始化的进行，它会在构造器被调用之前发生。

### (1) 初始化的顺序

> #### 变量定义的顺序决定了初始化的顺序，即使变量定义散布在方法定义之间，它们仍会在任何方法(包括构造器)被调用之前得到初始化。

> #### 初始化的顺序先是静态对象（如果它们之前没有被初始化的话），然后是非静态对象，最后是构造器初始化。



### (2) 静态数据初始化

> #### 无论创建多少对象，静态数据都只占用一份存储区域。static关键字不能作用于局部变量，而只能作用于属性。



### (3) 显式的静态初始化

> #### 可以将 一组静态初始化动作 放在类里面一个特殊的 `"静态子句"` （有时叫做 `静态块` ）中。



### (4) 非静态实例初始化

> #### Java 提供了被称为 *`实例初始化`* 的类似语法，用来初始化每个对象的非静态变量。看起来它很像静态代码块，只不过少了 **static** 关键字。







## 8. 数组初始化

> - #### `数组` 是 相同类型的 、 用一个标识符名称封装到一起的一个 对象序列 或 基本类型数据序列 。
>
> - #### Java 在访问数组超出边界时，会报运行时错误（异常），从而避免问题。
>
> - #### 初始化列表的最后一个逗号时可选的，这一特性使维护长列表变得容易。

### (1) 动态数组创建

> #### 如果在编写程序时，不确定数组中需要多少个元素，可以使用 **new** 在数组中创建元素。
>
> #### 如果可能的话，尽可能在定义数组的同时进行初始化。



### (2) 可变参数列表

> #### 可以以一种 `可变参数列表` 的方式来创建和调用方法，这可以应用在参数个数或类型未知的场合。

> #### 如果你有一组事物，可以把它们当作列表传递 ； 而如果你已经有了一个数组，该方法会把它们当作可变参数列表来接受。

> #### 可变参数列表中可以使用任何类型的参数，包括基本类型。

> #### 可变参数列表使得方法重载更加复杂，编译器会使用自动装箱来匹配重载的方法，然后调用最精确匹配的方法。
>
> #### 应该总是在重载方法的一个版本上使用可变参数列表，或者压根不用它。







## 9. 枚举类型

> #### `enum 关键字` ： 使得我们在需要群组并使用枚举类型集时，可以很方便地处理。

> #### 创建 **enum** 时，编译器会自动添加一些有用的特性。例如：
>
> - #### `toString()` 方法，以便你方便地显示某个 **enum** 实例的名称
>
> - #### `ordinal()` 方法表示某个特定 **enum** 常量的声明顺序
>
> - #### `static values()` 方法按照 enum 常量的声明顺序，生成这些常量值构成的数组







## 10. 本章小结

> - #### `构造器` ，这种看起来精巧的初始化机制，应该给了你很强的暗示：初始化在编程语言中的重要地位。
>
> - #### 在 Java 中，`垃圾回收器` 会自动地释放所有对象的内存。不需要类似析构器行为的时候，Java 的垃圾回收器极大地简化了编程，并加强了内存管理上的安全性。

> #### 由于要保证所有对象被创建，实际上构造器比这里讨论得更加复杂。特别是当通过*组合*或*继承*创建新类的时候，这种保证仍然成立，并且需要一些额外的语法来支持。在后面的章节中，你会学习组合，继承以及它们如何影响构造器。











# [第七章 封装](https://njuics.github.io/OnJava8/#/book/07-Implementation-Hiding?id=第七章-封装)

> #### `重构` 就是重写可工作的代码，使之更加可读，易懂，因而更易维护。
>
> #### 面向对象设计中的一个基本问题：“如何区分变动的事物和不变的事物”。

> #### Java 提供了*`访问修饰符`*供类库开发者指明哪些对于客户端程序员是可用的，哪些是不可用的。访问控制权限的等级，从“最大权限”到“最小权限”依次是： **public** ， **protected** ， *包访问权限* 和 **private** 。

> #### 这里存在的一个问题是 ： 如何将类库组件捆绑到一个内聚的类库单元(包)中。

## 1. 包的概念

> #### `包` 内包含一组类，它们被组织在一个单独的*命名空间*下。
>
> #### 这种类名的潜在冲突，正是我们需要在 Java 中对命名空间进行完全控制的原因。

> - #### 一个 Java 源代码文件称为一个*`编译单元`*（有时也称*`翻译单元`*）。
>
> - #### 每个编译单元的文件名后缀必须是 **.java**。
>
> - #### 在编译单元中只能有一个 **public** 类，它的类名必须与文件名相同。
>
> - #### 如果这个编译单元中还有其他类，那么在包之外是无法访问这些类，此时它们为主 **public** 类提供“支持”类 。

### (1) 代码组织

> #### 当编译一个 **.java** 文件时， **.java** 文件的每个类都会有一个输出文件。每个输出的文件名和 **.java** 文件中每个类的类名相同，只是后缀名是 **.class**。因此， 在编译少量的 **.java** 文件后，会得到大量的 **.class** 文件 。
>
> #### 在 Java 中，可运行程序是一组 **.class** 文件，它们可以打包压缩成一个 `Java 文档文件` (JAR，使用 **jar** 文档生成器)。Java 解释器负责查找、加载和解释这些文件。

> #### 如果把这些public组件集中在一起，就需要使用关键字 **`package`** 。 并且package语句必须是文件中除了注释以外的第一行代码 。
>
> - ##### 注：Java 包名按惯例一律小写，即使中间的单词也需要小写，与驼峰命名不同。

> #### **`package`** 和 **`import`** 这两个关键字将单一的全局命名空间分隔开，从而避免名称冲突。





### (2) 创建独一无二的包名

> #### 一个包从未被真正打包成单一的文件，它可以由很多.class文件构成。为了避免混乱，Java采取将特定包下的所有.class文件都放在一个目录下，利用操作系统的文件结构的层次性解决混乱问题。
>
> #### 将所有的文件放在一个子目录还解决了其他的两个问题： 创建独一无二的包名 和 查找可能隐藏于目录结构某处的类 。

> #### Java解释器准备加载一个.class文件时，需要定位到class文件所在位置：
>
> - #### 首先，Java解释器找出环境变量 `CLASSPATH` (包含一个或多个目录)，用作查找.class文件的根目录。
>
> - #### 接着Java解释器获取包名并将句点替换成反斜杠，生成基于根目录的路径名称。
>
> - #### 该相对路径与 `CLASSPATH` 链接，解释器就在该绝对路径的目录下查找.class文件。
>
> - #### `CLASSPATH` 可以包含多个不同的搜索路径。但在使用 `JAR` 文件时，必须在类路径写清楚JAR文件的 实际名称 而非JAR文件的 所在目录 。





### (3) 冲突

> #### 如果通过 ***** 导入了两个包含相同类名的类库，就会存在潜在的 `冲突` 。
>
> #### 解决方法是指明索要使用的类的位置，或者只导入其中一个类以防止冲突。





### (4) 定制工具库

```
package onjava;
public class Range {
	...
}
```

> #### 这个文件的位置一定是在 `CLASSPATH\onjava` 的目录下，编译完成后就可以在系统的任何方法使用 import onjava 语句来使用这些方法了





### (5) 使用 import 改变行为

> #### Java 没有 C 的 *条件编译* 功能(该功能使得我们不必更改任何程序代码就能够切换开关产生不同的行为)
>
> #### Java 去掉此功能是因为条件编译多用于解决跨平台问题(程序代码的不同部分要根据平台的不同来进行编译)，Java本身就是跨平台的，所以此功能没有必要。





### (6) 使用包的忠告

> - #### 创建一个包时，包名隐含了目录结构。这个包必须位于 CLASSPATH\包名 的目录中。
>
> - #### 编译过的代码通常位于与源代码不同的目录中 ，这是很多工程的标准，而且IDE通常会自动为我们做这些。所以我们必须保证JVM可以找到 编译后的代码 。









## 2. 访问权限修饰符

> #### Java访问权限修饰符 `public` 、 `protected`  、 `private` 位于定义的 类名 、 属性名 、 方法名 之前。每个访问修饰符只能控制它所修饰的对象。

### (1) 包访问权限

> #### 默认访问权限没有关键字，通常被称为 *`包访问权限`* (有时也称为 **friendly**)，这意味着当前包中的所有其它类都可以访问该成员。这使得位于 同一编译单元 中的所有类彼此之间都是可访问的。

> #### 包里的类赋予了它们包访问权限的成员相互访问的权限。构建包访问权限机制是将类聚集在包中的重要原因之一。因而我们可以将不应当对当前包中的类具有访问权限的类排除在包外。



#### 取得对成员的访问权的方式有：

- #### 使成员成为 **public**。那么无论是谁，无论在哪，都可以访问它。

- #### 赋予成员默认包访问权限，不用加任何访问修饰符，然后将其他类放在相同的包内

- #### 继承的类既可以访问 **public** 成员，也可以访问 **protected** 成员

- #### 提供 访问器 和 修改器 方法，从而读取和改变值。

 



### (2) public：接口访问权限

> #### 当我们使用了关键字 `public` ，就意味着紧随其后声明的成员对于所有人都是可用的。





### (3) 默认包

> #### 当某一文件在某一目录中且没有给自己设定明确的包名。Java会将这样的文件看作 隶属于该目录的默认包 中，因此他们为该目录中的所有其他文件都提供了包访问权限。





### (4) private：你无法访问

> #### 关键字 **`private`** 意味着除了包含该成员的类，其他任何类都无法访问这个成员。
>
> #### 任何可以肯定只是该类的 "助手"方法 ，都可以声明为 **private**，以确保不会在包中的其他地方误用它，也有利于改变或删除它。





### (5) 继承访问权限

> #### 关键字 **protected** 处理的是继承的概念，通过继承可以利用一个现有的类(基类)，在其中 添加新成员 或 改变基类现有成员 以生成新类(继承类)，继承通过关键字 extend 进行声明。

> #### 使用关键字 protected 保证基类的某个特定成员能被继承类访问但不能被其他类访问。同时 protected 提供 包访问权限 ，即相同包内的其他类可以访问 protected 所修饰的成员。





### (6) 包访问权限 VS Public构造器

> #### 当定义一个具有包访问权限的类时，可以在该类中定义一个public构造器，编译器不会报错。但这种写法是虚假的，而且从技术上来说也是错误的，因为实际上我们不能从包外访问到这个public构造器。





## 3. 接口和实现

> #### 访问控制 通常被称为 *`隐藏实现`* 。 将数据和方法包装进类中并把具体实现隐藏被称作是 *`封装`* 。其结果就是一个同时带有 特征 和 行为 的数据类型。

#### 访问控制在数据类型内部划定边界的两个原因：

- #### 确立客户端程序员可以使用和不能使用的边界

- #### 将接口与实现分离

> #### 创建类风格 ： public 成员放在类开头，接着是 protected 成员 、 包访问权限成员 、 private 成员。
>
> #### 好处：类的使用者从头读起可以首先看到对他们而言最重要的东西。

> #### 类浏览器 ： 将接口展现给类的使用者，展示所有可用的类，并告诉你如何使用它们。









## 4. 类访问权限

> #### 访问权限修饰符也可以用于确定类库中的哪些类对于类库的使用者是可用的。

#### 限制：

- #### 每个编译单元（即每个文件）中只能有一个 **public** 类。

- #### **public** 类的名称必须与含有该编译单元的文件名相同，包括大小写。

- #### 虽然不是很常见，但是编译单元内没有 **public** 类也是可能的。这时可以随意命名文件（尽管随意命名会让代码的阅读者和维护者感到困惑）。

> #### 类既不能是 private 的，也不能是 protected 的 ， 为了防止类被外界访问，可以将所有的构造器声明为 **private** 。







## 5. 本章小结

> #### 无论在什么样的关系中，划定一些供各成员共同遵守的界限是很重要的。当你创建了一个类库，也就与该类库的使用者产生了联系，他们是类库的 客户端程序员 ，需要使用你的类库创建应用或更大的类库。
>
> #### 本章讨论了类库是如何通过类构建的：首先，介绍了将一组类打包到类库的方式，其次介绍了类如何控制对其成员的访问。











# [第八章 复用](https://njuics.github.io/OnJava8/#/book/08-Reuse?id=第八章-复用)

> #### Java 围绕“类”（Class）来解决问题。我们可以直接使用别人构建或调试过的代码，而非创建新类、重新开始。

#### 如何在不污染源代码的前提下使用现存代码：

- #### 在新类中创建现有类的对象。这种方式叫做 `“组合”` ，通过这种方式复用代码的功能，而非其形式。

- #### 创建现有类类型的新类。采用现有类形式，又无需在编码时改动其代码，这种方式就叫做 `“继承”` ，编译器会做大部分的工作。

## 1. 组合语法

> #### 仅需要把对象的引用放置在一个新的类里，这就使用了 `组合` 。对于 非基本类型 对象，将引用直接放置在新类中，对于 基本类型 属性字段则仅进行声明。

> #### **@Override** 是可选的，但它有助于验证你没有拼写错误

#### 初始化引用有4种方法：

- #### 当对象被定义时。

- #### 在该类的构造函数中。

- #### 在实际使用对象之前。这通常被称为 *延迟初始化* 。

- #### 使用实例初始化。







## 2. 继承语法

> #### 在创建类时总是要继承，要么显式地继承其他类，要么隐式地继承Java的标准根类对象(Object)。

> #### Java 的 **`super`** 关键字引用了当前类继承的 “超类”(基类) 。

### (1) 初始化基类

> #### 当创建派生类的对象时，它包含基类的子对象。这个子对象与创建基类的对象是一样的。只是从外部看，基类的子对象被包装在派生类的对象中。

> #### 只有通过调用 基类构造函数 ，并在构造函数中执行初始化，才可以正确地初始化基类子对象。该构造函数具有执行基类初始化所需的所有适当信息和特权。

> #### Java 自动在派生类构造函数中插入对基类构造函数的调用。构造从基类“向外”进行，因此 基类在派生类构造函数能够访问它 `之前` 进行初始化 。





### (2) 带参数的构造函数

> #### 如果必须调用带参数的基类构造函数，则必须使用 *`super`* 关键字和适当的参数列表显式地编写对基类构造函数的调用。

> #### 对基类构造函数的调用必须是派生类构造函数的第一个操作。









## 3. 委托

> #### Java 不直接支持的 第三种重用关系 称为 `委托` 。 
>
> #### 这介于 组合 和 继承 之间，因为我们将一个成员对象放在正在构建的类中，但同时又在新类中公开来自成员对象的所有方法。

```
public class SpaceShipControls {
  void up(int velocity) {}
  void down(int velocity) {}
  void left(int velocity) {}
  void right(int velocity) {}
  void forward(int velocity) {}
  void back(int velocity) {}
  void turboBoost() {}
}
public class SpaceShipDelegation {
  private String name;
  private SpaceShipControls controls =
    new SpaceShipControls();
  public SpaceShipDelegation(String name) {
    this.name = name;
  }
  // Delegated methods:
  public void back(int velocity) {
    controls.back(velocity);
  }
  public void down(int velocity) {
    controls.down(velocity);
  }
  public void forward(int velocity) {
    controls.forward(velocity);
  }
  public void left(int velocity) {
    controls.left(velocity);
  }
  public void right(int velocity) {
    controls.right(velocity);
  }
  public void turboBoost() {
    controls.turboBoost();
  }
  public void up(int velocity) {
    controls.up(velocity);
  }
  public static void main(String[] args) {
    SpaceShipDelegation protector =
      new SpaceShipDelegation("NSEA Protector");
    protector.forward(100);
  }
}
```

> #### 方法被转发到底层 control 对象，因此接口与继承的接口相同。但对委托有更多的控制，因为可以选择只在成员对象中提供方法的子集。

> #### 虽然 Java 语言不支持委托，但开发工具常常支持。









## 4. 结合组合与继承

> #### 尽管编译器强制要求初始化基类，并要求我们在构造函数的开头就初始化基类，但它并不监视代码以确保代码初始化了成员对象。

### (1) 保证适当的清理

> #### 在 Java 中，有时我们的类可能在其生命周期中会执行一些需要清理的活动。但我们无法得知垃圾收集器何时被调用，甚至是否会被调用。因此若想为类清理一些东西，则必须 显式地编写一个特殊的方法来完成它 。

> #### **`try`** 关键字表示后面的块是一个受保护的区域，这意味着它得到了特殊处理。其中一个特殊处理是，无论 **try** 块如何退出，在这个保护区域之后的 **`finally`** 子句中的代码总是被执行。

> #### 在清理方法中，还必须注意基类和成员对象清理方法的 `调用顺序` ：首先按与创建的相反顺序执行特定于类的所有清理工作，然后调用基类清理方法。

> #### 除了内存回收外，不能依赖垃圾收集来做任何事情。如果希望进行清理，可以使用自己的清理方法，而不要使用 `finalize()` 。





### (2) 名称隐藏

> #### 如果 Java 基类的方法名多次重载，则在派生类中重新定义该方法名不会隐藏任何基类版本。









## 5. 组合与继承的选择

> #### 组合和继承都允许在新类中放置子对象(组合是显式的，而继承是隐式的) 。

> #### 当我们想在新类中包含一个已有类的功能时，即想在新类中嵌入一个(通常是私有的)对象，使用 `组合` ， 此时新类的使用者看到的是我们所 定义的新类的接口 ，而非嵌入对象的接口。

> #### 当我们想使用一个现有类并开发出它的新版本时(通常这意味着使用一个 通用类 ，并为了某个特殊需求将其 特殊化 )，使用 `继承` 。

> #### `“是一个”` 的关系是用 *`继承`* 来表达的，而 `“有一个”` 的关系则用 *`组合`* 来表达。









## 6. protected

> #### 关键字 protected 表示： “就类的用户而言，这是 private 的，但对于任何继承它的子类或在同一包中的类，它是可访问的。”







## 7. 向上转型

> #### `继承` 是新类和基类的一种关系 ———— 即“新类是已有类的一种类型”

> #### 这种把 派生类对象引用 转换为 基类对象引用 的行为称为 *`向上转型`* 。 因为是从一个更具体的类转化为一个更一般的类，所以向上转型永远是 安全的 。

### (1) 再论组合和继承

> #### 在面向对象编程中，创建和使用代码最可能的方法是将数据和方法一起打包到类中，然后使用该类的对象。也可以使用已有的类通过组合来创建新类。而继承其实不太常用，我们要尽量少使用它。

> #### 只要记住问一问 “我需要向上转型吗？” ，就能在这两者中作出较好的选择。









## 8. final 关键字

> #### Java 的关键字 `final` 通常的含义是指 “这是不能被改变的” 。 

### (1) final 数据

> #### 编译时常量可以允许编译器在编译时计算，从而减少一些运行时的负担。 在 Java 中，这类常量必须是基本类型，而且要用关键字 final 修饰。

> #### 一个被 static 和 final 同时修饰的属性只会占用一段不能改变的存储空间。

> #### 当用 final 修饰对象引用时，表示该对象引用一旦被初始化指向某个对象，就不能改为指向其他对象。但对象本身是可以修改的，Java 没有提供将任何对象设为常量的方法。

> #### public static final 是一种更加典型的常量定义的方式： public 意味着可以在包外访问 ； static 强调只有一个 ； final 说明是一个常量

> #### 按照惯例，带有恒定初始值的 final static 基本变量(即编译时常量) 的命名全部使用 大写 ，单词之间用 下划线 分割。

### (1) 空白 final

> #### 空白 final 指的是没有初始化值的 final 属性。编译器确保空白 final 在使用前必须被初始化，这样既能使一个类的每个对象的 final 属性值不同，也能保持它的不变性。

> #### 必须在定义时或在每个构造器中执行 final 变量的赋值操作。





### (2) final 参数

> #### 在参数列表中，将参数声明为 final 意味着在该方法中不能改变参数指向的对象或基本类型。这个特性主要用于 传递数据给匿名内部类 。





### (3) final 方法

> #### 使用 final 方法的原因有两个：
>
> - #### 给方法上锁，防止子类通过覆写改变方法行为。确保方法的行为不会因继承而改变。
>
> - #### 效率。在早期 Java 实现中，如果一个方法被指明为 final ，就是同意编译器把对该方法的i奥永转化为内嵌调用(即编译器会用方法体内的实际代码的副本替代方法调用)，这消除了方法调用的开销。
>
> - #### 但最近的Java版本中，JVM可以探测到这些情况并优化去掉这些效率反而降低的内嵌调用技术。有很长一段时间，使用final来提高效率都被阻止。





### (4) final 和 private

> #### 类中所有 private 方法都被隐式地指定为 final 。

> #### “覆写” 只发生在方法是基类的接口时，而 private 方法不是基类接口的一部分，它是隐藏在类内部的代码。
>
> #### 所以在派生类中以相同的命名创建 public 、 protected 、 default 方法时，这些方法和基类中的 private 方法没有联系。此时我们是在 创建新的方法 而不是在 覆写方法 。





### (5) final 类

> #### 当说一个类是 final 时，就意味着它不能被继承。 由于 final 类禁止继承，类中所有方法都被隐式地指定为 final ，所以没有办法覆写它们。





### (6) final 忠告

> #### 通常来说，预见一个类如何被复用是很困难的，特别是通用类。如果将一个方法指定为 final ，可能会防止其他程序员的项目中通过继承来复用你的类，而这仅仅是因为你没有想到它会被以那种方式使用。









## 9. 类初始化和加载

> #### Java 中 “万物皆对象” 的思想使得加载活动变得容易得多。记住每个类的编译代码都存在于它自己独立的文件中，该文件只有在使用程序代码时才会被加载，即所谓 *“类的代码在首次使用时加载”* 。

> #### 构造器也是一个 static 方法，尽管它的 static 关键字时隐式的。

### (1) 继承和初始化

> - #### 当试图访问一个继承类的静态 `main()` 方法时，加载器会找出该继承类的编译代码并加载它，加载过程中发现基类则继续加载基类。
>
> - #### 然后沿着基类 ——> 继承类的顺序开始执行 static 初始化。
>
> - #### 至此所有相关类加载完毕，可以创建对象。首先初始化类的成员属性，然后沿着基类 ——> 继承类的顺序调用构造器在进行初始化。
>
> - #### 总而言之，初始化顺序是 继承顺序 + 先 static 后 非static 最后 构造器









## 10. 本章小结

> #### *`继承`* 和 *`组合`* 都是从已有类型创建新类型。 组合 将已有类型作为新类型底层实现的一部分， 继承 复用的是接口。
>
> #### 使用继承时，派生类具有基类接口，因此可以 `向上转型` 为基类。

> #### 在设计一个系统时，目标是发现或创建一系列类，每个类有特定的用途，而且既不应太大（包括太多功能难以复用），也不应太小（不添加其他功能就无法使用）。













# [第九章 多态](https://njuics.github.io/OnJava8/#/book/09-Polymorphism?id=第九章-多态)

> #### *`多态`* 是面向对象编程语言中，继数据 *`抽象`* 和 *`继承`* 之外的第三个重要特征。又称为 *`动态绑定`* 或 *`后期绑定`* 或 *`运行时绑定`* 。
>
> - #### 多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做；
>
> - #### 多态可以改善代码的组织和可读性；
>
> - #### 多态能创建有扩展性的程序；

> #### 在上一章中，继承允许把一个对象视为它本身的类型或它的基类类型。这样就能把很多派生自一个基类的类型当作同一类型处理，因而一段代码就可以无差别地运行在所有不同的类型上了。

> #### *多态方法调用* 允许一种类型表现出与相似类型的 区别 ，只要这些类型派生自一个基类。这种区别是当你通过基类调用时，由方法的不同行为表现出来的。

## 1. 向上转型回顾

> #### 这种把一个对象引用当作它的基类引用的做法称为向上转型，因为继承图中基类一般都位于最上方。向上转型可能会 “缩小” 接口，但不会比 **基类** 的全部接口更少。

### (1) 忘掉对象类型

> #### 为什么所有人都故意忘记掉对象类型呢？当向上转型时，就会发生对象类型的遗忘。这是因为如果不忘掉对象类型，就必须为基类的每个新继承类编写特定方法的重载。如果忘记重载某个方法，编译器也不会提示你，并且会使得类型的整个处理过程变得难以管理。

> #### *`多态`* 允许忘掉派生类，编写的代码只与基类打交道。







## 2. 转机

> #### 当我们将一个继承类向上转型为基类之后，编译器无法知道该基类引用指向的是哪一个具体的继承类。

### (1) 方法调用绑定

> - #### 将一个 方法调用 和一个 方法主体 关联起来称作 *`绑定`*
>
> - #### 若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做 *`前期绑定`* 
>
> - #### 运行时根据对象的类型进行绑定，叫做 *`后期绑定`* ( 也称为 *`动态绑定`* 或 *`运行时绑定`* )

> #### Java 中除了 **static** 和 **final** 方法外，其他所有方法都是 *`后期绑定`* 。这意味着通常情况下，后期绑定自动发生。





### (2) 产生正确的行为

> #### 一个基类称为 `Shape` ，多个派生类称为 `Circle` 、 `Square` 、 `Triangle`等。 此时 Shape s = new Circle() 则会创建一个 `Circle` 对象，并将其引用赋值给 `Shape` 类型的变量 s 。而且调用基类方法 s.draw() 时，由于后期绑定(多态)，被调用的时 `Circle` 的 `draw()` 方法。

> #### 所以当我们将许多同一个基类的派生类的对象向上转型为基类时，即我们将多个派生类对象的引用赋值给基类变量时，此时调用方法会通过动态绑定到自己派生类所定义的方法上。





### (3) 可扩展性

> #### 由于多态机制，我们可以像系统中添加任意多的新的基类的派生类，而且不需要修改原来编写的代码。在一个设计良好的面向对象程序中，许多方法会遵循可扩展性模型，只与基类接口通信。

<img src="images/1562252767216.png" alt="乐器继承图" style="zoom: 67%;" />

> #### 所以换句话说， *`多态`* 是一项 “将改变的事物与不变的事物分离” 的重要技术。





### (4) 陷阱：“重写”私有方法

```
package polymorphism;

public class PrivateOverride {
    private void f() {
        System.out.println("private f()");
    }
    
    public static void main(String[] args) {
        PrivateOverride po = new Derived();
        po.f();
    }
}

class Derived extends PrivateOverride {
    public void f() {
        System.out.println("public f()");
    }
}
```

> #### 此时输出结果是 `private f()` 。

> #### 由于基类的 private 方法也是 final 方法，它对于派生类来说是隐蔽的，所以派生类的  `public void f()` 和基类的 `private void f()` 是两个无关方法，因而不存在重写(覆写)关系。
>
> #### 所以不是覆写关系的两个方法自然不会由于动态绑定机制从基类向下，绑定到子类的 `f()` 方法。相反， `f()` 方法会绑定到基类的 private 方法中。





### (5) 陷阱：属性与静态方法

> #### 只有 普通的方法调用 可以是多态的。如果直接 访问一个属性 ，则该访问会在编译时解析，而非在运行时绑定。

> #### 也就是说，当一个 继承类对象 向上转型为 基类对象 ，任何 属性访问 都被编译器解析，因此 不是多态的 ，此时所有被访问的属性都是基类对象中对应的成员变量。

> #### 如果一个方法是 静态(static) 的，它的行为就不具有多态性。即 *`静态方法只与类关联，与单个的对象无关。`*









## 3. 构造器和多态

> #### 由于人们会把构造器看作是隐式声明的静态方法，所以 构造器不具有多态性 。

### (1) 构造器调用顺序

> #### 在派生类的构造过程中总会调用基类的构造器，初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。
>
> #### 这样做的原因：由于属性通常声明为 private ，所以必须假定派生类只能访问自己的成员而不能访问基类的成员。 只有基类的构造器拥有恰当的知识和权限来初始化自身的元素 。因此，必须得调用所有构造器；否则就不能构造完整的对象。

> #### 构造器有着特殊的任务：检查对象是否被正确地构造。
>
> #### 如果在派生类的构造器主体中没有显式地调用基类构造器，编译器就会默默地调用基类的无参构造器。



#### 对象的构造器调用顺序：

- #### 基类构造器被调用。这个步骤被递归地重复，这样一来类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最底层的派生类。

- #### 按声明顺序初始化成员。

- #### 调用派生类构造器的方法体。





### (2) 继承和清理

> #### 由于继承，如果有其他特殊的清理工作的话，就必须在派生类中 重写  `dispose()` 方法。当重写 `dispose()` 方法时，记得调用基类的 `dispose()` 方法，否则基类的清理工作不会发生

> #### 销毁的顺序应该与初始化的顺序相反，以防一个对象依赖另一个对象。

> #### 当一个成员对象被其它一个或多个对象共享时，问题就变的复杂了。必须使用 *引用计数* 来跟踪仍然访问着共享变量的对象数量。







### (3) 构造器内部多态方法的行为

> #### 如果在构造器中调用正在构造的对象的动态绑定方法，则其结果会难以预料。

> #### 初始化的实际过程是：
>
> - #### 在所有事发生前，分配给对象的存储空间会被初始化为二进制 0。
>
> - #### 按声明顺序初始化成员。
>
> - #### 最终调用派生类的构造器。
>
> - #### 这样做的优点是所有事物至少初始化为0，而不是仅仅留作垃圾

```
class Glyph {
    void draw() {
        System.out.println("Glyph.draw()");
    }

    Glyph() {
        System.out.println("Glyph() before draw()");
        draw();
        System.out.println("Glyph() after draw()");
    }
}

class RoundGlyph extends Glyph {
    private int radius = 1;

    RoundGlyph(int r) {
        radius = r;
        System.out.println("RoundGlyph.RoundGlyph(), radius = " + radius);
    }

    @Override
    void draw() {
        System.out.println("RoundGlyph.draw(), radius = " + radius);
    }
}

public class PolyConstructors {
    public static void main(String[] args) {
        new RoundGlyph(5);
    }
}
output: 
Glyph() before draw()
RoundGlyph.draw(), radius = 0
Glyph() after draw()
RoundGlyph.RoundGlyph(), radius = 5
```









## 4. 协变返回类型

> #### Java 5 中引入了 *`协变返回类型`* ，这表示派生类的被重写方法可以返回基类方法返回类型的派生类型。









## 5. 使用继承设计

> #### 事实上，如果利用已有类创建新类首先选择继承的话，事情会变得莫名的复杂。
>
> #### 更好的方法是首先选择组合，特别是不知道该使用哪种方法时。组合不会强制设计是继承层次结构，而且组合更加灵活，因为可以动态地选择类型（因而选择相应的行为），而继承要求必须在编译时知道确切类型。

### (1) 替代 vs 扩展

> #### 采用“纯粹”的方式创建继承层次结构看上去是最清晰的方法。即只有基类的方法才能在派生类中被重写。这被称作纯粹的 *`“is-a”关系`* ，因为类的接口已经确定了它是什么。
>
> #### *纯粹的替代* 意味着派生类可以完美地替代类型，当使用它们时，完全不需要知道这些子类的信息。

> #### 但是继承扩展接口才是解决特定问题的完美方案。这可以称为 *`“is-like-a”关系`* ，因为派生类就像是基类——它有着相同的基本接口，但还具有需要额外方法实现的其他特性





### (2) 向下转型与运行时类型信息

> #### 由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，那么为了重新获取类型信息，就需要 在继承层次中向下移动 ，使用 *`向下转型`* 。

> #### 向上转型 永远是安全的，因为基类不会具有比派生类更多的接口。因此，每条发送给基类接口的消息都能被接收。
>
> #### 但是 向下转型 并不安全，所以在 Java 中，每次转型都会被检查，以确保他的确是希望的那种类型。如果不是，就会得到 *`ClassCastException`* （类转型异常）









## 6. 本章小结

> #### *`多态`* 意味着“不同的形式”。在面向对象编程中，我们持有从基类继承而来的相同接口和使用该接口的不同形式：不同版本的动态绑定方法。

> #### 为了在程序中有效地使用多态乃至面向对象的技术，就必须扩展自己的编程视野，不能只看到单一类中的成员和消息，而要看到 *类之间的共同特性* 和 *它们之间的关系* 。











# [第十章 接口](https://njuics.github.io/OnJava8/#/book/10-Interfaces?id=第十章-接口)

> #### *`接口`* 和 *`抽象类`* 提供了一种将接口与实现分离的更加结构化的方法。

## 1. 抽象类和方法

> #### Java 提供了一个叫做 *`抽象方法`* 的机制，这个方法是不完整的：他只有声明而没有方法体。
>
> #### 包含抽象方法的类叫做 *`抽象类`* 。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则编译器会报错。

> #### 如果一个抽象类是不完整的，那么当试图创建这个抽象类的对象时，Java 不会创建该对象，并且编译器会报错。 这样 既保证了抽象类的纯粹性 ， 又不用担心误用它 。

> #### 如果创建一个继承抽象类的新类并为之创建对象，那么就必须 为基类的所有抽象方法提供方法定义 。否则该新类仍然是一个抽象类，编译器会强制我们为新类加上 *`abstract`* 关键字。

> #### 在新类中为基类的抽象方法进行复写定义时，如果没有 `@Override` 的注解，如果没有定义相同的方法名或签名，抽象机制会认为你没有实现抽象方法从而产生编译时错误。

> #### 接口自动将其方法指明为 public 。事实上接口只允许 public 方法，如果不加访问修饰符的话，接口的方法不是 friendly 而是 public 。











## 2. 接口创建

> #### 使用 *`interface`* 关键字创建接口。在 Java 8 之前，接口只允许抽象方法。甚至不用为方法加上 abstract 关键字，因为接口中的方法默认为 抽象方法 。

> #### 因此我们可以说在 Java 8 之前， interface 关键字产生一个完全抽象的类，没有提供任何实现。我们描述类像什么、做什么但不能描述怎么做。 
>
> #### 而在 Java 8 中，允许接口包含 默认方法 和 静态方法 。但接口的基本概念仍然没变，介于类型之上、实现之下。
>
> - #### 接口的典型使用是代表一个类的类型或一个形容词，如 *Runnable* 或 *Serializable*
>
> - #### 抽象类通常是类层次结构的一部分或一件事物的类型，如 *String* 或 *ActionHero*

> #### 接口同样可以包含 *`属性`* ，这些属性被隐式指明为 *`static`* 和 *`final`*

> #### 使用 *`implement`* 关键字使一个类遵循某个特定接口(或一组接口)，这表示接口只是外形，现在我要说明它是如何工作的。

> #### 接口中的方法默认为 *public* 的 。所以当我们实现一个接口时，来自接口中的方法必须被定义为 public ，否则方法的 可访问权限就被降低了 ，这是 Java 编译器所不允许的。

### (1) 默认方法

> #### Java 8 为关键字 *`default`* 增加了一个新用途：当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 default 创建的方法体。





### (2) 多继承

> #### *`多继承`* 意味着一个类可能从多个父类型中继承特性和特征。

> #### Java 过去是一种严格要求单继承的语言：只能继承自一个类。而现在 Java 通过默认方法具有了某种多继承的特性。

> #### 结合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不允许存在属性（只有静态属性，不适用），所以 *`属性仍然只会来自单个基类或抽象类`* ，也就是说， *`不会存在状态的多继承`* 。





### (3) 接口中的静态方法

> #### Java 8 允许在接口中添加 *`静态方法`* 。这么做能恰当地 把工具功能置于接口中 ，从而操作接口，或者 成为通用的工具 。

> #### 这个特性是一项改善，因为它允许把静态方法放在更合适的地方。





### (4) Instrument 作为接口

```
// interfaces/music5/Music5.java
// {java interfaces.music5.Music5}
package interfaces.music5;
import polymorphism.music.Note;

interface Instrument {
    // Compile-time constant:
    int VALUE = 5; // static & final
    
    default void play(Note n)  // Automatically public 
        System.out.println(this + ".play() " + n);
    }
    
    default void adjust() {
        System.out.println("Adjusting " + this);
    }
}

class Wind implements Instrument {
    @Override
    public String toString() {
        return "Wind";
    }
}

class Percussion implements Instrument {
    @Override
    public String toString() {
        return "Percussion";
    }
}

class Stringed implements Instrument {
    @Override
    public String toString() {
        return "Stringed";
    }
}

class Brass extends Wind {
    @Override
    public String toString() {
        return "Brass";
    }
}

class Woodwind extends Wind {
    @Override
    public String toString() {
        return "Woodwind";
    }
}

public class Music5 {
    // Doesn't care about type, so new types
    // added to the system still work right:
    static void tune(Instrument i) {
        // ...
        i.play(Note.MIDDLE_C);
    }
    
    static void tuneAll(Instrument[] e) {
        for (Instrument i: e) {
            tune(i);
        }
    }
    
    public static void main(String[] args) {
        // Upcasting during addition to the array:
        Instrument[] orchestra = {
            new Wind(),
            new Percussion(),
            new Stringed(),
            new Brass(),
            new Woodwind()
        }
        tuneAll(orchestra);
    }
}
```

> #### 注意到，无论是将其向上转型为称作 **Instrument** 的普通类，或称作 **Instrument** 的抽象类，还是叫作 **Instrument** 的接口，其行为都是相同的。事实上，从 `tune()` 方法上看不出来 **Instrument** 到底是一个 *普通类* 、 *抽象类* ，还是一个 *接口* 。









## 3. 抽象类和接口

|         特性         |                            接口                            |                  抽象类                  |
| :------------------: | :--------------------------------------------------------: | :--------------------------------------: |
|         组合         |                    新类可以组合多个接口                    |            只能继承单一抽象类            |
|         状态         |        不能包含属性（除了静态属性，不支持对象状态）        | 可以包含属性，非抽象方法可能引用这些属性 |
| 默认方法 和 抽象方法 | 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 |         必须在子类中实现抽象方法         |
|        构造器        |                         没有构造器                         |               可以有构造器               |
|        可见性        |                      隐式 **public**                       |    可以是 **protected** 或 "friendly"    |

> #### *`抽象类`* 仍然是一个类，在创建新类时只能 *`继承一个抽象类`* ，但创建新类时可以 *`实现多个接口`* 。
>
> #### 由于有一天实际经验：在合理的范围内尽可能地抽象。所以 更倾向于使用接口而非抽象类 。











## 4. 完全解耦

> #### 每当一个方法与一个类而不是接口一起工作时(例如当方法的参数是类而不是接口)，那么我们只能应用那个类或其子类。但是却无法把这方法应用到一个继承层次之外的类。
>
> #### 接口在很大程度上放宽了这个限制，因而 *使用接口可以编写复用性更好的方法* 。

> #### 创建一个 能根据传入的参数类型从而具备不同行为 的方法称为 *`策略设计模式`* 。 *方法* 包含算法中 不变 的部分， *策略* 包含 变化 的部分 。
>
> #### 复用代码的第一种方式是客户端程序员遵循接口编写类。

> #### 允许代码接受已有的接口产生需要的接口 的方法称为 *`适配器设计模式`* 。

> #### 将接口与实现解耦使得接口可以应用于多种不同的实现，因而代码更具可复用性。











## 5. 多接口结合

> #### 接口没有任何 `实现` ———— 也就是说，没有任何与接口相关的存储 ———— 因此也无法阻止结合的多接口。 这使得我们可以表示 “一个x是一个a和一个b以及一个c”

<img src="images/1562999314238.png" alt="类图" style="zoom: 40%;" />

> #### 如果继承一个非接口的类，那么只能继承一个类，其余的基元素必须都是接口。需要将所有的接口名置于 **implement** 关键字之后且用逗号分隔。
>
> #### 可以有任何多个接口，并可以向上转型为每个接口，因为每个接口都是独立的类型。

> #### 当某个新类既要继承具体类，也要实现接口时，需要将 继承具体类放在前面 ， 实现接口放在后面 。

> #### 使用接口的原因：
>
> - #### 为了能够向上转型为多个基类型（以及由此带来的灵活性）。
>
> - #### 第二个原因与使用抽象基类相同：防止客户端程序员创建这个类的对象，确保这仅仅只是一个接口。
>
> #### 如果创建不带任何方法定义或成员变量的基类，就选择接口而不是抽象类。











## 6. 使用继承扩展接口

> #### 通过继承，可以在接口中 增加方法声明 ，还可以在新接口中 结合多个接口 。

### (1) 结合接口时的命名冲突

> #### 当一个新类实现多个接口时，如果多个接口出现完全相同的方法没有问题，但如果它们的签名或返回类型不同则会出现命名冲突。

> #### 覆写、实现和重载令人不快地搅和在一起带来了困难。所以当打算组合接口时， *`在不同的接口中使用相同的方法名`* 通常会造成代码可读性的混乱，应尽量避免这种情况。











## 7. 接口适配

> #### 接口最吸引人的原因之一时 *`相同的接口可以有多个实现`* 。

> #### 因此接口的一种常见用法是前面提到的 *`策略设计模式`* ：编写一个方法执行某些操作并接收一个指定的接口作为参数，那么只要对象遵循接口，就可以调用方法。
>
> #### 这会使得方法更加灵活、通用、并更具可复用性。
>
> #### 比如，如果我们令类 `Scanner` 的构造器的接受参数为一个 `Readable` 接口，那么 `Scanner` 可以与更多的类型协作，如果我们想创建一个新类并让 `Scanner` 可以作用于它，那么就可以让它实现 `Readable` 接口。

> #### 接口的另一种常见用法是前面提到的 *`适配器设计模式`* ：通过 ***`interface`*** 提供的多继承，我们可以创建一个实现多个接口的类。

> #### 使用接口而不是类的强大之处在于： 一个 接受接口类型 的方法提供了一种 让任何类都可以与该方法进行适配 的方式。











## 8. 接口字段

> #### 由于接口中的字段都自动是 `static` 和 `final` 的，所以接口就成为了创建一组常量的方便工具。

### (1) 初始化接口中的字段

> #### 接口中定义的字段不能是 “空final” ，但是可以用 非常量表达式 初始化。 由于字段是 static 的，所以它们在类第一次被加载时初始化，这发生在任何字段首次被访问时。

> #### 接口中 字段的值 被存储在 *接口的静态存储区域* 中。











## 9. 接口嵌套

> #### 接口可以嵌套在类或其他接口中。 它也具有 public 或 包访问权限 的可见性。

> #### 接口也可以是 private 的，例如 A.D 。那么 private 接口是一种可以 强制该接口中的方法定义不会添加任何类型信息 (即 不可以向上转型 )的方式 。

> #### 由于作用于接口的规则 ———— 接口中的元素必须是 public 的 ———— 会被严格执行，所以嵌套在另一个接口中的接口自动就是 public 的，不能指明为 private 。









## 10. 接口和工厂方法模式

> #### 接口是多实现的途径，而生成符合某个接口的对象的典型方式是 *`工厂方法设计模式`* 。不同于直接调用构造器，只需调用工厂对象中的创建方法就能生成对象的实现 ———— 理论上通过这种方式可以将接口和实现的代码完全分离，使得可以透明的将某个实现替换为另一个实现。









## 11. 本章小结

> #### 任何抽象性都应该是由真正的需求驱动的。当有必要时才应该使用接口进行重构，而不是到处添加额外的间接层，从而带来额外的复杂性。

> #### 恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。















# [第十一章 内部类](https://njuics.github.io/OnJava8/#/book/11-Inner-Classes?id=第十一章-内部类)

> #### 内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起。内部类了解外部类，并能与之通信，而且用内部类写出的代码更加优雅而清晰，~~尽管并不总是这样。~~

## 1. 创建内部类

> #### 创建内部类的方式就如同你想的一样 ———— *`把类的定义置于外部类的里面`* 。

> #### 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体地指明这个对象的类型：*OuterClassName.InnerClassName*。在外部类的静态方法中也可以直接指明类型 *InnerClassName* 。











## 2. 链接外部类

> #### 当生成一个内部类的对象时，此对象与制造它的外部对象之间就有了一种联系，所以它能访问其外部对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外部类的所有元素的访问权。

> #### 当某个外部类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用。然后，在你访问此外部类的成员时，就是用那个引用来选择外部类的成员。幸运的是，编译器会帮你处理所有的细节。











## 3. 使用 .this 和 .new

> #### 如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 **this**。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。

> #### 有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在 **new** 表达式中提供对其他外部类对象的引用，这是需要使用 **.new** 语法。

> #### 在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到创建它的外部类对象上。但是，如果所要创建的是嵌套类(静态内部类)，那么它就不需要对外部类对象的引用。











## 4. 内部类和向上转型

> #### 当我们将内部类向上转型为其基类，尤其是转型为一个接口的时候，这样由于此内部类能够完全不可见且不可用，所以得到的只是指向基类或接口的引用，从而能够很方便地隐藏实现细节。

> #### private 内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。
>
> #### 此外从 客户端程序员 的视角来看，由于不能访问任何新增加的、原本不属于公共接口的方法，所以扩展接口是没有价值的。这给 Java 编译器提供了 生成高效代码 的机会。











## 5. 内部类方法和作用域

> #### 可以在一个方法或者在任意的作用域内定义内部类。

#### 内部类可在以下地方被定义：

- #### 定义在方法中的类。

- #### 定义在作用域内的类，此作用域在方法的内部。

- #### 实现了接口的匿名类。

- #### 匿名类，它扩展了没有默认构造器的类。

- #### 匿名类，它执行字段初始化。

- #### 匿名类，它通过实例初始化实现构造（匿名内部类不可能有构造器）。









## 6. 匿名内部类

> #### *`匿名内部类`* 这种奇怪的语法指的是：“创建一个继承自 **Content** 的匿名类的对象。” 通过 new 表达式返回的引用被自动向上转型为对 Contents 的引用。

> #### 在匿名内部类末尾的分号，并不是用来标记此内部类结束的。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。因此这与别的地方使用的分号是一致的。

> #### 如果在定义一个匿名内部类时，它要使用一个 *外部环境* (在本匿名内部类之外定义的) 对象，那么编译器会要求该对象的参数引用时 ***`final`*** 或者 ***`effective final`*** (即该参数在初始化之后不能被重新赋值，没有被 final 关键字修饰但可以当作 final ) 的。

> #### 如果想在匿名类中做一些类似构造器的行为，由于匿名类没有名字，所以在匿名类中不可能有 命名构造器 。但通过 *`实例初始化`* ，可以达到为匿名内部类创建一个构造器的效果。
>
> #### *`实例初始化`* 在形式上就是将初始化相关的语句通过花括号括起来。而且虽然对于匿名类而言，实例初始化的效果就是构造器，但却是受到限制的，我们 无法重载实例初始化方法 。

> #### 匿名内部类与正规的继承相比有些限制，因为匿名内部类要么继承类，要么实现接口，但 *无法两者兼备* 。而且只能实现 *一个接口* 。









## 7. 嵌套类

> #### ***`嵌套类`*** ： 如果不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为 static ，这通常称为嵌套类。
>
> #### 普通的内部类对象隐式地保存了一个引用，指向创建它的外部类对象。然而当内部类是 static 时，就并非如此：
>
> - #### 创建嵌套类对象时，不需要其外部类对象
>
> - #### 不能从嵌套类对象中访问非静态的外部类对象

> #### 普通内部类的字段和方法只能放在类的外部层次上，所以普通内部类 *不能有 static 数据 和 static 字段* ，而且也 *不能包含嵌套类* 。
>
> #### 但嵌套类可以包含所有这些东西。

> #### 在一个普通的内部类中，通过一个特殊的 **this** 引用 可以链接到其外部类对象。嵌套类就没有这个特殊的 **this** 引用 ，这使得它类似于一个 **static** 方法。

### (1) 接口内部的类

> #### 嵌套类可以作为接口的一部分，因为接口中的任何类都自动是 `public` 和 `static` 的。甚至可以在内部类中实现其外部接口。

> #### 如果想要创建某些公共代码，使得他们可以 被某个接口的所有不同实现所共用 ，那么使用接口内部的嵌套类会显得很方便。

> #### 可以在每个类中都写一个 `main()` 方法，用来测试这个类。这样做的缺点就是必须带着那些已编译过的额外代码。所以我们可以使用嵌套类来放置测试代码。





### (2) 从多层嵌套类中访问外部类的成员

> #### 无论一个内部类被嵌套多少层，它都能透明的访问它所嵌入的外部类的所有成员。











## 8. 为什么需要内部类

> #### 一般来说，内部类继承自某个类或者实现某个接口，内部类的代码操作创建它的外部类对象。所以可以认为： *内部类提供了某种进入其外部类的窗口* 。

> #### 相比于内部类实现接口，外部类实现接口不总能享用到接口带来的方便，有时需要用到接口的实现。
>
> #### 所以使用内部类最吸引人的原因是： *`每个内部类都能独立的继承自一个(接口)实现，因此无论外部类是否已经继承了某个(接口)实现，对于内部类而言都没有影响。`*

> #### *`内部类允许继承多个非接口类型(类或抽象类)`* 。
>
> #### 所以当我们要在一个类中以某种方式实现多个接口，那么由于接口的灵活性，我们可以使用单一类或内部类； 而当我们要在一个类中以某种方式继承多个抽象类或具体类，那么我们只能使用 *内部类才能实现多重继承* 。

```
package innerclasses;

class D {}

abstract class E {}

class Z extends D {
    E makeE() {
      return new E() {};  //内部类
    }
}

public class MultiImplementation {
    static void takesD(D d) {}
    static void takesE(E e) {}
    
    public static void main(String[] args) {
        Z z = new Z();
        takesD(z);
        takesE(z.makeE());
    }
}
```



> #### 内部类可以实现的其他特性：
>
> - #### 内部类可以有多个实例，每个实例都有自己的状态信息，并且与外部类对象的信息相互独立
>
> - #### 在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类
>
> - #### 创建内部类对象的时刻并不依赖于外部类对象的创建
>
> - #### 内部类并没有 “is-a” 关系，它仅是一个独立实体

### (1) 闭包与回调

> #### ***`闭包`*** ： 是一个可调用的对象，它记录了一些来自于创建它的作用域的信息。 
>
> #### 所以由此可见，内部类是面向对象的闭包，因为它不仅包含外部类对象的信息，还自动拥有一个指向此外部类对象的引用，内部类有权操作所有成员。

> #### 除了内部类，在 Java 8 中，我们可以使用 *`lambda 表达式`* 来实现闭包行为，并且语法更加优雅和简洁。

> #### Java 最引人争议的问题之一就是，人们认为 Java 应该包含某种类似指针的机制，以允许 ***`回调`*** 。
>
> #### 通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。

> #### 回调的价值在于它的 *`灵活性`* ———— 可以在运行时动态地决定需要调用什么方法 。

### (2) 内部类与控制框架

> #### *`应用程序框架`* ： 就是被设计用以解决某类特定问题的一个类或一组类。
>
> #### 要运用某个应用程序框架，通常是 继承 一个或多个类，并 重写 某些方法。你在重写的方法中写的代码定制了该应用程序框架提供的通用解决方案，来解决你的具体问题。

> #### `设计模式` 总是将变化的事物与保持不变的事物分离开，在这个模式中， `模板方法` 是保持不变的事物，而 `可重写的方法` 就是变化的事物。

> #### *`控制框架`* 是一类特殊的应用程序框架，它用来解决 响应事件 的需求。
>
> #### 主要用来响应事件的系统被称作 *`事件驱动`* 系统。

> #### 内部类允许：
>
> - #### 控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不同的方法。
>
> - #### 内部类能够很容易地访问外部类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。









## 9. 继承内部类

> #### 由于内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类的时候，问题在于那个 指向外部类对象的“秘密的”引用必须被初始化 ，而 在派生类中不再存在可连接的默认对象 。
>
> #### 所以要解决这个问题，必须使用特殊的语法来说清它们之间的关联：

```
class WithInner {
    class Inner {}
}
public class InheritInner extends WithInner.Inner {
    //- InheritInner() {} // Won't compile
    InheritInner(WithInner wi) {
        wi.super();
    }
    public static void main(String[] args) {
        WithInner wi = new WithInner();
        InheritInner ii = new InheritInner(wi);
    }
}
```

> #### 必须在构造器内使用如下语法：

```
enclosingClassReference.super();
```









## 10. 内部类可以被重写吗？

> #### 重写内部类就好像它是外部类的一个方法，其实并不起什么作用。即内部类无法像方法一样被重写：

```
class Egg {
    private Yolk y;
    protected class Yolk {
        public Yolk() {
            System.out.println("Egg.Yolk()");
        }
    }
    Egg() {
        System.out.println("New Egg()");
        y = new Yolk();
    }
}
public class BigEgg extends Egg {
    public class Yolk {
        public Yolk() {
            System.out.println("BigEgg.Yolk()");
        }
    }
    public static void main(String[] args) {
        new BigEgg();
    }
}
输出为：
    New Egg()
	Egg.Yolk()
```

> #### 你可能认为既然创建了 **BigEgg** 的对象，那么所使用的应该是“重写后”的 **Yolk** 版本，但从输出中可以看到实际情况并非如此。

> #### 当继承了某个外部类的时候，内部类并没有发生什么特别神奇的变化。这 *`两个内部类是完全独立的两个实体`* ，各自在自己的命名空间内。









## 11. 局部内部类

> #### ***`局部内部类`*** 不能有访问说明符，因为它不是外部类的一部分，但却可以访问当前代码块内的常量以及此外部类的所有成员。

> #### ***`局部内部类`*** 有多个已命名的构造器，而 ***`匿名内部类`*** 只能使用实例初始化。









## 12. 内部类标识符

> #### 内部类也必须生成一个 .class 文件以包含它们的 Class 对象信息。内部类文件的命名有严格的规则： ***`外部类名 + "$" + 内部类名`*** 。如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符 。









## 13. 本章小结

> #### 接口和内部类更加深奥复杂，将两者结合起来，同样能够解决 C++ 中的用多重继承所能解决的问题。这些特性本身是相当直观的，但这些特性的使用应该是 *设计阶段* 所考虑的问题。













# [第十二章 集合](https://njuics.github.io/OnJava8/#/book/12-Collections?id=第十二章-集合)

> #### 程序总是根据运行时才知道的某些条件去创建新的对象。在此之前，无法知道所需对象的数量甚至确切类型。
>
> #### 大多数编程语言都提供了某种方法来解决这个基本问题。Java有多种方式保存对象（确切地说，是对象的引用）。例如 java.util 库提供的一套相当完整的 *集合类* 来解决这个问题(其中有 List 、 Set 、 Queue 、 Map 等)，这些类型也被称作 *容器类* 。
>
> #### ***`Java集合类都可以自动地调整自己的大小。`***

## 1. 泛型和类型安全的集合

> #### 在 Java 5 之前的集合的一个主要问题是编译器允许我们像集合中插入不正确的类型。

> #### 可以使用特定的 ***`注解`*** 来抑制警告信息。注解以“@”符号开头，可以带参数。
>
> #### `@SuppressWarning("unchecked")` 注解及其参数表示只抑制“unchecked”类型的警告（[注解](https://njuics.github.io/OnJava8/#/)章节将介绍更多有关注解的信息）

> #### 由于 ArrayList 保存的是 Object ，所以可以通过 ArrayList 的 `add()` 方法将不同的对象放入集合中，这无论在编译期还是运行时都不会有问题。

> #### 在[泛型](https://njuics.github.io/OnJava8/#/)章节中，你将了解到使用 Java 泛型来创建类可能很复杂。但是，使用预先定义的泛型类却相当简单。

> #### `new ArrayList<>()` 有时被称为“菱形语法”，使用了 *类型推断* 技术

> #### 使用泛型，不仅编译器会检查让如集合的元素类型，而且调用 `get()` 方法取出元素时，会自动执行类型转换，从而获得更清晰的语法。

> #### *向上转型* 不仅作用于其他类型，也可以作用于泛型。使得某类型的子类型可以放入到其父类集合中。











## 2. 基本类型

> #### Java 集合类库采用 *`“持有对象”`* 的思想，并将其分为两个不同的概念，表示为类库的基本接口：
>
> - #### ***`集合`*** ： 一个独立元素的序列，这些元素都服从一条或多条规则，例如 `List` 、 `Set` 、 `Queue` 。
>
> - #### ***`映射`*** ： 一组成对的 “键值对” 对象，允许使用键来查找值。例如 `ArrayList` 、 `Map` 。

> #### 我们可以在创建这些接口时，将具体实现向上转型为其基类，这样如果想要改变具体实现，只需在创建时修改它即可。但当要使用具体类的额外方法时，则不可以将具体类向上转型为更通用的接口。









## 3. 添加元素组

> - #### `Arrays.asList()` ： 方法接受一个 数组 或是逗号分隔的 元素列表 ，并将其转换为 **List** 对象。
>
> - #### `Collections.addAll()` ： 方法接受一个 **C<u>ollection** 对象</u> ，以及一个 数组 或是逗号分隔的 元素列表 ，将其中元素添加到 **Collection** 中。

> #### `Arrays.asList()` 的输出是一个 **List** ，但是这里的底层实现是数组， 没法调整大小 。如果尝试在这个 **List** 上调用 `add()` 或 `remove()`，由于这两个方法会尝试修改数组大小，所以会在运行时得到 *`“Unsupported Operation”`* 错误。

```
List<Snow> snow4 = Arrays.<Snow>asList(
    new Light(), new Heavy(), new Slush());
```

> #### `Arrays.asList()` 中间的“暗示”（即 `<Snow>` ），告诉编译器 `Arrays.asList()` 生成的结果 **List** 类型的实际目标类型是什么。这称为 *`显式类型参数说明`* 。









## 4. 集合的打印

> #### 必须使用 `Arrays.toString()` 来生成数组的可打印形式。但是打印集合无需任何帮助。
>
> #### 默认的打印行为，使用集合提供的 `toString()` 方法即可生成可读性很好的结果。
>
> - #### ***`Collection`*** 打印出的内容用方括号括住，每个元素由逗号分隔。
>
> - #### ***`Map`*** 则由大括号括住，每个键和值用等号连接（键在左侧，值在右侧）。

> ##### 如果存储顺序很重要，则可以使用 **TreeSet** ，它把对象按照比较规则来排序；还有 **LinkedHashSet** ，它把对象按照被添加的先后顺序来排序。









## 5. 列表List

> #### ***`List`*** 承诺将元素保存在特定的序列中。 List 接口在 Collection 的基础上添加了许多方法，允许在 List 的中间插入和删除元素。

#### 有两种类型的 List ：

- #### 基本的 *`ArrayList`* ，擅长随机访问数组，但在List中间插入和删除元素时速度较慢。

- #### *`LinkedList`* ，擅长在List中间插入和删除，提供了优化的顺序访问。LinkedList对于随机访问来说速度较慢。但拥有比 ArrayList 更大的特征集。

> #### `subList()` 所产生的列表的幕后支持就是原始列表。因此， *对所返回列表的更改都将会反映在原始列表中* ，反之亦然。









## 6. 迭代器 Iterators

> #### 假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合。
>
> #### ***`迭代器`*** (也是一种设计模式)的概念实现了这种抽象。它是一个对象，它在序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。
>
> #### 迭代器通常被称为 ***`轻量级对象`*** ： 即创建它的代价小 。因此经常可以看到一些对迭代器有些奇怪的约束，而且 Iterator 只能用来：
>
> - #### Java 的 Iterator 只能单向移动；
>
> - #### 使用 `iterator()` 方法要求集合返回一个 *`Iterator`* 。Iterator 将准备好返回序列中的第一个元素；
>
> - #### 使用 `next()` 方法获得序列中的下一个元素；
>
> - #### 使用 `hasNext()` 方法检查序列中是否还有元素；
>
> - #### 使用 `remove()` 方法将迭代器最近返回的那个元素删除；

```
// collections/SimpleIteration.java
import typeinfo.pets.*;
import java.util.*;

public class SimpleIteration {
  public static void main(String[] args) {
    List<Pet> pets = Pets.list(12);
    Iterator<Pet> it = pets.iterator();
    while(it.hasNext()) {
      Pet p = it.next();
      System.out.print(p.id() + ":" + p + " ");
    }
    System.out.println();
    // A simpler approach, when possible:
    for(Pet p : pets)
      System.out.print(p.id() + ":" + p + " ");
    System.out.println();
    // An Iterator can also remove elements:
    it = pets.iterator();
    for(int i = 0; i < 6; i++) {
      it.next();
      it.remove();
    }
    System.out.println(pets);
  }
}
/* Output:
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug
7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug
7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster
[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]
*/
```

> #### ***`Iterator`*** 的真正威力：能够将 *遍历序列的操作* 与 *该序列的底层结构* 分离。

### (1) ListIterator

> #### **ListIterator** 是一个更强大的 **Iterator** 子类型，它只能由各种 **List** 类生成。**ListIterator** 可以双向移动。









## 7. LinkedList

> #### *`LinkedList`* 也像 **ArrayList** 一样实现了基本的 **List** 接口，但它在 **List** 中间执行插入和删除操作时比 **ArrayList** 更高效。然而,它在随机访问操作效率方面却要逊色一些。

> #### ***`LinkedList`\* 还添加了一些方法，使其可以被用作栈、队列或双端队列。**
>
> - ##### `getFirst()` 和 `element()` 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 **List** 为空，则抛出 **NoSuchElementException** 异常。 `peek()` 方法与这两个方法只是稍有差异，它在列表为空时返回 **null** 。
>
> - ##### `removeFirst()` 和 `remove()` 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 **NoSuchElementException** 异常。 `poll()` 稍有差异，它在列表为空时返回 **null** 。
>
> - ##### `addFirst()` 在列表的开头插入一个元素。
>
> - ##### `offer()` 与 `add()` 和 `addLast()` 相同。 它们都在列表的尾部（末尾）添加一个元素。
>
> - ##### `removeLast()` 删除并返回列表的最后一个元素。









## 8. 堆栈 Stack

> #### 堆栈是“后进先出”（LIFO）集合。它有时被称为*叠加栈*。









## 9. 集合 Set

> #### *`Set`* 不保存重复的元素。 如果试图将相同对象的多个实例添加到 **Set** 中，那么它会阻止这种重复行为。
>
> #### **Set** 具有与 **Collection** 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 **List** 那样。

> #### ***`TreeSet`*** 将元素存储在红-黑树数据结构中，而 ***`HashSet`*** 使用散列函数。 ***`LinkedHashSet`*** 也使用散列来提高查询速度，但是似乎使用了链表来维护元素的插入顺序。









## 10. 映射 Map

> #### 将对象映射到其他对象的能力是解决编程问题的有效方法。
>
> #### 可以使用 `containsKey()` 和 `containsValue()` 方法去测试一个 **Map** ，以查看它是否包含某个键或某个值。

> #### **Map** 与数组和其他的 **Collection** 一样，可以轻松地扩展到多个维度：例如，假设你正在追踪有多个宠物的人，只需要一个 **Map< Person, List< Pet > >** 即可。









## 11. 队列 Queue

> #### ***`队列`*** 是一个典型的“先进先出”（FIFO）集合。 即从集合的一端放入事物，再从另一端去获取它们，事物放入集合的顺序和被取出的顺序是相同的。

> - #### `offer()` 是 **Queue** 的特有方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 **false** 。
>
> - #### `peek()` 和 `element()` 都返回队头元素而不删除它，但如果队列为空，则 `peek()` 返回 **null** ， 而 `element()` 抛出 **NoSuchElementException** 。 
>
> - #### `poll()` 和 `remove()` 都删除并返回队头元素，但如果队列为空，则 `poll()` 返回 **null** ，而 `remove()` 抛出 **NoSuchElementException** 。

### (1) 优先级队列

> #### 先进先出（FIFO）描述了最典型的*队列规则*。 ***`队列规则`*** 是指在给定队列中的一组元素的情况下，确定下一个弹出队列的元素的规则。

> #### ***`优先级队列`*** ：下一个弹出的元素是最需要的元素（具有最高的优先级）。











## 12. 集合和迭代器

> #### *`Collection`* 是所有序列集合共有的根接口。它可能会被认为是一种 *“附属接口”* ，即因为要 表示其他若干个接口的共性而出现的接口。

> #### 使用接口的一个理由是它可以使我们创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多类型的对象。

> #### 当需要实现一个不是 **Collection** 的外部类时，由于让它去实现 **Collection** 接口可能非常困难或麻烦，因此使用 **Iterator** 就会变得非常吸引人。

> #### 如果实现了 **Collection** ，就必须也实现 `iterator()` ，而单独只实现 `iterator()` 和继承 **AbstractCollection** 相比，并没有容易多少。

> #### 生成 **Iterator** 是将序列与消费该序列的方法连接在一起的耦合度最小的方式，并且与实现 **Collection** 相比，它在序列类上所施加的约束也少得多。









## 13. for-in 和迭代器

> #### 到目前为止，*for-in* 语法主要用于数组，但它也适用于任何 **Collection** 对象。

> #### *for-in* 语句适用于数组或者其它任何 **Iterable** ，但这并不代表数组一定是 **Iterable** ，也不会发生任何自动装箱。
>
> #### 尝试将数组作为一个 **Iterable** 参数传递会导致失败。这说明不存在任何从数组到 **Iterable** 的自动转换; 必须手工执行这种转换。

### (1) 适配器方法惯用法

> #### 如果有一个 Iterable 类，我们想要添加一种或多种在 *for-in* 语句中使用这个类的方法，应该怎么做呢？
>
> #### 一种解决办法就是所谓 ***`适配器方法`*** 。如果已经有一个接口并却需要另一个接口时，则编写适配器就可以解决这个问题。
>
> #### 在这里，如果希望在默认的正向迭代器的基础上添加产生反向迭代器的能力，因此不能使用重写，相反而是添加一个能够生成 Iterable 对象的方法，该对象可以用于 *for-in* 语句。这使得我们可以提供多种使用 *for-in* 语句的方式。









## 14. 本章小结

#### Java 提供了许多保存对象的方法：

- #### ***`数组`*** 将数字索引与对象相关联。它保存类型明确的对象，因此在查找对象时不必对结果做类型转换。它可以是多维的，可以保存基本类型的数据。虽然可以在运行时创建数组，但是一旦创建数组，就无法更改数组的大小。

- #### *`Collection`* 保存单一的元素，而 **Map** 包含相关联的键值对。使用 Java 泛型，可以指定集合中保存的对象的类型，因此不能将错误类型的对象放入集合中，并且在从集合中获取元素时，不必进行类型转换。各种 **Collection** 和各种 **Map** 都可以在你向其中添加更多的元素时，自动调整其尺寸大小。集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。

- #### 像数组一样， ***`List`*** 也将数字索引与对象相关联，因此，数组和 **List** 都是有序集合。

- #### 如果要执行大量的随机访问，则使用 ***`ArrayList`*** ，如果要经常从表中间插入或删除元素，则应该使用 **LinkedList** 。

- #### ***`队列和堆栈`*** 的行为是通过 **LinkedList** 提供的。

- #### ***`Map`*** 是一种将对象（而非数字）与对象相关联的设计。 **HashMap** 专为快速访问而设计，而 **TreeMap** 保持键始终处于排序状态，所以没有 **HashMap** 快。 **LinkedHashMap** 按插入顺序保存其元素，但使用散列提供快速访问的能力。

- #### ***`Set`*** 不接受重复元素。 **HashSet** 提供最快的查询速度，而 **TreeSet** 保持元素处于排序状态。 **LinkedHashSet** 按插入顺序保存其元素，但使用散列提供快速访问的能力。

- #### 不要在新代码中使用遗留类 ***`Vector`*** ，***`Hashtable`*** 和 ***`Stack`*** 。



#### Java 集合简图：

<img src="https://njuics.github.io/OnJava8/images/simple-collection-taxonomy.png" alt="simple collection taxonomy" style="zoom: 55%;" />

- #### 下面是译者绘制的 Java 集合框架简图， ***`黄色为接口`*** ， ***`绿色为抽象类`*** ， ***`蓝色为具体类`*** 。 ***`虚线箭头表示实现关系`*** ， ***`实线箭头表示继承关系`*** 。

<img src="https://njuics.github.io/OnJava8/images/collection.png" alt="collection" style="zoom:50%;" />

<img src="https://njuics.github.io/OnJava8/images/map.png" alt="map" style="zoom:60%;" />















# [第十三章 函数式编程](https://njuics.github.io/OnJava8/#/book/13-Functional-Programming?id=第十三章-函数式编程)

> #### ***`函数式编程语言操`*** 纵代码片段就像操作数据一样容易。 虽然 Java 不是函数式语言，但 Java 8 Lambda 表达式和方法引用允许以函数式编程。

> #### 在计算机时代早期，由于内存的稀缺和高昂，人们为了高效代码宁愿选择汇编语言手工编写。
>
> #### 而且为了能使程序在有限内存上运行，程序员会在程序运行时修改内存中的代码，使程序可以执行不同操作，从而用这种方式结束代码空间。这种技术被称为 ***`自修改代码`*** 。

> #### 使用纯粹的自修改代码的缺点是：
>
> - #### 我们很难确定程序在做什么。它也难以测试，除非我们一点点测试输出，代码转换和修改等等过程。
>
> #### 但是 使用代码以某种方式操纵其他代码 的想法也很有趣，只要保证安全：
>
> - #### 从代码创建，维护和可靠性的角度来看，这个想法非常吸引人。我们可以将可靠的小块代码拼接成新代码。
>
> - #### 这就是 ***`函数式编程(FP)`*** 的意义所在。

> #### 我们可以这样认为：
>
> - #### OO(面向对象) 是抽象数据；
>
> - #### FP(函数式编程) 是抽象行为；

> #### 纯粹的函数式语言在安全性上更进一步。它强加额外约束：所有数据不可变，函数从不修改自身外部的任何东西。这杜绝了所谓 *“副作用”* 现象的出现。

## 1. 新旧对比

> #### 传统形式、Java 8 的方法引用、Lambda 表达式的对比：

```
// functional/Strategize.java

interface Strategy {
  String approach(String msg);
}

class Soft implements Strategy {	//我们一般通过创建一个实现Strategy接口的类来实现这种行为
  public String approach(String msg) {
    return msg.toLowerCase() + "?";
  }
}

class Unrelated {
  static String twice(String msg) {
    return msg + " " + msg;
  }
}

public class Strategize {
  Strategy strategy;
  String msg;
  Strategize(String msg) {
    strategy = new Soft(); // [1] 在 Strategize 中，你可以看到 Soft 作为默认策略，在构造函数中赋值。
    this.msg = msg;
  }

  void communicate() {
    System.out.println(strategy.approach(msg));
  }

  void changeStrategy(Strategy strategy) {
    this.strategy = strategy;
  }

  public static void main(String[] args) {
    Strategy[] strategies = {	//Strategy 数组
      new Strategy() { // [2] 一种较为简洁且更加自然的方法是创建一个匿名内部类。
        public String approach(String msg) {
          return msg.toUpperCase() + "!";
        }
      },
      msg -> msg.substring(0, 5), // [3]Java 8 的 Lambda 表达式，其参数和函数体被箭头 -> 分隔开。箭头右侧是从 Lambda 返回的表达式。它与单独定义类和采用匿名内部类是等价的，但代码少得多。
      Unrelated::twice // [4] Java 8 的方法引用，它以 :: 为特征。 :: 的左边是类或对象的名称， :: 的右边是方法的名称，但是没有参数列表。
    };
    Strategize s = new Strategize("Hello there");
    s.communicate();
    for(Strategy newStrategy : strategies) {
      s.changeStrategy(newStrategy); // [5] 使用默认的 Soft 策略之后，我们逐步遍历数组中的所有 Strategy，并通过调用 changeStrategy() 方法将每个 Strategy 传入变量 s 中。
      s.communicate(); // [6] 每次调用 communicate() 都会产生不同的行为，具体取决于此刻正在使用的策略代码对象。我们传递的是行为，而并不仅仅是数据。
    }
  }
}
```

> #### 方法引用 和 Lambda 表达式的出现让我们可以在需要时 ***传递功能*** ，而不是仅在必要时才这么做。









## 2. Lambda 表达式

> #### ***`Lambda 表达式`*** 是使用 ***最小可能*** 语法编写的函数定义：
>
> - #### Lambda 表达式产生函数，而不是类。 虽然在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是类，但是幕后有各种操作执行让 Lambda 看起来像函数 —— 作为程序员，你可以高兴地假装它们“就是函数”。
>
> - #### Lambda 语法尽可能少 ， 这正是为了使 Lambda 易于编写和使用。

```
interface Description {
  String brief();
}

interface Body {
  String detailed(String head);
}

interface Multi {
  String twoArg(String head, Double d);
}

public class LambdaExpressions {

  static Body bod = h -> h + " No Parens!"; // [1] 当只用一个参数，可以不需要括号 ()。 然而，这是一个特例。

  static Body bod2 = (h) -> h + " More details"; // [2] 正常情况使用括号 () 包裹参数。 为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见

  static Description desc = () -> "Short info"; // [3] 如果没有参数，则必须使用括号 () 表示空参数列表。

  static Multi mult = (h, n) -> h + n; // [4] 对于多个参数，将参数列表放在括号 () 中。

  static Description moreLines = () -> { // [5] 如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 return。
    System.out.println("moreLines()");
    return "from moreLines()";
  };

  public static void main(String[] args) {
    System.out.println(bod.detailed("Oh!"));
    System.out.println(bod2.detailed("Hi!"));
    System.out.println(desc.brief());
    System.out.println(mult.twoArg("Pi! ", 3.14159));
    System.out.println(moreLines.brief());
  }
}
```

#### 任何 Lambda 表达式的基本语法是：

- #### 参数

- #### `->` 视为 “产出”

- #### `->` 之后的内容都是方法体

### (1) 递归

> #### 可以编写 ***递归的 Lambda 表达式*** ，但需要注意：递归方法必须是 实例变量 或 静态变量 ，否则会出现编译时错误：

```
interface IntCall {
  int call(int arg);
}
public class RecursiveFactorial {
  static IntCall fact;	// 静态变量
  public static void main(String[] args) {
    fact = n -> n == 0 ? 1 : n * fact.call(n - 1);
    for(int i = 0; i <= 10; i++)
      System.out.println(fact.call(i));
  }
}
public class RecursiveFibonacci {
  IntCall fib;
  RecursiveFibonacci() {
    fib = n -> n == 0 ? 0 :
               n == 1 ? 1 :
               fib.call(n - 1) + fib.call(n - 2);
  }
  
  int fibonacci(int n) { return fib.call(n); }

  public static void main(String[] args) {
    RecursiveFibonacci rf = new RecursiveFibonacci();
    for(int i = 0; i <= 10; i++)
      System.out.println(rf.fibonacci(i));
  }
}
```









## 3. 方法引用

> #### 方法引用组成：类名或对象名 + `::` + 方法名称。

```
import java.util.*;

interface Callable { // [1]
  void call(String s);
}

class Describe {
  void show(String msg) { // [2] show() 的签名符合接口 Callable 的 call() 的签名
    System.out.println(msg);
  }
}

public class MethodReferences {
  static void hello(String name) { // [3] hello() 的签名也符合接口 Callable 的 call() 的签名
    System.out.println("Hello, " + name);
  }
  static class Description {
    String about;
    Description(String desc) { about = desc; }
    void help(String msg) { // [4] 静态内部类中的非静态方法 help() 的签名也符合接口 Callable 的 call() 的签名
      System.out.println(about + " " + msg);
    }
  }
  static class Helper {
    static void assist(String msg) { // [5]  静态内部类中的非静态方法 assist() 的签名也符合接口 Callable 的 call() 的签名
      System.out.println(msg);
    }
  }
  public static void main(String[] args) {
    Describe d = new Describe();
    Callable c = d::show; // [6] 我们将 Describe 对象的方法引用赋值给 Callable ，它没有 show() 方法，而是 call() 方法。
    c.call("call()"); // [7] 我们现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show()。

    c = MethodReferences::hello; // [8] 这是一个静态方法引用。
    c.call("Bob");

    c = new Description("valuable")::help; // [9] 这是一个对已实例化对象的方法的引用，有时称为绑定方法引用。
    c.call("information");

    c = Helper::assist; // [10] 取静态内部类中静态方法的引用与 [8] 中通过外部类引用相似。
    c.call("Help!");
  }
}
```

### (1) Runnable 接口

> #### ***`Runnable 接口`*** 自1.0版本以来一直在 Java 中，因此不需要导入。它也符合特殊的但方法接口格式： 它的方法 `run()` 不带参数且没有返回值。所以我们可以使用 *Lambda 表达式* 和 *方法引用* 作为 Runnable 。

```
// 方法引用与 Runnable 接口的结合使用

class Go {
  static void go() {
    System.out.println("Go::go()");
  }
}

public class RunnableMethodReference {
  public static void main(String[] args) {

    new Thread(new Runnable() { // 匿名内部类。只有匿名内部类才要求显式声明 run() 方法。
      public void run() {
        System.out.println("Anonymous");
      }
    }).start();

    new Thread(
      () -> System.out.println("lambda") // Lambda 表达式
    ).start();

    new Thread(Go::go).start(); // 方法引用
  }
}
```







### (2) 未绑定的方法引用

> #### 未绑定的方法引用是指没有关联对象的普通(非静态)方法。使用未绑定的引用时，我们必须先提供对象。

```
// 没有方法引用的对象

class X {
  String f() { return "X::f()"; }
}

interface MakeString {
  String make();
}

interface TransformX {
  String transform(X x);
}

public class UnboundMethodReference {
  public static void main(String[] args) {
    // MakeString ms = X::f; // [1] 编译会报“invalid method reference”（无效方法引用）错误，因为方法引用需要一个隐藏参数 this 参与，我们不能再没有 X 对象的前提下调用 f() 。 X :: f 表示未绑定的方法引用，因为它尚未 “绑定” 到对象。
    TransformX sp = X::f;
    X x = new X();
    System.out.println(sp.transform(x)); // [2] 的结果有点像脑筋急转弯。我拿到未绑定的方法引用，并且调用它的transform()方法，将一个X类的对象传递给它，最后使得 x.f() 以某种方式被调用。Java知道它必须拿第一个参数，该参数实际就是this 对象，然后对此调用方法。
    System.out.println(x.f()); // 同等效果
  }
}
```







### (3) 构造函数引用

> #### 我们可以捕获构造函数的引用，然后通过引用调用该构造函数。

```
class Dog {
  String name;
  int age = -1; // For "unknown"
  Dog() { name = "stray"; }
  Dog(String nm) { name = nm; }
  Dog(String nm, int yrs) { name = nm; age = yrs; }
}

interface MakeNoArgs {
  Dog make();
}

interface Make1Arg {
  Dog make(String nm);
}

interface Make2Args {
  Dog make(String nm, int age);
}

public class CtorReference {
  public static void main(String[] args) {
    MakeNoArgs mna = Dog::new; // [1]
    Make1Arg m1a = Dog::new;   // [2]
    Make2Args m2a = Dog::new;  // [3]

    Dog dn = mna.make();
    Dog d1 = m1a.make("Comet");
    Dog d2 = m2a.make("Ralph", 4);
  }
}
```

> #### 这三个构造函数只有一个相同名称：`:: new`，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。











## 4. 函数式接口

> #### 方法引用 和 Lambda 表达式 都必须被赋值，同时赋值需要类型信息才能使编译器保证类型的正确性。

> #### Lambda 表达式包含 ***`类型推导`*** ：编译器会自动推导出类型信息，避免了程序员显式声明。

> #### Java 8 引入了 `java.util.function` 包。它包含一组接口，这些接口是 Lambda 表达式 和 方法引用 的目标类型。 每个接口只包含一个抽象方法，称为 ***`函数式方法`*** 。
>
> #### 在 *编写接口* 时，可以使用 `@FunctionalInterface` 注解强制执行此“函数式方法”模式。当接口中抽象方法多于一个时产生编译器错误。

> #### 如果将 方法引用 或 Lambda 表达式 赋值给 函数式接口 (类型需要匹配)，Java 会适配你的赋值到目标接口。 编译器会在后台把方法引用或 Lambda 表达式包装进实现目标接口的类的实例中。
>
> #### Java 8 允许我们 ***`将函数赋值给接口`*** ，这样的语法更加简单漂亮。

> #### `java.util.function` 包旨在 创建一组完整的目标接口 ，使得我们一般情况下不需再定义自己的接口。

#### 基本命名准则：

- #### 如果只处理对象而非基本类型，名称则为 `Function`，`Consumer`，`Predicate` 等。参数类型通过泛型添加。

- #### 如果接收的参数是基本类型，则由名称的第一部分表示，如 `LongConsumer`，`DoubleFunction`，`IntPredicate` 等，但返回基本类型的 `Supplier` 接口例外。

- #### 如果返回值为基本类型，则用 `To` 表示，如 `ToLongFunction <T>` 和 `IntToLongFunction`。

- #### 如果返回值类型与参数类型相同，则是一个 `Operator` ：单个参数使用 `UnaryOperator`，两个参数使用 `BinaryOperator`。

- #### 如果接收参数并返回一个布尔值，则是一个 **谓词** (`Predicate`)。

- #### 如果接收的两个参数类型不同，则名称中有一个 `Bi`。

|                           **特征**                           |                       **函数式方法名**                       |                           **示例**                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|                      无参数； 无返回值                       |               **Runnable** (java.lang) `run()`               |                         **Runnable**                         |
|                    无参数； 返回类型任意                     |              **Supplier** `get()` `getAs类型()`              | **Supplier`<T>` BooleanSupplier IntSupplier LongSupplier DoubleSupplier** |
|                    无参数； 返回类型任意                     |         **Callable** (java.util.concurrent) `call()`         |                      **Callable`<V>`**                       |
|                      1 参数； 无返回值                       |                   **Consumer** `accept()`                    |  **`Consumer<T>` IntConsumer LongConsumer DoubleConsumer**   |
|                     2 参数 **Consumer**                      |                  **BiConsumer** `accept()`                   |                    **`BiConsumer<T,U>`**                     |
| 2 参数 **Consumer**； 第一个参数是 引用； 第二个参数是 基本类型 |                **Obj类型Consumer** `accept()`                | **`ObjIntConsumer<T>` `ObjLongConsumer<T>` `ObjDoubleConsumer<T>`** |
|                    1 参数； 返回类型不同                     | **Function** `apply()` **To类型** 和 **类型To类型** `applyAs类型()` | **Function`<T,R>` IntFunction`<R>` `LongFunction<R>` DoubleFunction`<R>` ToIntFunction`<T>` `ToLongFunction<T>` `ToDoubleFunction<T>` IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction** |
|                    1 参数； 返回类型相同                     |                 **UnaryOperator** `apply()`                  | **`UnaryOperator<T>` IntUnaryOperator LongUnaryOperator DoubleUnaryOperator** |
|               2 参数，类型相同； 返回类型相同                |                 **BinaryOperator** `apply()`                 | **`BinaryOperator<T>` IntBinaryOperator LongBinaryOperator DoubleBinaryOperator** |
|                  2 参数，类型相同; 返回整型                  |              Comparator (java.util) `compare()`              |                     **`Comparator<T>`**                      |
|                     2 参数； 返回布尔型                      |                    **Predicate** `test()`                    | **`Predicate<T>` `BiPredicate<T,U>` IntPredicate LongPredicate DoublePredicate** |
|                 参数基本类型； 返回基本类型                  |            **类型To类型Function** `applyAs类型()`            | **IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction** |
|                      2 参数； 类型不同                       |                   **Bi操作** (不同方法名)                    | **`BiFunction<T,U,R>` `BiConsumer<T,U>` `BiPredicate<T,U>` `ToIntBiFunction<T,U>` `ToLongBiFunction<T,U>` `ToDoubleBiFunction<T>`** |

> #### 在使用函数接口时，名称无关紧要 —— 只要参数类型和返回类型相同。 Java 会将你的方法映射到接口方法。 要调用方法，可以调用接口的函数式方法名，而不是你的方法名。

### (1) 多参数函数式接口

> #### 如果需要多参数的函数式接口，我们可以很容易地查看 Java 库源代码并自行创建：

```
@FunctionalInterface
public interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}
```





### (2) 缺少基本类型的函数

> #### 许多函数式接口使用的是基本类型对应的类，这会导致隐式地自动拆装箱。所以使用基本类型的唯一理由是可以避免传递参数和返回结果过程中的自动拆装箱，进而提升性能。
>
> #### 如果因为缺少针对基本类型的函数或接口造成了性能问题，我们也可以轻松编写自己的接口。











## 4. 高阶函数

> #### ***`高阶函数`*** 只是一个 *消费或产生函数的函数* 。

```
import java.util.function.*;

interface
FuncSS extends Function<String, String> {} // [1] 使用继承轻松给专用接口创建别名

public class ProduceFunction {
  static FuncSS produce() { // produce() 是高阶函数
    return s -> s.toLowerCase(); // [2] 使用 Lambda 表达式 轻松在方法中创建和返回一个参数
  }
  public static void main(String[] args) {
    FuncSS f = produce();
    System.out.println(f.apply("YELLING"));
  }
}
import java.util.function.*;

class I {
  @Override
  public String toString() { return "I"; }
}

class O {
  @Override
  public String toString() { return "O"; }
}

public class TransformFunction {
  static Function<I,O> transform(Function<I,O> in) {
    return in.andThen(o -> {
      System.out.println(o);
      return o;
    });
  }
  public static void main(String[] args) {
    Function<I,O> f2 = transform(i -> {
      System.out.println(i);
      return new O();
    });
    O o = f2.apply(new I());
  }
}
```











## 5. 闭包

> #### ***`闭包`*** 一词非常重要，利用闭包可以轻松生成函数。Java 8 提供了有限但合理的闭包支持。

> #### 当我们调用函数时，若它引用了那些 “外部”(函数作用域之外的)变量，则会发生什么？ 能够解决这个问题的语言被称作 ***`支持闭包`*** ，或 ***`词法定界`*** ，又或 ***`变量捕获`*** 。

```
import java.util.function.*;

public class Closure1 {
  int i;
  IntSupplier makeFun(int x) {
    return () -> x + i++; //多次调用 makeFun 得到多个函数，它们共享 i 的存储空间。
  }
}

public class Closure2 {
  IntSupplier makeFun(int x) {
    int i = 0;
    return () -> x + i; //当调用返回的函数时 i 和 x 仍然有效，而不是正常情况下执行完 makeFun() 之后两者就消失了。
  }
}
```

> #### 同时， Lambda 表达式 引用的局部变量必须是 `final` 或者 `等同final` 效果的。
>
> #### 但是应用于对象引用的 `final` 关键字仅表示不会重新赋值引用。 它并不代表你不能修改对象本身。

> #### 结论是 ———— Lambda 可以没有限制地引用 实例变量和静态变量。但 局部变量必须显式声明为final，或事实上是final 。

### (1) 作为闭包的内部类

```
import java.util.function.*;

public class AnonymousClosure {
  IntSupplier makeFun(int x) {
    int i = 0;
    return new IntSupplier() {
      public int getAsInt() { return x + i; }
    };
  }
}
```

> #### 只要有内部类，就会有闭包。在 Java 8 之前，变量 `x` 和 `i` 必须被明确声明为 `final`。在 Java 8 中，内部类的规则放宽，包括**等同 final 效果**。









## 6. 函数组合

> #### ***`函数组合`*** 意为 “多个函数组合成新函数” 。它通常是函数式编程的基本组成部分。一些 `java.util.function` 接口中包含支持函数组合的方法：

|                          组合方法                           |                           支持接口                           |
| :---------------------------------------------------------: | :----------------------------------------------------------: |
|        `andThen(argument)` 执行原操作,再执行参数操作        | **Function BiFunction Consumer BiConsumer IntConsumer LongConsumer DoubleConsumer UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator BinaryOperator** |
|        `compose(argument)` 执行参数操作,再执行原操作        | **Function UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator** |
| `and(argument)` 原谓词(Predicate)和参数谓词的短路**逻辑与** | **Predicate BiPredicate IntPredicate LongPredicate DoublePredicate** |
|       `or(argument)` 原谓词和参数谓词的短路**逻辑或**       | **Predicate BiPredicate IntPredicate LongPredicate DoublePredicate** |
|                `negate()` 该谓词的**逻辑非**                | **Predicate BiPredicate IntPredicate LongPredicate DoublePredicate** |











## 7. 柯里化和部分求值

> #### ***`柯里化`*** 的名称来自于其发明者之一 *Haskell Curry*。其含义为：将一个多参数的函数，转换为一系列单参数函数。

```
import java.util.function.*;

public class CurryingAndPartials {
   // 未柯里化:
   static String uncurried(String a, String b) {
      return a + b;
   }
   public static void main(String[] args) {
      // 柯里化的函数:
      Function<String, Function<String, String>> sum =
         a -> b -> a + b; // [1] 在函数接口声明中，第二个参数是另一个函数

      System.out.println(uncurried("Hi ", "Ho"));

      Function<String, String>
        hi = sum.apply("Hi "); // [2] 柯里化的目的是能够通过提供单个参数来创建一个新函数，所以现在有了一个“带参函数”和剩下的“自由函数”。实际上，你从一个双参数函数开始，最后得到一个单参数函数。
      System.out.println(hi.apply("Ho"));

      // 部分应用:
      Function<String, String> sumHi =
        sum.apply("Hup ");
      System.out.println(sumHi.apply("Ho"));
      System.out.println(sumHi.apply("Hey"));
   }
}
```

> #### 我们可以通过继续添加层级来柯里化一个 三参数函数 ：

```
import java.util.function.*;

public class Curry3Args {
   public static void main(String[] args) {
      Function<String,
        Function<String,
          Function<String, String>>> sum =
            a -> b -> c -> a + b + c;
      Function<String,
        Function<String, String>> hi =
          sum.apply("Hi ");
      Function<String, String> ho =
        hi.apply("Ho ");
      System.out.println(ho.apply("Hup"));
   }
}
```

> #### 对于每一级的箭头级联，你都会在类型声明周围包裹另一个 **Function** 。









## 8. 纯函数式编程

> #### Java 8 让函数式编程更简单，不过我们要确保的是一切是 `final` 的，同时所有方法和函数 `没有副作用` 。因为 Java 本质上并非是不可变语言，所以编译器对我们所犯错误无能为力。









## 9. 本章小结

> #### Lambda 表达式和方法引用并没有将 Java 转换成函数式语言，而是提供了对函数式编程的支持。这对 Java 来说是一个巨大的改进。因为这允许你编写更简洁明了，易于理解的代码。















# [第十四章 流式编程](https://njuics.github.io/OnJava8/#/book/14-Streams?id=第十四章-流式编程)

> #### **`流`** 是与任何特定存储机制无关的元素序列，实际上 流是没有存储的 。 取代了在集合中迭代元素的做法，使用流即可从管道中提取元素并对其操作。这些管道通常被串联在一起形成一整套的管线，来对流进行操作。

> #### 流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用和流一起使用时会更让人感觉自成一体。

```
import java.util.*;
public class Randoms {
    public static void main(String[] args) {
        new Random(47)
            .ints(5, 20)	// ints() 方法产生一个流并且 ints() 方法有多种方式的重载 —— 两个参数限定了产生的数值的边界。
            .distinct()		// distinct() 使流中的整数不重复
            .limit(7)		// limit() 方法获取前 7 个元素
            .sorted()		// sorted() 方法排序
            .forEach(System.out::println);	// forEach() 方法遍历输出，它根据传递给它的函数对流中的每个对象执行操作
    }
}
```

> #### 注意 `Randoms.java` 中没有声明任何变量。流可以在不曾使用赋值或可变数据的情况下，对有状态的系统建模，这非常有用。

> #### ***`声明式编程`*** 是一种编程风格 ： 它声明了要做什么，而不是指明每一步如何做

> - #### 显式地编写迭代过程的方式称为 ***外部迭代*** 
>
> - #### 看不到迭代过程的方式称为     ***内部迭代*** ， 这是流式编程的一个核心特征
>
> #### 内部迭代产生的代码可读性更强，而且能更简单的使用多核处理器。通过放弃对迭代过程的控制，可以把控制权交给并行化机制。

> #### 流是 *懒加载* 的。这代表着它 只在绝对必要时才计算 。你可以将流看作“延迟列表”。由于计算延迟，流使我们能够表示非常大（甚至无限）的序列，而不需要考虑内存问题。

## 1. 流支持

> #### Java 8 采用的解决方案是：在接口中添加被 `default` 修饰的方法。这样设计者可以将 流式方法 平滑地嵌入到现有类中。
>
> #### 流操作的类型有三种：创建流、修改流元素(中间操作)、消费流元素(终端操作)









## 2. 流创建

> #### 可以通过 `Stream.of()` 很容易地将一组元素转化成为流：

```
import java.util.stream.*;
public class StreamOf {
    public static void main(String[] args) {
        Stream.of(new Bubble(1), new Bubble(2), new Bubble(3))
            .forEach(System.out::println);
        Stream.of("It's ", "a ", "wonderful ", "day ", "for ", "pie!")
            .forEach(System.out::print);
        System.out.println();
        Stream.of(3.14159, 2.718, 1.618)
            .forEach(System.out::println);
    }
}
```

> #### 每个集合可以通过调用 `stream()` 方法来产生一个流：

```
import java.util.*;
import java.util.stream.*;
public class CollectionToStream {
    public static void main(String[] args) {
        List<Bubble> bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));
        System.out.println(bubbles.stream() 
            .mapToInt(b -> b.i)	//mapToInt() 方法将一个对象流（object stream）转换成为包含整型数字的 IntStream
            .sum());
        
        Set<String> w = new HashSet<>(Arrays.asList("It's a wonderful day for pie!".split(" ")));
        w.stream()		// 只需要简单地调用所有集合中都有的 stream()，即可产生一个流
         .map(x -> x + " ")	// 中间操作 map() 会获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中
         .forEach(System.out::print);
        System.out.println();
        
        Map<String, Double> m = new HashMap<>();
        m.put("pi", 3.14159);
        m.put("e", 2.718);
        m.put("phi", 1.618);
        m.entrySet().stream()	// 调用 entrySet() 产生一个对象流，每个对象都包含一对键值对。
                    .map(e -> e.getKey() + ": " + e.getValue())
                    .forEach(System.out::println);
    }
}
```

### (1) 随机数流

> #### `Random` 类被一组生成流的方法增强了
>
> #### **Random** 类只能生成基本类型 **int**， **long**， **double** 的流。但 `boxed()` 流操作将会自动地把基本类型包装成为对应的装箱类型。

```
// streams/RandomWords.java
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
import java.io.*;
import java.nio.file.*;
public class RandomWords implements Supplier<String> {
    List<String> words = new ArrayList<>();
    Random rand = new Random(47);
    RandomWords(String fname) throws IOException {
        List<String> lines = Files.readAllLines(Paths.get(fname));
        // 略过第一行
        for (String line : lines.subList(1, lines.size())) {
            for (String word : line.split("[ .?,]+")) // 正则表达式
                words.add(word.toLowerCase());
        }
    }
    public String get() {
        return words.get(rand.nextInt(words.size()));
    }
    @Override
    public String toString() {
        return words.stream()
            .collect(Collectors.joining(" ")); // collect() 操作，它根据参数来结合所有的流元素。
    }
    public static void main(String[] args) throws Exception {
        System.out.println(
            Stream.generate(new RandomWords("Cheese.dat")) // Stream.generate() 的用法，它可以把任意 Supplier<T> 用于生成 T 类型的流。
                .limit(10)
                .collect(Collectors.joining(" "))); // 用 Collectors.joining()作为 collect() 的参数时，将得到一个String 类型的结果，该结果是流中的所有元素被joining()的参数隔开。
    }
}
```







### (2) int 类型的范围

> #### `IntStream` 类提供了 `range()` 方法用于生成整型序列的流。 并且实用小功能 `repeat()` 可以用来替换简单的 `for` 循环。

```
package onjava;
import static java.util.stream.IntStream.*;
public class Repeat {
    public static void repeat(int n, Runnable action) {
        range(0, n).forEach(i -> action.run());
    }
}
```







### (3) generate()

> #### 如果要创建包含相同对象的流，只需要传递一个生成哪些对象的 `lambda` 到 `generate()` 中：

```
import java.util.stream.*;
public class Duplicator {
    public static void main(String[] args) {
        Stream.generate(() -> "duplicate")
              .limit(3)
              .forEach(System.out::println);
    }
}
```



```
import java.util.function.*;
public class Bubble {
    public final int i;
    
    public Bubble(int n) {
        i = n;
    }
    
    @Override
    public String toString() {
        return "Bubble(" + i + ")";
    }
    
    private static int count = 0;
    public static Bubble bubbler() {
        return new Bubble(count++);
    }
}
import java.util.stream.*;
public class Bubbles {
    public static void main(String[] args) {
        Stream.generate(Bubble::bubbler)
              .limit(5)
              .forEach(System.out::println);
    }
}
import java.util.stream.*;
public class Bubbles {
    public static void main(String[] args) {
        Stream.generate(Bubble::bubbler)
              .limit(5)
              .forEach(System.out::println);
    }
}
```

> #### 这是创建 *单独工厂类* 的另一种方式。在很多方面它更加整洁，但是这是一个关于代码组织和品味的问题——你总是可以创建一个完全不同的工厂类。







### (4) iterate()

> #### `Stream.iterate()` 产生的流的第一个元素是种子（iterate方法的第一个参数），然后将种子传递给方法（iterate方法的第二个参数）。方法运行的结果被添加到流（作为流的下一个元素），并被存储起来，作为下次调用 `iterate()`方法时的第一个参数，以此类推。

```
// streams/Fibonacci.java
import java.util.stream.*;
public class Fibonacci {
    int x = 1;
    
    Stream<Integer> numbers() {
        return Stream.iterate(0, i -> {
            int result = x + i;
            x = i;
            return result;
        });
    }
    
    public static void main(String[] args) {
        new Fibonacci().numbers()
                       .skip(20) // 过滤前 20 个
                       .limit(10) // 然后取 10 个
                       .forEach(System.out::println);
    }
}
```







### (5) 流的建造者模式

> #### 在 *`建造者模式`* 中，首先创建一个 `builder` 对象，然后将创建流所需的多个信息传递给它，最后`builder` 对象执行”创建“流的操作。**Stream** 库提供了这样的 `Builder`。







### (6) Arrays

> #### `Arrays` 类中含有一个名为 `stream()` 的静态方法用于把数组转换成为流。







### (7) 正则表达式

> #### Java 8 在 `java.util.regex.Pattern` 中增加了一个新的方法 `splitAsStream()`。这个方法可以根据 传入的公式 *将字符序列转化为流* 。但是有一个限制，输入只能是 **CharSequence**，因此不能将流作为 `splitAsStream()` 的参数。

#### 流操作非常重要的优势：

- #### “不需要把流存储起来。”当然，流确实需要一些内部存储，但存储的只是序列的一小部分，和存储整个序列不同。

- #### 它们是懒加载计算的。











## 3. 中间操作

> #### ***`中间操作`*** 用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作

### (1) 跟踪和调试

> #### `peek()` 操作的目的是帮助调试，它允许我们无修改地查看流中元素。这是由于 `peek()` 符合无返回值的 **Consumer** 函数式接口，所以我们只能观察而无法使用不同的元素来替换流中对象。

```
class Peeking {
    public static void main(String[] args) throws Exception {
        FileToWords.stream("Cheese.dat")
        .skip(21)
        .limit(4)
        .map(w -> w + " ")
        .peek(System.out::print)
        .map(String::toUpperCase)
        .peek(System.out::print)
        .map(String::toLowerCase)
        .forEach(System.out::print);
    }
}
```







### (2) 流元素排序

> #### `sorted()` 还有另一种形式的实现：传入一个 **Comparator** 参数，`sorted()` 预设了一些默认的比较器，当然也可以把 Lambda 函数作为参数传递：

```
import java.util.*;
public class SortedComparator {
    public static void main(String[] args) throws Exception {
        FileToWords.stream("Cheese.dat")
        .skip(10)
        .limit(10)
        .sorted(Comparator.reverseOrder())
        .map(w -> w + " ")
        .forEach(System.out::print);
    }
}
```







### (3) 移除元素

- #### `distinct()`：在 `Randoms.java` 类中的 `distinct()` 可用于消除流中的重复元素。相比创建一个 **Set** 集合来消除重复，该方法的工作量要少得多。

- #### `filter(Predicate)`：过滤操作，保留如下元素：若元素传递给过滤函数产生的结果为`true` 。







### (4) 应用函数到元素

- #### `map(Function)`：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。

- #### `mapToInt(ToIntFunction)`：操作同上，但结果是 **IntStream**。

- #### `mapToLong(ToLongFunction)`：操作同上，但结果是 **LongStream**。

- #### `mapToDouble(ToDoubleFunction)`：操作同上，但结果是 **DoubleStream**。

> #### 我们完全可以产生和接收类型完全不同的类型，从而改变流的数据类型：

```
import java.util.*;
import java.util.stream.*;
class Numbered {
    final int n;
    Numbered(int n) {
        this.n = n;
    }
    @Override
    public String toString() {
        return "Numbered(" + n + ")";
    }
}
class FunctionMap2 {
    public static void main(String[] args) {
        Stream.of(1, 5, 7, 9, 11, 13)
        .map(Numbered::new)		// 将获取到的整数通过构造器 Numbered::new 转化成为 Numbered 类型。
        .forEach(System.out::println);
    }
}
```







#### (5) 在 `map()` 中组合流

> #### `flatMap()` 做了两件事：将产生流的函数应用在每个元素上（与 `map()` 所做的相同） ； 然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。

- #### `flatMap(Function)` ：当 `Function` 产生流时使用。

- #### `flatMapToInt(Function)` ：当 `Function` 产生 `IntStream` 时使用。

- #### `flatMapToLong(Function)` ：当 `Function` 产生 `LongStream` 时使用。

- #### `flatMapToDouble(Function)` ：当 `Function` 产生 `DoubleStream` 时使用。

```
import java.util.stream.*;
public class FlatMap {
    public static void main(String[] args) {
        Stream.of(1, 2, 3)
        .flatMap(i -> Stream.of("Gonzo", "Fozzie", "Beaker")) // 从映射返回的每个流都会自动扁平为组成它的字符串.
        .forEach(System.out::println);
    }
}
import java.util.*;
import java.util.stream.*;
public class StreamOfRandoms {
    static Random rand = new Random(47);
    public static void main(String[] args) {
        Stream.of(1, 2, 3, 4, 5)
            .flatMapToInt(i -> IntStream.concat( // concat()，它以参数顺序组合两个流。
        rand.ints(0, 100).limit(i), IntStream.of(-1)))
            .forEach(n -> System.out.format("%d ", n));
    }
}
```

> #### 每次需要一个新的流时，我们都必须从头开始创建，因为流不能被复用。













## 4. Optional 类

> #### 在软件或信息建模的上下文中，***`快乐路径`*** (有时称为快乐流)是没有异常或错误条件的默认场景。
>
> #### 我们喜欢沿着 “快乐路径” 把流连接起来，同时假设流不会中断。然而在流中防止 `null` 却会轻易令其中断。所以我们希望存在这样的对象：可以在持有流元素的同时，即使在我们查找的元素不存在时也可以进行友好的提示。
>
> #### *`Optional`* 可以实现这样的功能。一些标准流操作返回 **`Optional`** 对象，因为它们并不能保证预期结果一定存在。例如：
>
> - #### `findFirst()` 返回一个包含第一个元素的 **Optional** 对象，如果流为空则返回 **Optional.empty**
>
> - #### `findAny()` 返回包含任意元素的 **Optional** 对象，如果流为空则返回 **Optional.empty**
>
> - #### `max()` 和 `min()` 返回一个包含最大值或者最小值的 **Optional** 对象，如果流为空则返回 **Optional.empty**

```
import java.util.*;
import java.util.stream.*;
class OptionalsFromEmptyStreams {
    public static void main(String[] args) {
        System.out.println(Stream.<String>empty()
             .findFirst());
        System.out.println(Stream.<String>empty()
             .findAny());
        System.out.println(Stream.<String>empty()
             .max(String.CASE_INSENSITIVE_ORDER));
        System.out.println(Stream.<String>empty()
             .min(String.CASE_INSENSITIVE_ORDER));
        System.out.println(Stream.<String>empty()
             .reduce((s1, s2) -> s1 + s2));
        System.out.println(IntStream.empty()
             .average());
    }
}
```

> #### Optional 的两个基本用法：

```
import java.util.*;
import java.util.stream.*;
class OptionalBasics {
    static void test(Optional<String> optString) {
        if(optString.isPresent()) 	// 调用 isPresent() 检查其中是否包含元素
            System.out.println(optString.get()); 
        else
            System.out.println("Nothing inside!");
    }
    public static void main(String[] args) {
        test(Stream.of("Epithets").findFirst());
        test(Stream.<String>empty().findFirst());
    }
}
```

### (1) 便利函数

> #### 有很多便利函数可以解包 Optional ，这简化了上述 “对所包含的对象的检查和执行操作” 过程：
>
> - #### `ifPresent(Consumer)`：当值存在时调用 **Consumer**，否则什么也不做。
>
> - #### `orElse(otherObject)`：如果值存在则直接返回，否则生成 **otherObject**。
>
> - #### `orElseGet(Supplier)`：如果值存在则直接返回，否则使用 **Supplier** 函数生成一个可替代对象。
>
> - #### `orElseThrow(Supplier)`：如果值存在直接返回，否则使用 **Supplier** 函数生成一个异常。







### (2) 创建 Optional

> #### 当我们在自己的代码中加入 **Optional** 时，可以使用下面 3 个静态方法：
>
> - #### `empty()`：生成一个空 **Optional**。
>
> - #### `of(value)`：将一个非空值包装到 **Optional** 里。
>
> - #### `ofNullable(value)`：针对一个可能为空的值，为空时自动生成 **Optional.empty**，否则将值包装在 **Optional** 中。

```
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
class CreatingOptionals {
    static void test(String testName, Optional<String> opt) {
        System.out.println(" === " + testName + " === ");
        System.out.println(opt.orElse("Null"));
    }
    public static void main(String[] args) {
        test("empty", Optional.empty());
        test("of", Optional.of("Howdy"));
        try {
            test("of", Optional.of(null));	// 我们不能通过传递 null 到 of() 来创建 Optional 对象。最安全的方法是， 使用 ofNullable() 来优雅地处理 null。
        } catch(Exception e) {
            System.out.println(e);
        }
        test("ofNullable", Optional.ofNullable("Hi"));
        test("ofNullable", Optional.ofNullable(null));
    }
}
```







### (3) Optional 对象操作

> #### 当我们的流管道生成了 **Optional** 对象，下面 3 个方法可使得 **Optional** 的后续能做更多的操作：
>
> - #### `filter(Predicate)`：对 **Optional** 中的内容应用**Predicate** 并将结果返回。如果 **Optional** 不满足 **Predicate** ，将 **Optional** 转化为空 **Optional** 。如果 **Optional** 已经为空，则直接返回空**Optional** 。
>
> - #### `map(Function)`：如果 **Optional** 不为空，应用 **Function** 于 **Optional** 中的内容，并返回结果。否则直接返回 **Optional.empty**。
>
>     - ##### 一般来说，流的 `filter()` 会在 **Predicate** 返回 `false` 时移除流元素 ； 而 `Optional.filter()` 在失败时不会删除 **Optional**，而是将其保留下来，并转化为空。
>
> - #### `flatMap(Function)`：同 `map()`，但是提供的映射函数将结果包装在 **Optional** 对象中，因此 `flatMap()` 不会在最后进行任何包装。
>
> #### 以上方法都不适用于数值型 **Optional** 。

> #### `Optional.map()` 执行一个函数。它仅在 **Optional** 不为空时才执行这个映射函数。并将 **Optional** 的内容提取出来，传递给映射函数。
>
> #### `flatMap()` 将提取非空 **Optional** 的内容并将其应用在映射函数。唯一的区别就是 `flatMap()` 不会把结果包装在 **Optional** 中，因为映射函数已经被包装过了。







### (4) Optional 流

> #### 假设我们的生成器可能产生 `null` 值，那么当用它来创建流时，我们会自然地想到用 Optional 来包装元素。













## 5. 终端操作

> #### ***`终端操作`*** 总是我们在流管道中所做的最后一件事，至此我们无法再继续往后传递流。

### (1) 数组

- #### `toArray()`：将流转换成适当类型的数组。

- #### `toArray(generator)`：在特殊情况下，生成自定义类型的数组。







### (2) 循环

- #### `forEach(Consumer)` ： 常见如 `System.out::println` 作为 **Consumer** 函数。无序操作，仅在引入并行流时才有意义。

- #### `forEachOrdered(Consumer)` ： 保证 `forEach` 按照原始流顺序操作。







### (3) 集合

- #### `collect(Collector)`：使用 **Collector** 收集流元素到结果集合中。

- #### `collect(Supplier, BiConsumer, BiConsumer)`：同上，第一个参数 **Supplier** 创建了一个新的结果集合，第二个参数 **BiConsumer** 将下一个元素收集到结果集合中，第三个参数 **BiConsumer** 用于将两个结果集合合并起来。

```
import java.util.*;
import java.util.stream.*;
public class SpecialCollector {
    public static void main(String[] args) throws Exception {
        ArrayList<String> words =
                FileToWords.stream("Cheese.dat")
                        .collect(ArrayList::new,
                                ArrayList::add,
                                ArrayList::addAll);
        words.stream()
                .filter(s -> s.equals("cheese"))
                .forEach(System.out::println);
    }
}
```







### (4) 组合

- #### `reduce(BinaryOperator)`：使用 **BinaryOperator** 来组合所有流中的元素。因为流可能为空，其返回值为 **Optional**。

- #### `reduce(identity, BinaryOperator)`：功能同上，但是使用 **identity** 作为其组合的初始值。因此如果流为空，**identity** 就是结果。

- #### `reduce(identity, BiFunction, BinaryOperator)`：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 `map()` 和 `reduce()` 来更简单的表达它。

```
import java.util.*;
import java.util.stream.*;
class Frobnitz {
    int size;
    Frobnitz(int sz) { size = sz; }
    @Override
    public String toString() {
        return "Frobnitz(" + size + ")";
    }
    // Generator:
    static Random rand = new Random(47);
    static final int BOUND = 100;
    static Frobnitz supply() {
        return new Frobnitz(rand.nextInt(BOUND));
    }
}
public class Reduce {
    public static void main(String[] args) {
        Stream.generate(Frobnitz::supply)
                .limit(10)
                .peek(System.out::println)
                .reduce((fr0, fr1) -> fr0.size < 50 ? fr0 : fr1)
                .ifPresent(System.out::println);
    }
}
```







### (5) 匹配

- #### `allMatch(Predicate)` ：如果流的每个元素提供给 **Predicate** 都返回 true ，结果返回为 true。在第一个 false 时，则停止执行计算。

- #### `anyMatch(Predicate)`：如果流的任意一个元素提供给 **Predicate** 返回 true ，结果返回为 true。在第一个 true 是停止执行计算。

- #### `noneMatch(Predicate)`：如果流的每个元素提供给 **Predicate** 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。

```
import java.util.stream.*;
import java.util.function.*;
import static streams.RandInts.*;

interface Matcher extends BiPredicate<Stream<Integer>, Predicate<Integer>> {}
        
public class Matching {
    static void show(Matcher match, int val) {
        System.out.println(
                match.test(
                        IntStream.rangeClosed(1, 9)
                                .boxed()
                                .peek(n -> System.out.format("%d ", n)),	// peek()用来展示在测试短路之前测试进行到了哪一步。
                        n -> n < val));
    }
    public static void main(String[] args) {
        show(Stream::allMatch, 10);
        show(Stream::allMatch, 4);
        show(Stream::anyMatch, 2);
        show(Stream::anyMatch, 0);
        show(Stream::noneMatch, 5);
        show(Stream::noneMatch, 0);
    }
}
```







### (6) 查找

- #### `findFirst()`：返回第一个流元素的 **Optional**，如果流为空返回 **Optional.empty**。

- #### `findAny()`：返回含有任意流元素的 **Optional**，如果流为空返回 **Optional.empty**。

```
import java.util.*;
import java.util.stream.*;
import static streams.RandInts.*;
public class SelectElement {
    public static void main(String[] args) {
        System.out.println(rands().findFirst().getAsInt());
        System.out.println(
                rands().parallel().findFirst().getAsInt());
        System.out.println(rands().findAny().getAsInt());
        System.out.println(
                rands().parallel().findAny().getAsInt());
    }
}
```







### (7) 信息

- #### `count()`：流中的元素个数。

- #### `max(Comparator)`：根据所传入的 **Comparator** 所决定的“最大”元素。

- #### `min(Comparator)`：根据所传入的 **Comparator** 所决定的“最小”元素。

```
import java.util.stream.*;
import java.util.function.*;
public class Informational {
    public static void
    main(String[] args) throws Exception {
        System.out.println(
                FileToWords.stream("Cheese.dat").count());
        System.out.println(
                FileToWords.stream("Cheese.dat")
                        .min(String.CASE_INSENSITIVE_ORDER)
                        .orElse("NONE"));	// min() 和 max() 的返回类型为 Optional，这需要我们使用 orElse()来解包。
        System.out.println(
                FileToWords.stream("Cheese.dat")
                        .max(String.CASE_INSENSITIVE_ORDER)
                        .orElse("NONE"));
    }
}
```







### (8) 数字流信息

- #### `average()` ：求取流元素平均值。

- #### `max()` 和 `min()`：数值流操作无需 **Comparator**。

- #### `sum()`：对所有流元素进行求和。

- #### `summaryStatistics()`：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。

```
import java.util.stream.*;
import static streams.RandInts.*;
public class NumericStreamInfo {
    public static void main(String[] args) {
        System.out.println(rands().average().getAsDouble());
        System.out.println(rands().max().getAsInt());
        System.out.println(rands().min().getAsInt());
        System.out.println(rands().sum());
        System.out.println(rands().summaryStatistics());
    }
}
```













## 6. 本章小结

> #### 流式操作改变并极大地提升了 ***Java 语言的可编程性*** ，并可能极大地阻止了 Java 编程人员向诸如 Scala 这种函数式语言的流转。















# [第十五章 异常](https://njuics.github.io/OnJava8/#/book/15-Exceptions?id=第十五章-异常)

> #### Java 的基本理念是 ***`“结构不佳的代码不能运行”`*** 。

> #### 发现错误的理想时机是在编译阶段，也就是在我们试图运行程序之前。然而编译期间并不能找出所有错误，余下问题必须在运行期间解决。这就需要错误源能通过某种方式，把适当的信息传递给某个接收者 ———— 该接收者江之岛如何处理这个问题。

> #### Java 使用异常来提供一致的 错误报告模型 ，使得构件能够与客户端代码可靠地沟通问题。

## 1. 异常概念

> #### ***`“异常”`*** 这个词有 “我对此感到意外” 的意思。所以当问题出现时，我们也许不清楚如何处理，但我们知道不应当对它置之不理，我们需要程序停下来看看是否有别人或在别的地方，能够处理这个问题。如果在当前环境中没有足够的信息来解决它，则需要把这个问题提交到更高级别的环境中，在那里做出决定。

> #### 异常往往能 ***降低错误处理代码的复杂度*** 。使用了异常，就不必在方法调用处进行检查，因为异常机制将保证能够捕获该错误。
>
> #### 这种方式不仅节省代码，而且把 ***“描述在正常执行过程中做什么事”*** 的代码和 ***“出了问题怎么办”*** 的代码相分离。









## 2. 基本异常

> #### ***`异常情形`*** 是指 ***阻止当前方法或作用域继续执行的问题*** ，无法继续下去。
>
> #### ***`普通问题`*** 是指 ***在当前环境下能得到足够信息从而处理这个错误*** ，处理完毕可以继续下去。
>
> #### 由于在异常情形下，我们无法在当前环境中获得必要的信息以解决问题，所以只能从当前环境中跳出，并把问题提交给上一级环境。这就是 ***`抛出异常`*** 时所发生的事情。

#### 当抛出异常后，有几件事会随之发生：

- #### 首先，将使用 new 在堆上创建异常对象。

- #### 然后，当前的执行路径（它不能继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。

- #### 此时，异常处理机制接管程序，并开始寻找一个异常处理程序继续执行。它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。

> #### ***`抛出一个异常`*** ：可以创建一个代表错误信息的对象并把它从当前环境中 “抛出” ，这样就把错误信息传播到了 “更大” 的环境中。

> #### 异常允许我们将做的每件事都当作一个事务来考虑，而异常守护着这些事物，“事务相当于计算机中的合同法。如果任何事出现了错误，我们只需要丢弃整个计算。”
>
> #### 也可以将异常看作一种内建的 *“恢复”系统* ，以外在程序中可以有各种恢复点。一旦程序的一部分失败了，异常将恢复到一个已知的稳定点上。

### (1) 异常参数

> #### 所有标准异常类都有两个构造器：`无参构造器` 和 `接受字符串作为参数的构造器`

> #### ①尽管异常对象的类型通常与方法设计的返回类型不同，但从效果上看，它就像是从方法“返回”的。 ②另外还能用抛出异常的方式从当前的作用域退出。在这两种情况下，将会返回一个异常对象，然后退出方法或作用域。

> #### 异常返回的“地点”与普通方法调用返回的“地点”完全不同。（异常将在一个恰当的异常处理程序中得到解决，它的位置可能离异常被抛出的地方很远，也可能会跨越方法调用栈的许多层级。）

> #### 能抛出任意类型的 `Throwable` 对象是异常类型的根类，错误信息保存在 异常对象内部 或 用异常类的名称来暗示 。











## 3. 异常捕获

> #### ***`监控区域`*** ： 是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。

> #### 如果在方法内部抛出了异常(或者在方法内部调用的其他方法抛出了异常)，这个方法将在怕抛出异常的过程中结束。但是可以使用 try 块捕获异常。

> #### 有了异常处理机制，可以把所有动作都放在 try 块里，然后只需在一个地方就可以捕获所有异常。这意味着我们的代码将更容易编写和阅读，因为代码的意图和错误检查不是混淆在一起的。

### (1) 异常处理程序

> #### ***`异常处理程序`*** 紧跟在 try 块之后，以关键字 catch 表示：

```
try {
    // Code that might generate exceptions
} catch(Type1 id1) {
    // Handle exceptions of Type1
} catch(Type2 id2) {
    // Handle exceptions of Type2
} catch(Type3 id3) {
    // Handle exceptions of Type3
}
// etc.
```

> #### 当异常被抛出后，异常处理机制将负责搜寻 *参数与异常类型相匹配* 的第一个处理程序，然后进入 catch 子句执行，执行结束后则处理程序的查找过程结束。

> #### 在 try 块内部，许多不同的方法调用可能会产生类型相同的异常，但我们只需要提供一个针对此类型的异常处理程序。







### (2) 终止和恢复

#### 异常处理理论上有两种模型：

- #### Java 和 C++ 支持 ***`终止模型`*** ： 这种模型假设错误非常严重，以至于程序无法返回异常发生的地方继续执行。

- #### ***`恢复模型`*** ： 异常处理程序的工作室修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。

- #### Java实现恢复行为的方法有：遇见错误不抛出异常而是调用方法来修正；或者将 try 块放入while循环中。











## 4. 自定义异常

> #### 我们可以创建自己的异常类，来表示程序中可能遇到的问题。定义异常类必须从已有的、意思相近的异常类继承。而建立新的异常类型最简单的方法就是让编译器为你产生无参构造器。

```
class SimpleException extends Exception {}

public class InheritingExceptions {
    public void f() throws SimpleException {
        System.out.println(
                "Throw SimpleException from f()");
        throw new SimpleException();
    }
    public static void main(String[] args) {
        InheritingExceptions sed =
                new InheritingExceptions();
        try {
            sed.f();
        } catch(SimpleException e) {
            System.out.println("Caught it!");
        }
    }
}
```

> #### 对异常来说，最重要的部分就是类名。通常将错误写入 `System.err` 要比输出到 `System.out` 好。

> #### `Throwable` 类中声明的 `printStackTrace()` 方法它将打印“从方法调用处直到异常抛出处”的方法调用序列

```
class MyException extends Exception {
    MyException() {}
    MyException(String msg) { super(msg); }
}
public class FullConstructors {
    public static void f() throws MyException {
        System.out.println("Throwing MyException from f()");
        throw new MyException();
    }
    public static void g() throws MyException {
        System.out.println("Throwing MyException from g()");
        throw new MyException("Originated in g()");
    }
    public static void main(String[] args) {
        try {
            f();
        } catch(MyException e) {
            e.printStackTrace(System.out);
        }
        try {
            g();
        } catch(MyException e) {
            e.printStackTrace(System.out);
        }
    }
}
```







### (1) 异常与记录日志

> #### 我们可以使用  `java.util.logging` 工具将输出记录到日志中。

```
import java.util.logging.*;
import java.io.*;
class LoggingException extends Exception {
    private static Logger logger =
            Logger.getLogger("LoggingException");	// 静态的 Logger.getLogger() 方法创建了一个 String 参数相关联的 Logger 对象
    LoggingException() {
        StringWriter trace = new StringWriter();
        printStackTrace(new PrintWriter(trace));	// 使用重载的 printStackTrace() 方法，它接受一个 java.io.PrintWriter 对象作为参数，从而获得异常抛出处的栈轨迹的字符串
        logger.severe(trace.toString());	// 向 Logger 写入的最简单方式就是直接调用与日志记录消息的级别相关联的方法，这里使用的是 severe()。
    }
}
public class LoggingExceptions {
    public static void main(String[] args) {
        try {
            throw new LoggingException();
        } catch(LoggingException e) {
            System.err.println("Caught " + e);
        }
        try {
            throw new LoggingException();
        } catch(LoggingException e) {
            System.err.println("Caught " + e);
        }
    }
}
```

> #### 既然异常也是对象的一种，所以可以继续修改异常类已得到更强的功能。但实用程序包的客户端程序员可能仅仅只是查看一下抛出的异常类型便不管了，所以针对异常添加的其他功能也许根部用不上。











## 5. 异常声明

> #### Java 鼓励人们把方法可能会抛出的异常告知此方法的客户端程序员。这是种优雅的做法，它使得调用者能确切的知道写什么样的代码可以捕获所有潜在的异常。

> #### ***`异常说明`*** ：属于方法声明的一部分，紧跟在形式参数列表之后。Java 提供相应语法(并强制使用该语法)，使我们能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，从而客户端程序员可以进行相应的处理。

> #### 代码必须与异常说明保持一致。如果 *方法里产生了异常却没有进行处理* ，编译器会发现这个问题并提醒你：要么处理这个异常，要么在异常说明中表明此方法将产生异常。













## 6. 捕获所有异常

> #### 可以通过捕获异常类型的基类 `Exception` 来实现只写一个异常处理程序捕获所有类型异常。 最好将其放在处理程序列表的末尾，以防它抢在其他处理程序之前先把异常捕获了。

> #### 可以调用 `Exception` 从基类 `Throwable` 继承的方法： 

```
String getMessage()
String getLocalizedMessage()
String toString()
void printStackTrace()
void printStackTrace(PrintStream)
void printStackTrace(java.io.PrintWriter)
public class ExceptionMethods {
    public static void main(String[] args) {
        try {
            throw new Exception("My Exception");
        } catch(Exception e) {
            System.out.println("Caught Exception");
            System.out.println(
                    "getMessage():" + e.getMessage());
            System.out.println("getLocalizedMessage():" +
                    e.getLocalizedMessage());
            System.out.println("toString():" + e);
            System.out.println("printStackTrace():");
            e.printStackTrace(System.out);
        }
    }
}
/* Output:
Caught Exception
getMessage():My Exception
getLocalizedMessage():My Exception
toString():java.lang.Exception: My Exception
printStackTrace():
java.lang.Exception: My Exception
at ExceptionMethods.main(ExceptionMethods.java:7)*/
```

### (1) 多重捕获

> #### 通过 Java 7 的多重捕获机制，你可以使用“或”将不同类型的异常组合起来，从而只需要一行 catch 语句。这对于书写更整洁的代码很有帮助。







### (2) 栈轨迹

> #### `printStackTrace()` 方法所提供的信息可以通过 `getStackTrace()` 方法来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一桢。元素 0 是栈顶元素，并且是调用序列中的最后一个方法调用。数组中的最后一个元素和栈底是调用序列中的第一个方法调用。

```
public class WhoCalled {
    static void f() {
// Generate an exception to fill in the stack trace
        try {
            throw new Exception();
        } catch(Exception e) {
            for(StackTraceElement ste : e.getStackTrace())
                System.out.println(ste.getMethodName());
        }
    }
    static void g() { f(); }
    static void h() { g(); }
    public static void main(String[] args) {
        f();
        System.out.println("*******");
        g();
        System.out.println("*******");
        h();
    }
}
```







### (2) 重新抛出异常

> #### 我们可以将捕获到的异常在 catch 块种重新抛出，此时异常会被抛给上一级环境中的异常处理程序，在同一个 try 块的后续 catch 子句将被忽略

```
catch(Exception e) {
    System.out.println("An exception was thrown");
    throw e;
}
```

> #### 如果只是把当前异常对象重新抛出，那么 `printStackTrace()` 方法显示的将是原来异常抛出点的调用栈信息而非重新抛出点的信息，若要更新这个信息，可以调用 `fillInStackTrace()` 方法，这将返回一个 `Throwable` 对象，它是通过把当前调用栈信息填入原来的异常对象而建立的。
>
> #### 调用 `fillInStackTrace()` 的那一行就成了异常的新发生地了。如果在捕获异常之后抛出另一种异常，那么得到的效果类似于使用 `fillStackTrace()` ，有关原来异常发生点的信息会丢失，剩下的事与新的抛出点有关的信息。







### (3) 精准的重新抛出异常

> #### 在 Java 7 之前，如果捕捉到一个异常，重新抛出的异常类型只能与原异常完全相同。这导致代码不精确，Java 7修复了这个问题。







### (4) 异常链

> #### 常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为 ***`异常链`*** 。
>
> #### 所有 Throwable 的子类在构造器中都可以接受一个 ***`cause`*** 对象作为参数。这个 cause 就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。

> #### 在 `Throwable` 的子类中，只有三种基本的异常类提供了带 `cause` 参数的构造器，分别是 `Error` 、 `Exception` 、 `RuntimeException` 。 如果要把其他类型的异常链接起来，应该使用 `initCause()` 方法而不是构造器。















## 7. Java 标准异常

> #### `Throwable` 这个 Java 类被用来表示 任何可以作为异常被抛出的类 。`Throwable` 对象可分为两种类型（指从 Throwable 继承而得到的类型）：
>
> - #### `Error` 用来表示编译时和系统错误（除特殊情况外，一般不用你关心）；
>
> - #### `Exception` 是可以被抛出的基本类型，在 Java 类库、用户方法以及运行时故障中都可能抛出 `Exception` 型异常。

> #### 基本理念是用异常的名称代表发生的问题。异常的名称应该可以望文知意。

### (1) 特例：RuntimeException

> #### Java 的标准运行时检测避免了我们对传递给方法的每个引用都进行检查，类似这样的异常都属于 ***`运行时异常`*** ，他们被 Java 自动抛出，所以不必在异常说明中把它们列出来。

#### RuntimeException 代表的是 *编程错误* ：

- #### 无法预料的错误。比如从你控制范围之外传递进来的 null 引用。

- #### 作为程序员，应该在代码中进行检查的错误。在一个地方发生的异常，常常会在另一个地方导致错误。

> #### 如果不捕获这种类型的异常会发生什么事呢？因为编译器没有在这个问题上对异常说明进行强制检查，`RuntimeException` 类型的异常也许会穿越所有的执行路径直达 main() 方法，而不会被捕获，此时在程序退出前将调用异常的 `printStackTrace()` 方法。











## 8. 使用 finally 进行清理

> #### 当我们希望无论 try 块中的异常是否抛出，某些代码片段都可以得到执行。这通常适用于内存回收之外的情况。为了达到这个目的，可以在异常处理程序后加上 `finally` 子句。

> #### 这位解决 Java ***不允许我们回到异常抛出点*** 这一问题提供了一个思路。如果将 try 块放到循环中，就可以设置一种在程序执行前一定会遇到的异常情况。还可以加入一个 static 的计数器或别的装置，使循环在结束以前能尝试一定次数。

### (1) finally 能用来做什么？

> #### 对于没有 *垃圾回收* 和 *析构函数自动调用机制* 的语言来说， `finally` 能使程序员保证无论 try 块中发生了什么，内存总能得到释放。

> #### 当要 ***`把除内存之外的资源恢复到它们的初始状态时`*** ，就要用到 `finally` 子句。这种需要清理的资源包括：已打开文件或网络连接、在屏幕上画的图形、外部世界的某个开关。

> #### 当异常没有被当前的异常处理程序捕获的情况下，异常处理机制会在跳到更高一层的异常处理程序之前，执行 `finally` 子句：

```
class FourException extends Exception {}
public class AlwaysFinally {
    public static void main(String[] args) {
        System.out.println("Entering first try block");
        try {
            System.out.println("Entering second try block");
            try {
                throw new FourException();
            } finally {
                System.out.println("finally in 2nd try block");
            }
        } catch(FourException e) {
            System.out.println(
                    "Caught FourException in 1st try block");
        } finally {
            System.out.println("finally in 1st try block");
        }
    }
}
```







### (2) 在 `return` 中使用 `finally`

> #### 由于 `finally` 子句总是会执行，所以可以从一个方法的多个点返回，但仍能保证重要的清理工作会执行。

```
public class MultipleReturns {
    public static void f(int i) {
        System.out.println(
                "Initialization that requires cleanup");
        try {
            System.out.println("Point 1");
            if(i == 1) return;
            System.out.println("Point 2");
            if(i == 2) return;
            System.out.println("Point 3");
            if(i == 3) return;
            System.out.println("End");
            return;
        } finally {
            System.out.println("Performing cleanup");
        }
    }
    public static void main(String[] args) {
        for(int i = 1; i <= 4; i++)
            f(i);
    }
}
```







### (3) 缺憾：异常丢失

> #### Java 的异常实现具有瑕疵，用某些特殊的方式使用 `finally` 子句，就会发生异常丢失的情况：

```
class VeryImportantException extends Exception {
    @Override
    public String toString() {
        return "A very important exception!";
    }
}
class HoHumException extends Exception {
    @Override
    public String toString() {
        return "A trivial exception";
    }
}
public class LostMessage {
    void f() throws VeryImportantException {
        throw new VeryImportantException();
    }
    void dispose() throws HoHumException {
        throw new HoHumException();
    }
    public static void main(String[] args) {
        try {
            LostMessage lm = new LostMessage();
            try {
                lm.f();
            } finally {
                lm.dispose();	// 在返回上一层异常处理程序之前会执行该 finally 子句中的函数调用，而 dispose() 会产生 HoHumException 并却带之前抛出的 VeryImportantException
            }
        } catch(VeryImportantException | HoHumException e) {
            System.out.println(e);
        }
    }
}
```

> #### 相比之下，C++把“前一个异常还没处理就抛出下一个异常”的情形看成是糟糕的编程错误。所以好的做法是：将所有抛出异常的方法全部打包放到 try-catch 子句中。

```
public class ExceptionSilencer {
    public static void main(String[] args) {
        try {
            throw new RuntimeException();
        } finally {
            return;	// 另一种丢失异常的方式是从 finally 子句中返回
        }
    }
}
```











## 9. 异常限制

> #### ***`当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。`***也就是说，在继承和覆盖的过程中，某个特定方法的“异常说明的接口”反而变小了。

> #### 异常限制对构造器不起作用，也就是说构造器可以抛出任何异常，而不必理会基类构造器所抛出的异常。但 ***`派生类构造器的异常说明必须包含基类构造器的异常说明`***。同时派生类构造器不能捕获基类构造器抛出的异常。

> #### 尽管在继承过程中，编译器会对 `异常说明` 做强制要求，但异常说明本身并不属于 `方法类型`(方法名字+参数类型) 的一部分，所以 ***`不能基于异常说明来重载方法`*** 。











## 10. 构造器

> #### 有一点很重要：
>
> - #### ***`如果异常发生了，所有东西能被正确地清理吗？`***

> #### ***`构造器`*** 会把对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，***`这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。`*** 如果在构造器内抛出了异常，这些清理行为也许就不能正常工作了。

> #### 简单地使用 `finally` 并不能解决问题，因为如果构造器在其执行过程中由于异常而半途而废，那么该对象的某些部分则没有被成功创建，但这些部分却会在 `finally` 子句中被清理。

> #### 在设计异常时有这样一个问题：应该如何组织异常处理的层次结构？
>
> - #### 应该把异常全部放在同一层处理；
>
> - #### 还是先处理一部分，再向上层抛出相同的(或新的)异常；
>
> - #### 又或者是不做任何处理直接向上层抛出；

> #### 对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是 ***`使用嵌套的 try 子句`*** :

```
public class Cleanup {
    public static void main(String[] args) {
        try {
            InputFile in = new InputFile("Cleanup.java");
            try {
                String s;
                int i = 1;
                while((s = in.getLine()) != null)
                    ; // Perform line-by-line processing here...
            } catch(Exception e) {
                System.out.println("Caught Exception in main");
                e.printStackTrace(System.out);
            } finally {
                in.dispose();
            }
        } catch(Exception e) {
            System.out.println(
                    "InputFile construction failed");
        }
    }
}
```

> #### 异常处理的实现较为混乱，这也有力地论证了 ***`应该创建不会抛出异常的构造器`*** ，尽管这并不总会实现。











## 11. Try-With-Resources 用法

> #### 一种更好的方式是如果在构造函数中读取文件并在内部缓冲它，这样文件的打开、读取和关闭都发生在构造函数中。或者如果读取和存储文件不切实际，可以改为生成流。

```
import java.io.*;
import java.nio.file.*;
import java.util.stream.*;
public class InputFile2 {
    private String fname;

    public InputFile2(String fname) {
        this.fname = fname;
    }

    public Stream<String> getLines() throws IOException {	// 现在，getLines() 全权负责打开文件并创建 Stream 。
        return Files.lines(Paths.get(fname));
    }

    public static void
    main(String[] args) throws IOException {
        new InputFile2("InputFile2.java").getLines()
                .skip(15)
                .limit(1)
                .forEach(System.out::println);
    }
}
```



> #### 为了解决我们的问题 ———— 需要在特定时刻进行资源清理(在通常情况下意味着通过异常进行清理)，我们有时不得不写出复杂的代码：

```
import java.io.*;
public class MessyExceptions {
    public static void main(String[] args) {
        InputStream in = null;
        try {
            in = new FileInputStream(
                    new File("MessyExceptions.java"));
            int contents = in.read();
            // Process contents
        } catch(IOException e) {
            // Handle the error
        } finally {
            if(in != null) {
                try {
                    in.close();
                } catch(IOException e) {
                    // Handle the close() error
                }
            }
        }
    }
}
```

> #### 但是我们可以使用 `try-with-resources` 语法简化代码：

```
import java.io.*;
public class TryWithResources {
    public static void main(String[] args) {
        try(
                InputStream in = new FileInputStream(
                        new File("TryWithResources.java"))
        ) {
            int contents = in.read();
            // Process contents
        } catch(IOException e) {
            // Handle the error
        }
    }
}
```

> #### 现在 `try` 后可以跟一个带括号的定义 ———— 这里是我们创建的 `FileInputStream` 对象。括号内的部分称为 `资源规范头` 。此时 `in` 在整个 `try` 块的其余部分都是可用的。

> #### `try-with-resources` 定义子句中创建的对象(在括号内)必须实现 `java.lang.AutoCloseable` 接口，这个接口只有一个方法 ： `close()` 。在 Java 7 中引入 `AutoCloseable` 时，许多接口和类被修改以实现它。
>
> - #### 资源规范头中可以包含多个定义并通过分号进行分割，规范头中定义的每个对象都会在 `try` 语句块运行结束之后调用 `close()` 方法。
>
> - #### `try-with-resources` 里面的 `try` 语句块可以不包含 `catch` 或者 `finally` 语句而独立存在。

### (1) 揭示细节

> #### 为了研究 `try-with-resources` 的基本机制，我们将创建自己的 `AutoCloseable` 类：

```
class Reporter implements AutoCloseable {
    String name = getClass().getSimpleName();
    Reporter() {
        System.out.println("Creating " + name);
    }
    public void close() {
        System.out.println("Closing " + name);
    }
}
class First extends Reporter {}
class Second extends Reporter {}
public class AutoCloseableDetails {
    public static void main(String[] args) {
        try(
                First f = new First();
                Second s = new Second()
        ) {
        }
    }
}
/* Output:
Creating First
Creating Second
Closing Second
Closing First*/
```

> #### 退出 `try` 块会调用两个对象的 `close()` 方法，并以与创建顺序相反的顺序关闭它们。顺序很重要，因为后创建的对象可能依赖于先创建的对象。
>
> #### 假设我们在资源规范头中定义了一个不是 `AutoCloseable` 的对象，那么会出现编译时错误。

> #### 如果构造函数抛出异常怎么办？

```
class CE extends Exception {}
class SecondExcept extends Reporter {
    SecondExcept() throws CE {
        super();
        throw new CE();
    }
}
public class ConstructorException {
    public static void main(String[] args) {
        try(
                First f = new First();
                SecondExcept s = new SecondExcept();
                Second s2 = new Second()
        ) {
            System.out.println("In body");
        } catch(CE e) {
            System.out.println("Caught: " + e);
        }
    }
}
/*Output:
Creating First
Creating SecondExcept
Closing First
Caught: CE
*/
```

> #### 资源规范头实际上被 `try` 块包围。但是如果在 `try` 块主体中可能抛出异常，那么我们将再次被强制要求提供一个 `catch` 子句：

```
class Third extends Reporter {}
public class BodyException {
    public static void main(String[] args) {
        try(
                First f = new First();
                Second s2 = new Second()
        ) {
            System.out.println("In body");
            Third t = new Third();	// Thrid对象永远不会被清除，因为它不是在资源规范头中创建的，所以它没有被保护。
            new SecondExcept();
            System.out.println("End of body");
        } catch(CE e) {
            System.out.println("Caught: " + e);
        }
    }
}
/*Output:
Creating First
Creating Second
In body
Creating Third
Creating SecondExcept
Closing Second
Closing First
Caught: CE
*/
```











## 12. 异常匹配

> #### 抛出异常时，异常处理系统会按照代码的书写顺序找出 “最近” 的处理程序，而找到匹配的处理程序之后，他就认为异常将得到处理，然后就不再继续查找。
>
> #### 查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。***`派生类的对象也可以匹配其基类的处理程序`***。

```
class Annoyance extends Exception {}
class Sneeze extends Annoyance {}
public class Human {
    public static void main(String[] args) {
        // Catch the exact type:
        try {
            throw new Sneeze();
        } catch(Sneeze s) {
            System.out.println("Caught Sneeze");
        } catch(Annoyance a) {
            System.out.println("Caught Annoyance");
        }
        // Catch the base type:
        try {
            throw new Sneeze();
        } catch(Annoyance a) {
            System.out.println("Caught Annoyance");
        }
    }
}
/*Output:
Caught Sneeze
Caught Annoyance*/
```

> #### 如果把捕获基类的 `catch` 子句放在最前面，以此想把派生类的异常全给屏蔽掉。但此时编译器会发现继承类的 `catch` 子句永远得不到执行，因此它会向你报告错误。











## 13. 其他可选方式

> #### 当 “异常情况” 发生的时候，正常的执行已变得不可能或者不需要了，这时候就需要用到 ***异常处理系统*** 这个 ***`“活门”`*** 。异常代表了当前方法不能继续执行的情形。

> #### 开发异常处理系统的原因是，如果为每个方法所有可能发生的错误都进行处理的话，任务就显得过于繁重了，程序员也不愿意这么做。
>
> #### 所以 ***异常处理的一个重要原则是*** ： ***`“只有在你知道如何处理的情况下才捕获异常"`*** 。 实际上 ***异常处理的一个重要目标是*** ： ***`“把处理错误的代码同错误发生的地点相分离”`*** 。

> #### ***`“被检查的异常”`*** 使上述问题变得复杂，因为它们强制你在可能还没准备好处理错误的时候被迫加上 `catch` 子句，这就导致了 ***`蚕食则有害`*** 的问题

```
try {
    // ... to do something useful
} catch(ObligatoryException e) {} // Gulp!
```

> #### 这一节，我们来研究一下“被检查的异常”及其并发症，以及采用什么方法来解决这些问题。

### (1) 历史

> #### 异常处理起源于 `PL/1` 和 `Mesa` 之类的系统中，后来又出现在 `CLU`、`Smalltalk`、`Modula-3`、`Ada`、`Eiffel`、`C++`、`Python`、`Java` 以及后 `Java` 语言 `Ruby` 和 `C#` 中。`Java` 的设计和 `C++` 很相似，只是 `Java` 的设计者去掉了一些他们认为 `C++` 设计得不好的东西。

> #### Liskov 和 Snyder 在他们的一篇讨论该主题的独创性论文中指出，用瞬时风格报告错误的语言（如 C 中）有一个主要缺陷，那就是：
>
> > #### “....每次调用的时候都必须执行条件测试，以确定会产生何种结果。这使程序难以阅读并且有可能降低运行效率，因此程序员们既不愿意指出，也不愿意处理异常。”
>
> #### 因此，异常处理的初衷是要消除这种限制，但是我们又从 Java 的“被检查的异常”中看到了这种代码。他们继续写道：
>
> > #### “....要求程序员把异常处理程序的代码文本附接到会引发异常的调用上，这会降低程序的可读性，使得程序的正常思路被异常处理给破坏了。”

> #### 异常说明有两个目的：
>
> - #### 一个是“我的代码会产生这种异常，这由你来处理”。
>
> - #### 另一个是“我的代码忽略了这些异常，这由你来处理”。







### (2) 观点

> #### 值得注意的是 Java 有效地发明了 “被检查的异常” ，但这还只是一次尝试，目前还没有别的语言选择复制这种做法。

> #### 当小项目的程序开始膨胀变大的时候，过多的类型检查，特别是 “被检查的异常” 就会造成无法管理的问题。
>
> #### 一名 C# 的设计人员发现：
>
> > #### “仅从小程序来看，会认为异常说明能增加开发人员的效率，并提高代码的质量；但考察大项目的时候，结论就不同了-开发效率下降了，而代码质量只有微不足道的提高，甚至毫无提高”。
>
> #### 谈到未被捕获的异常的时候，CLU 的设计师们认为：
>
> > #### “我们觉得强迫程序员在不知道该采取什么措施的时候提供处理程序，是不现实的。”

#### **好的程序设计语言能帮助程序员写出好程序，但无论哪种语言都避免不了程序员用它写出坏程序。**







### (3) 把异常传递给控制台

> #### 在简单的程序中，不用写多少代码就能保留异常的最简单的方法，就是把它们从 `main()` 传递到控制台。







#### (4) 把 “被检查的异常” 转换为 “不检查的异常”

> #### 可以通过将一个 “被检查的异常” 传递给 `RuntimeException` 的构造器，从而将它包装进 `RuntimeException` 里。

```
try {
    // ... to do something useful
} catch(IDontKnowWhatToDoWithThisCheckedException e) {
    throw new RuntimeException(e);
}
```

> #### 如果想把“被检查的异常”这种功能“屏蔽”掉的话，这看上去像是一个好办法。不用“吞下”异常，也不必把它放到方法的异常说明里面，而异常链还能保证你不会丢失任何原始异常的信息。
>
> #### 这种把被检查的异常用 `RuntimeException` 包装起来的技术，将在本书余下部分使用。另一种解决方案是创建自己的 `RuntimeException` 的子类。这样的话，异常捕获将不被强制要求，但是任何人都可以在需要的时候捕获这些异常。











## 13. 异常指南

#### 应该在下列情况下使用异常：

- #### 尽可能使用 `try-with-resource`。

- #### 在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常。）

- #### 解决问题并且重新调用产生异常的方法。

- #### 进行少许修补，然后绕过异常发生的地方继续执行。

- #### 用别的数据进行计算，以代替方法预计会返回的值。

- #### 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。

- #### 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。

- #### 终止程序。

- #### 进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人。）

- #### 让类库和程序更安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资。）









## 14. 本章小结

> #### 异常处理的优点之一就是它使得你 ***`可以在某处集中精力处理你要解决的问题，而在另一处处理你编写的这段代码中产生的错误`***。
>
> #### Java 坚定地强调 ***`将所有的错误都以异常形式报告`*** 的这一事实，正是它远远超过如 C++ 这类语言的长处之一，因为在 C++ 这类语言中，需要以大量不同的方式来报告错误，或者根本就没有提供错误报告功能。















# [第十六章 代码校验](https://njuics.github.io/OnJava8/#/book/16-Validating-Your-Code?id=第十六章-代码校验)

> #### ***`你永远不能保证你的代码是正确的，你只能证明它是错的。`***

## 1. 测试

- ### 如果没有测试过，它就是不能工作的。

> #### Java是一个静态类型的语言，但静态类型检查是一种非常局限性的测试，只是说明编译器接受你代码中的语法和基本类型规则。
>
> #### 所以迈向代码校验的第一步就是创建测试，针对我们的目标检查代码的行为。

### (1) 单元测试

> #### 将集成测试构建到我们创建的所有代码中，并在每次构建系统时运行这些测试。这样，构建过程不仅能检查语法错误，同时也能检查语义错误。

> #### “单元” 是指测试一小部分代码，通常每个类都有测试来检查它所有方法的行为。 “系统”测试则是检查整个程序是否满足要求。

> #### Java 通过将单元测试集成到构建过程中，我们扩大了安全保障，因而有了更快的开发效率。当发现设计或实现缺陷时，可以更容易、更大胆地重构我们的代码。







### (2) JUnit

> #### 在 JUnit 最简单的使用中，使用 **`@Test`** 注解标记表示测试的每个方法。 JUnit 将这些方法标记为单独的测试，并一次设置和运行一个测试，采取措施避免测试之间的副作用。

```
package validating;
import java.util.*;    
public class CountedList extends ArrayList<String> {
    private static int counter = 0;
    private int id = counter++;
    public CountedList() {
        System.out.println("CountedList #" + id);
    }
    public int getId() { return id; }
}
```

> #### 标准做法是将测试放在它们自己的子目录中。测试还必须放在包中，以便 JUnit 能发现它们。:

> - #### **`@BeforeAll`** 注解是在任何其他测试操作之前运行一次的方法。
>
> - #### **`@AfterAll`** 是所有其他测试操作之后只运行一次的方法。两个方法都必须是静态的。
>
> - #### **`@BeforeEach`** 注解是通常用于创建和初始化公共对象的方法，并在每次测试前运行。
>
> - #### 如果你必须在每次测试后执行清理（如果修改了需要恢复的静态文件，打开文件需要关闭，打开数据库或者网络连接，etc），那就用注解 **`@AfterEach`**。
>
> - #### JUnit 使用 **`@Test`** 注解发现测试方法，并将每个方法作为测试运行。在方法内部，你可以执行任何所需的操作并使用 JUnit 断言方法（以"assert"开头）验证测试的正确性。如果断言失败，将显示导致失败的表达式和值。

> #### `JUnit` 还包括大量的测试结构，你可以到[官网](https://njuics.github.io/OnJava8/#/junit.org)上学习它们。 `JUnit` 是 `Java` 最流行的单元测试框架，但也有其他可替代的。







### (3) 测试覆盖率的幻觉

> #### ***`测试覆盖率`*** 同样也被称为 ***`代码覆盖率`*** ，是度量代码的测试百分比。百分比越高，测试的覆盖率越大。这里有很多 [方法](https://en.wikipedia.org/wiki/Code_coverage) 和 [Java代码覆盖工具](https://en.wikipedia.org/wiki/Java_Code_Coverage_Tools) 。

> #### 100% 的测试覆盖并不意味着是对测试有效性的良好测量。我们可以测试所有需要它的东西但只需要 65% 的覆盖率，如果需要 100% 的覆盖，我们将浪费大量时间来生产剩余的代码。











## 2. 前置条件

> #### ***`前置条件`*** 的概念来自于契约式设计(DBC)，利用断言机制实现。

### (1) 断言

> #### 断言通过 ***验证在程序执行期间满足某些条件*** ，从而增加了程序的健壮性。但是断言不能再编译时被检查，并且它们不属于单元测试的一部分。







### (2) Java 断言语法

#### 断言语句有两种形式 :

- #### assert boolean-expression；

- #### assert boolean-expression: information-expression;

```
public class Assert1 {
    public static void main(String[] args) {
        assert false;
    }
}

/* Output:
___[ Error Output ]___
Exception in thread "main" java.lang.AssertionError
at Assert1.main(Assert1.java:9)
*/
```

> #### 如果正常运行程序，没有任何特殊的断言标志则不会发生任何事情。我们需要在运行程序时显示启动断言。一种简单的方法是使用 `-ea` 表示，这将运行程序并执行任何断言语句。

```
public class Assert2 {
    public static void main(String[] args) {
    assert false:
    "Here's a message saying what happened";
    }
}
/* Output:
___[ Error Output ]___
Exception in thread "main" java.lang.AssertionError:
Here's a message saying what happened
at Assert2.main(Assert2.java:8)
*/
```

> #### 我们还可以基于类名或包名打开或关闭断言；也就是说，我们可以对整个包启用或禁用断言。
>
> #### 我们还可以通过编程的方式通过链接到类加载器对象来控制断言。类加载器中有几种方法允许动态启用和禁用断言。这消除了在运行程序时在命令行上使用 `-ea` 标志的需要。

> #### 决定在程序运行时启用断言可以使用下面的 **static** 块来实现这一点，该语句位于系统的主类中：

```
static {
    boolean assertionsEnabled = false;
    // Note intentional side effect of assignment:
    assert assertionsEnabled = true;
    if(!assertionsEnabled)
        throw new RuntimeException("Assertions disabled");
}
```







### (3) Guava 断言

> #### 因为启用 Java 本地断言很麻烦，Guava 团队添加了一个始终启用的用来代替断言的 `Verify` 类。他们建议静态导入 `Verify` 方法：

```
import com.google.common.base.*;
import static com.google.common.base.Verify.*;
public class GuavaAssertions {
    public static void main(String[] args) {
        verify(2 + 2 == 4);
        try {
            verify(1 + 2 == 4);
            } catch(VerifyException e) {
            System.out.println(e);
        }
        
        try {
            verify(1 + 2 == 4, "Bad math");
        } catch(VerifyException e) {
            System.out.println(e.getMessage());
        }
        
        try {
            verify(1 + 2 == 4, "Bad math: %s", "not 4");
        } catch(VerifyException e) {
            System.out.println(e.getMessage());
        }
        
        String s = "";
        s = verifyNotNull(s);
        s = null;
        try {
            verifyNotNull(s);
        } catch(VerifyException e) {
            System.out.println(e.getMessage());
        }
        
        try {
            verifyNotNull(
                s, "Shouldn't be null: %s", "arg s");
        } catch(VerifyException e) {
            System.out.println(e.getMessage());
        }
    }
}
/* Output:
com.google.common.base.VerifyException
Bad math
Bad math: not 4
expected a non-null reference
Shouldn't be null: arg s
*/
```

> #### 这里有两个方法，使用 **`verify()`** 和 **`verifyNotNull()`** 来支持有用的错误消息。**`verifyNotNull()`** 内置的错误消息通常就足够了，而 **`verify()`** 太一般，没有有用的默认错误消息。







### (4) 使用断言进行契约式设计

> #### ***`契约式设计`*** 通过确保对象遵循某些规则来帮助创建健壮的程序。这些规则是由正在解决的问题的性质决定的，这超出了编译器可以验证的范围。
>
> #### DBC假定服务供应者和该服务的消费者之间存在明确指定的契约。而在面向对象编程中，服务通常由对象提供，对象的边界是对象类的接口。

#### Meyer 认为：

- #### 应该明确指定行为，就好像它是一个契约一样。设计过程中一个有价值的部分是特定类DBC约束的表达式，如果无法指定约束，则可能对要构建的内容了解得不够。

- #### 通过实现某些运行时检查来保证这种行为，这些检查被称为 前置条件 、 后置条件 和 不变项 。







### (5) 检查指令

> #### Meyer 称断言为检查指令。***`检查指令`*** 说明我们确信代码中的某个特定属性此时已经得到满足。
>
> #### 检查指令是对我们的代码进行补充，当我们可以测试并阐述对象或程序的状态时，应该使用它。







### (6) 前置条件

> #### ***`前置条件`*** 确保客户端履行其部分契约。这意味着在方法调用开始时几乎总是会检查参数，以此保证它们的调用在方法中是否是合适的。







### (7) 后置条件

> #### ***`后置条件`*** 测试我们在方法中所做操作的结果。这段代码放在方法调用的末尾和 return 语句之前。
>
> #### 后置条件很重要，但是在任何 ***可以描述方法结果上的约束*** 时，最好将这些约束在代码中标识为后置条件。







### (8) 不变性

> #### ***`不变性`*** 保证了必须在方法调用之间维护的兑现的状态，但它并不会阻止方法在执行过程中暂时偏离这些保证，他只是在说 `对象的状态信息应该总是遵守状态规则` 。
>
> #### 不变性是对构造后对于对象状态的保证。







### (9) 放松DBC检查 或 非严格的DBC

> #### 由于在一个产品中包含所有DBC代码并不总是实际的，所以我们可以基于对特定位置的代码的 信任程度 放松 DBC 检查。以下是放松检查的顺序，从最安全到最不安全：
>
> - #### 不变性检查在方法 ***一开始*** 的时候是不能进行的，因为在方法结束时进行不变性检查能保证一开始对象处于有效状态。所以通常情况下我们可以相信对象的状态不会在方法调用之间发生变化。
>
> - #### 当我们进行合理的单元测试以验证方法是否返回了适当的值时，可以禁用后置条件检查。因为不变性检查是观察对象的状态，后置条件检查仅在方法期间验证计算结果，因此可能会被丢弃，以便进行单元测试。
>
> - #### 如果我们确信方法主体没有把对象改为无效状态，则可以禁用方法调用末尾的不变性检查。
>
> - #### 禁用前置条件检查，但除非这是万不得已的情况下。因为这是最不安全、最不明智的选择、







### (10) DBC + 单元测试

> #### 下面的例子将实现一个简单的 FIFO 队列，演示了将契约式设计中的概念与单元测试相结合的有效性。我们先对这个队列做一些契约定义：
>
> - #### 前置条件(用于put())：不允许将空元素添加到队列中。
>
> - #### 前置条件(用于put())：将元素放入完整队列是非法的。
>
> - #### 前置条件(用于get())：试图从空队列中获取元素是非法的。
>
> - #### 后置条件用于get())：不能从数组中生成空元素。
>
> - #### 不变性：包含对象的区域不能包含任何空元素。
>
> - #### 不变性：不包含对象的区域必须只有空值。

```
package validating;
public class CircularQueueException extends RuntimeException {
          public CircularQueueException(String why) {
          super(why);
      }
  }
  package validating;
  import java.util.*;
  public class CircularQueue {
      private Object[] data;
      private int in = 0, // Next available storage space 
      out = 0; // Next gettable object
               // Has it wrapped around the circular queue?
      private boolean wrapped = false;
      public CircularQueue(int size) {
          data = new Object[size];
          // Must be true after construction:
          assert invariant();
      }
      
      public boolean empty() {
          return !wrapped && in == out;
      }
      
      public boolean full() {
            return wrapped && in == out;
      }
      
        public boolean isWrapped() { return wrapped; }
      
      public void put(Object item) {
            precondition(item != null, "put() null item");
            precondition(!full(),
            "put() into full CircularQueue");
            assert invariant();
            data[in++] = item;
            if(in >= data.length) {
              in = 0;
              wrapped = true;
            }
            assert invariant();
        }
      
      public Object get() {
            precondition(!empty(),
            "get() from empty CircularQueue");
            assert invariant();
            Object returnVal = data[out];
            data[out] = null;
            out++;
          if(out >= data.length) {
              out = 0;
              wrapped = false;
          }
          assert postcondition(
          returnVal != null,
          "Null item in CircularQueue");
          assert invariant();
          return returnVal;
      }
      
        // Design-by-contract support methods:
      private static void precondition(boolean cond, String msg) {
          if(!cond) throw new CircularQueueException(msg);
      }
      
      private static boolean postcondition(boolean cond, String msg) {
          if(!cond) throw new CircularQueueException(msg);
            return true;
      }
      
      private boolean invariant() {
          // Guarantee that no null values are in the
          // region of 'data' that holds objects:
          for(int i = out; i != in; i = (i + 1) % data.length)
              if(data[i] == null)
                  throw new CircularQueueException("null in CircularQueue");
                  // Guarantee that only null values are outside the
                  // region of 'data' that holds objects:
          if(full()) return true;
          for(int i = in; i != out; i = (i + 1) % data.length)
               if(data[i] != null)
                   throw new CircularQueueException(
                        "non-null outside of CircularQueue range: " + dump());
          return true;
      }
      
      public String dump() {
          return "in = " + in +
              ", out = " + out +
              ", full() = " + full() +
              ", empty() = " + empty() +
              ", CircularQueue = " + Arrays.asList(data);
      }
  }
```

> #### 现在我们可以为类创建 `JUnit` 测试：

```
package validating;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
public class CircularQueueTest {
    private CircularQueue queue = new CircularQueue(10);
    private int i = 0;
    
    @BeforeEach
    public void initialize() {
        while(i < 5) // Pre-load with some data
            queue.put(Integer.toString(i++));
      }
    
    // Support methods:
    private void showFullness() {
        assertTrue(queue.full());
        assertFalse(queue.empty());
        System.out.println(queue.dump());
    }
    
    private void showEmptiness() {
        assertFalse(queue.full());
        assertTrue(queue.empty());
        System.out.println(queue.dump());
    }
    
    @Test
    public void full() {
        System.out.println("testFull");
        System.out.println(queue.dump());
        System.out.println(queue.get());
        System.out.println(queue.get());
        while(!queue.full())
            queue.put(Integer.toString(i++));
            String msg = "";
        try {
              queue.put("");
        } catch(CircularQueueException e) {
              msg = e.getMessage();
              ∂System.out.println(msg);
        }
        assertEquals(msg, "put() into full CircularQueue");
        showFullness();
    }
    
    @Test
    public void empty() {
        System.out.println("testEmpty");
        while(!queue.empty())
              System.out.println(queue.get());
              String msg = "";
        try {
            queue.get();
        } catch(CircularQueueException e) {
            msg = e.getMessage();
            System.out.println(msg);
        }
        assertEquals(msg, "get() from empty CircularQueue");
        showEmptiness();
    }
    @Test
    public void nullPut() {
        System.out.println("testNullPut");
        String msg = "";
        try {
              queue.put(null);
        } catch(CircularQueueException e) {
            msg = e.getMessage();
            System.out.println(msg);
        }
        assertEquals(msg, "put() null item");
    }
    
    @Test
    public void circularity() {
          System.out.println("testCircularity");
          while(!queue.full())
              queue.put(Integer.toString(i++));
              showFullness();
              assertTrue(queue.isWrapped());
        
        while(!queue.empty())
              System.out.println(queue.get());
              showEmptiness();
        
        while(!queue.full())
              queue.put(Integer.toString(i++));
              showFullness();
        
        while(!queue.empty())
              System.out.println(queue.get());
              showEmptiness();
     }
 }
/* Output:
testNullPut
put() null item
testCircularity
in = 0, out = 0, full() = true, empty() = false,
CircularQueue =
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
0
1
2
3
4
5
6
7
8
9
in = 0, out = 0, full() = false, empty() = true,
CircularQueue =
[null, null, null, null, null, null, null, null, null,
null]
in = 0, out = 0, full() = true, empty() = false,
CircularQueue =
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
10
11
12
13
14
15
16
17
18
19
in = 0, out = 0, full() = false, empty() = true,
CircularQueue =
[null, null, null, null, null, null, null, null, null,
null]
testFull
in = 5, out = 0, full() = false, empty() = false,
CircularQueue =
[0, 1, 2, 3, 4, null, null, null, null, null]
0
1
put() into full CircularQueue
in = 2, out = 2, full() = true, empty() = false,
CircularQueue =
[10, 11, 2, 3, 4, 5, 6, 7, 8, 9]
testEmpty
0
1
2
3
4
get() from empty CircularQueue
in = 5, out = 5, full() = false, empty() = true,
CircularQueue =
[null, null, null, null, null, null, null, null, null,
null]
*/
```







### (11) 使用 Guava 前置条件

> #### 谷歌的 Guava 库包含了一组很好的前置条件测试，这些测试不仅易于使用，而且明明也足够好。

```
import java.util.function.*;
import static com.google.common.base.Preconditions.*;
public class GuavaPreconditions {
    static void test(Consumer<String> c, String s) {
        try {
            System.out.println(s);
            c.accept(s);
            System.out.println("Success");
        } catch(Exception e) {
            String type = e.getClass().getSimpleName();
            String msg = e.getMessage();
            System.out.println(type +
            (msg == null ? "" : ": " + msg));
        }
    }
    
    public static void main(String[] args) {
        test(s -> s = checkNotNull(s), "X");
        test(s -> s = checkNotNull(s), null);
        test(s -> s = checkNotNull(s, "s was null"), null);
        test(s -> s = checkNotNull(
        s, "s was null, %s %s", "arg2", "arg3"), null);
        test(s -> checkArgument(s == "Fozzie"), "Fozzie");
        test(s -> checkArgument(s == "Fozzie"), "X");
        test(s -> checkArgument(s == "Fozzie"), null);
        test(s -> checkArgument(
        s == "Fozzie", "Bear Left!"), null);
        test(s -> checkArgument(
        s == "Fozzie", "Bear Left! %s Right!", "Frog"),
        null);
        test(s -> checkState(s.length() > 6), "Mortimer");
        test(s -> checkState(s.length() > 6), "Mort");
        test(s -> checkState(s.length() > 6), null);
        test(s ->
        checkElementIndex(6, s.length()), "Robert");
        test(s ->
        checkElementIndex(6, s.length()), "Bob");
        test(s ->
        checkElementIndex(6, s.length()), null);
        test(s ->
        checkPositionIndex(6, s.length()), "Robert");
        test(s ->
        checkPositionIndex(6, s.length()), "Bob");
        test(s ->
        checkPositionIndex(6, s.length()), null);
        test(s -> checkPositionIndexes(
        0, 6, s.length()), "Hieronymus");
        test(s -> checkPositionIndexes(
        0, 10, s.length()), "Hieronymus");
        test(s -> checkPositionIndexes(
        0, 11, s.length()), "Hieronymus");
        test(s -> checkPositionIndexes(
        -1, 6, s.length()), "Hieronymus");
        test(s -> checkPositionIndexes(
        7, 6, s.length()), "Hieronymus");
        test(s -> checkPositionIndexes(
        0, 6, s.length()), null);
    }
}
/* Output:
X
Success
null
NullPointerException
null
NullPointerException: s was null
null
NullPointerException: s was null, arg2 arg3
Fozzie
Success
X
IllegalArgumentException
null
IllegalArgumentException
null
IllegalArgumentException: Bear Left!
null
IllegalArgumentException: Bear Left! Frog Right!
Mortimer
Success
Mort
IllegalStateException
null
NullPointerException
Robert
IndexOutOfBoundsException: index (6) must be less than
size (6)
Bob
IndexOutOfBoundsException: index (6) must be less than
size (3)
null
NullPointerException
Robert
Success
Bob
IndexOutOfBoundsException: index (6) must not be
greater than size (3)
null
NullPointerException
Hieronymus
Success
Hieronymus
Success
Hieronymus
IndexOutOfBoundsException: end index (11) must not be
greater than size (10)
Hieronymus
IndexOutOfBoundsException: start index (-1) must not be
negative
Hieronymus
IndexOutOfBoundsException: end index (6) must not be    
less than start index (7)
null
NullPointerException
*/
```













## 3. 测试驱动开发

> #### 之所以可以有 ***`测试驱动开发`*** （TDD）这种开发方式，是因为如果你在设计和编写代码时考虑到了测试，那么你不仅可以写出可测试性更好的代码，而且还可以得到更好的代码设计。
>
> #### ***`测试优先的开发`*** ：纯粹的 TDD 主义者会在实现新功能之前就为其编写测试。

> #### 动态测试生成：`JUnit5` 中最复杂的新功能之一，通过它我们可以使我们所编写的代码在运行时生成测试，而不需要我们对每个测试显示编码。

```
package validating;

interface StringInverter {
    String invert(String str);
}
package validating;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.DynamicTest.*;

class DynamicStringInverterTests {
    // Combine operations to prevent code duplication:
    Stream<DynamicTest> testVersions(String id,
        Function<StringInverter, String> test) {
        List<StringInverter> versions = Arrays.asList(
            new Inverter1(), new Inverter2(),
            new Inverter3(), new Inverter4());
        return DynamicTest.stream(
            versions.iterator(),
            inverter -> inverter.getClass().getSimpleName(),
            inverter -> {
                System.out.println(
                    inverter.getClass().getSimpleName() +
                        ": " + id);
                try {
                    if(test.apply(inverter) != "fail")
                        System.out.println("Success");
                } catch(Exception | Error e) {
                    System.out.println(
                        "Exception: " + e.getMessage());
                }
            }
        );
    }
    String isEqual(String lval, String rval) {
        if(lval.equals(rval))
            return "success";
        System.out.println("FAIL: " + lval + " != " + rval);
        return "fail";
    }
    @BeforeAll
    static void startMsg() {
        System.out.println(
            ">>> Starting DynamicStringInverterTests <<<");
    }
    @AfterAll
    static void endMsg() {
        System.out.println(
            ">>> Finished DynamicStringInverterTests <<<");
    }
    @TestFactory
    Stream<DynamicTest> basicInversion1() {
        String in = "Exit, Pursued by a Bear.";
        String out = "eXIT, pURSUED BY A bEAR.";
        return testVersions(
            "Basic inversion (should succeed)",
            inverter -> isEqual(inverter.invert(in), out)
        );
    }
    @TestFactory
    Stream<DynamicTest> basicInversion2() {
        return testVersions(
            "Basic inversion (should fail)",
            inverter -> isEqual(inverter.invert("X"), "X"));
    }
    @TestFactory
    Stream<DynamicTest> disallowedCharacters() {
        String disallowed = ";-_()*&^%$#@!~`0123456789";
        return testVersions(
            "Disallowed characters",
            inverter -> {
                String result = disallowed.chars()
                    .mapToObj(c -> {
                        String cc = Character.toString((char)c);
                        try {
                            inverter.invert(cc);
                            return "";
                        } catch(RuntimeException e) {
                            return cc;
                        }
                    }).collect(Collectors.joining(""));
                if(result.length() == 0)
                    return "success";
                System.out.println("Bad characters: " + result);
                return "fail";
            }
        );
    }
    @TestFactory
    Stream<DynamicTest> allowedCharacters() {
        String lowcase = "abcdefghijklmnopqrstuvwxyz ,.";
        String upcase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ,.";
        return testVersions(
            "Allowed characters (should succeed)",
            inverter -> {
                assertEquals(inverter.invert(lowcase), upcase);
                assertEquals(inverter.invert(upcase), lowcase);
                return "success";
            }
        );
    }
    @TestFactory
    Stream<DynamicTest> lengthNoGreaterThan30() {
        String str = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        assertTrue(str.length() > 30);
        return testVersions(
            "Length must be less than 31 (throws exception)",
            inverter -> inverter.invert(str)
        );
    }
    @TestFactory
    Stream<DynamicTest> lengthLessThan31() {
        String str = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        assertTrue(str.length() < 31);
        return testVersions(
            "Length must be less than 31 (should succeed)",
            inverter -> inverter.invert(str)
        );
    }
}
package validating;
public class Inverter1 implements StringInverter {
    public String invert(String str) { return str; }
}
package validating;
import static java.lang.Character.*;
public class Inverter2 implements StringInverter {
    public String invert(String str) {
        String result = "";
        for(int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            result += isUpperCase(c) ?
                      toLowerCase(c) :
                      toUpperCase(c);
        }
        return result;
    }
}
package validating;
import static java.lang.Character.*;
public class Inverter3 implements StringInverter {
    public String invert(String str) {
        if(str.length() > 30)
            throw new RuntimeException("argument too long!");
        String result = "";
        for(int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            result += isUpperCase(c) ?
                      toLowerCase(c) :
                      toUpperCase(c);
        }
        return result;
    }
}
package validating;
import static java.lang.Character.*;
public class Inverter4 implements StringInverter {
    static final String ALLOWED =
        "abcdefghijklmnopqrstuvwxyz ,." +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    public String invert(String str) {
        if(str.length() > 30)
            throw new RuntimeException("argument too long!");
        String result = "";
        for(int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if(ALLOWED.indexOf(c) == -1)
                throw new RuntimeException(c + " Not allowed");
            result += isUpperCase(c) ?
                      toLowerCase(c) :
                      toUpperCase(c);
        }
        return result;
    }
}
```

### (1) 测试驱动 VS. 测试优先

> #### ***`“测试失败的书签”`*** ： 以失败的测试为书签能让我们找到之前停止的地方。这似乎让我们能更轻松地暂时离开我们的工作，因为不用担心找不到工作进展的位置。

> #### 纯粹的测试优先编程的主要问题是它假设你事先了解了你正在解决的问题。但通常只有处理问题一段时间之后我们对它的理解才能达到能给它编写测试的程度。











## 4. 日志

#### 日志会给出正在运行的程序的各种信息。

> #### 在调试程序中，***`日志`*** 可以是普通状态数据，用于显示程序运行过程。

> #### 采用传统的 `println` 和 `debug` 相结合的编译器移除或加入调试代码的方式，使得每次启动或关闭跟踪语句时必须重新编译代码。而通过更改配置文件来修改日志属性，从而起到 ***启用跟踪语句但不用重新编译程序会更方便*** 。

> #### *`Simple Logging Facade for Java(SLF4J)`* ,它为多个日志框架提供了一个封装好的调用方式，这些日志框架包括 **`java.util.logging`** ， **`logback`** 和 **`log4j`** 。

```
import org.slf4j.*;
public class SLF4JLogging {
    private static Logger log =
        LoggerFactory.getLogger(SLF4JLogging.class);
    public static void main(String[] args) {
        log.info("hello logging");
    }
}
/* Output:
2017-05-09T06:07:53.418
[main] INFO SLF4JLogging - hello logging
*/
```

> #### 日志输出中的格式和信息，甚至输出是否正常或“错误”都取决于 `SLF4J` 所连接的后端程序包是怎样实现的。在上面的示例中，它连接到的是 `logback` 库，并显示为标准输出。
>
> #### 如果我们修改 `build.gradle` 从而使用内置在 `JDK` 中的日志包作为后端，则输出显示为错误输出。

### (1) 日志等级

> #### `SLF4J` 提供了多个等级的日志消息。下面这个例子以“严重性”的递增顺序对它们作出演示：

```
import org.slf4j.*;
public class SLF4JLevels {
    private static Logger log =
        LoggerFactory.getLogger(SLF4JLevels.class);
    public static void main(String[] args) {
        log.trace("Hello");
        log.debug("Logging");
        log.info("Using");
        log.warn("the SLF4J");
        log.error("Facade");
    }
}
/* Output:
2017-05-09T06:07:52.846
[main] TRACE SLF4JLevels - Hello
2017-05-09T06:07:52.849
[main] DEBUG SLF4JLevels - Logging
2017-05-09T06:07:52.849
[main] INFO SLF4JLevels - Using
2017-05-09T06:07:52.850
[main] WARN SLF4JLevels - the SLF4J
2017-05-09T06:07:52.851
[main] ERROR SLF4JLevels - Facade
*/
```

> #### 可以按等级来查找消息。 **`级别通常设置在单独的配置文件中`** ，因此可以重新配置而无需重新编译。 配置文件格式取决于你使用的后端日志包实现。例如 `logback` 使用 `XML` 文件格式来编写配置文件：

```
<!-- validating/logback.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="STDOUT"
        class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
%d{yyyy-MM-dd'T'HH:mm:ss.SSS}
[%thread] %-5level %logger - %msg%n
            </pattern>
        </encoder>
    </appender>
    <root level="TRACE">
        <appender-ref ref="STDOUT" />
    </root>
</configuration>
```

> #### 我们可以尝试将 `<root level="TRACE">` 行更改为其他级别。

> #### 以上只是 `SFL4J` 最简单的介绍和使用基础，可以查阅 [SLF4J 文档](http://www.slf4j.org/manual.html)来获得更深入的信息。











## 5. 调试

> #### 使用 `System.out` 和 `日志信息` 对于困难问题来说就显得过于笨拙，所以我们需要依靠调试器来更加深入的理解程序。

### (1) 使用 `JDB` 调试

> #### ***`Java 调试器(JDB)`*** 是 `JDK` 内置的命令行工具。从调试指令和命令行接口来看， `JDB` 至少从概念上是 `GNU 调试器(GDB)` 的继承者

```
public class SimpleDebugging {
    private static void foo1() {
        System.out.println("In foo1");
        foo2();
    }
    
    private static void foo2() {
        System.out.println("In foo2");
        foo3();
    }
    
    private static void foo3() {
        System.out.println("In foo3");
        int j = 1;
        j--;
        int i = 5 / j;
    }
    
    public static void main(String[] args) {
        foo1();
    }
}
/* Output
In foo1
In foo2
In foo3
__[Error Output]__
Exception in thread "main"
java.lang.ArithmeticException: /by zero 
at 
SimpleDebugging.foo3(SimpleDebugging.java:17)
at 
SimpleDebugging.foo2(SimpleDebugging.java:11)
at
SimpleDebugging.foo1(SimpleDebugging.java:7)
at
SimpleDebugging.main(SimpleDebugging.java:20)
```

> #### 为了运行 `JDB` ，我们需要在编译 **SimpleDebugging.java** 时加上 **`-g`** 标记，从而告诉编译器生成编译信息。然后使用 `jdb SimpleDebugging` 的命令开始调试程序。
>
> - #### 可以输入 `?` 查看可用的 `JDB` 命令
>
> - #### 命令 **`catch Exception`** 在任何抛出异常的地方设置断点（然而，即使你不显式地设置断点，调试器也会停止 ——— JDB 中好像是默认在异常抛出处设置了异常）。
>
> - #### 命令 **list** 将导致程序终止的执行点列出来
>
> - #### 命令 **locals** 能转储所有的局部变量值
>
> - #### 命令 **wherei** 打印进入当前线程的方法栈中的栈帧信息
>
> - #### 命令 **help** 将会告诉你更多关于 **jdb** 的用法







### (2) 图形化调试器

> #### 使用类似 `JDB` 的命令行调试器是不方便的。它需要显示的命令去 `查看变量状态` 、 `列出执行点` 、 `查找线程` 、 `设置断点` 等等。而使用 `图形化调试器` 只需要点击几下。











## 6. 基准测试

> #### 通常一个简单直接的编码方法就足够好了，如果进行了不必要的优化，就会使的代码变得无谓的复杂和难以理解。

> #### ***`基准测试`*** 意味着对代码或算法片段进行计时看哪个跑得更快，与下一节的分析和优化截然相反， ***`分析优化`*** 是观察整个程序，找到程序中最耗时的部分。
>
> #### 在 Java 这种拥有复杂的运行时系统的编程语言中，基准测试变得更有挑战性。为了生成可靠的数据，环境设置必须控制诸如 CPU 频率、节能特性、其他运行在相同机器上的进程、优化器选项等等。

### (1) 微基准测试

> #### 写一个计时工具类从而比较不同代码块的执行速度是具有吸引力的。看上去这会产生一些有用的数据。

```
package onjava;
import static java.util.concurrent.TimeUnit.*;

public class Timer {
    private long start = System.nanoTime();
    
    public long duration() {
        return NANOSECONDS.toMillis(System.nanoTime() - start);
    }
    
    public static long duration(Runnable test) {
        Timer timer = new Timer();
        test.run();
        return timer.duration();
    }
}
```

> #### 但会有很多因素影响我们的结果，即使是生成提示符也会造成计时的混乱。这只考虑了微基准测试的问题。 Java 虚拟机 `Hotspot` 也非常影响性能，如果我们在测试前没有通过代码给 `JVM` 预热，那么你就会得到 “冷” 的结果，不能反映出代码在 JVM 预热之后的运行速度。
>
> #### 优化器有时可以检测出我们创建了未使用的东西，或是部分代码的运行结果对程序没有影响。如果它优化掉我们的测试，那么我们可能会得到不好的结果。







### (2) JMH 的引入

> #### 截止目前为止，唯一能产生像样结果的 ***Java 微基准测试系统*** 就是 `Java Microbenchmarking Harness (JMH)`。

> #### 考虑其他的因素：
>
> - #### C：客户端执行操作的线程数量
>
> - #### P：并行算法使用的并行数量
>
> - #### N：数组的大小：**10^(2\*k)**，通常来说，**k=1..7** 足够来练习不同的缓存占用。
>
> - #### Q：setter 的操作成本
>
> #### 这个 C/P/N/Q 模型在早期 JDK 8 的 Lambda 开发期间浮出水面，大多数并行的 Stream 操作(**parallelSetAll()** 也基本相似)都满足这些结论：**N\*Q**(主要工作量)对于并发性能尤为重要。并行算法在工作量较少时可能实际运行得更慢。

> #### 大多数时候，JMH 的简单应用会产生好的结果（正如你将在本书后面例子中所见），但是你不能一直假定 JMH 会产生好的结果。 JMH 网站上的范例可以帮助你开始。











## 7. 剖析和优化

> #### 有时你必须检测程序运行时间花在哪儿，从而看是否可以 ***`优化`*** 那一块的性能。 ***`剖析器`*** 可以找到这些导致程序慢的地方，因而你可以找到最轻松，最明显的方式加快程序运行速度。

> - #### 剖析器可以收集信息从而显示程序哪一部分消耗内存，哪个方法最耗时。
>
> - #### 剖析器可以帮助检测程序中的线程死锁。注意剖析和基准测试的区别：`剖析` 关注的是已经运行在真实数据上的整个程序，而 `基准测试` 关注的是程序中隔离的片段，通常是去优化算法。
>
> - #### 安装 `JDK` 时会顺带安装一个虚拟的剖析器，叫做 **`VisualVM`** 。它会被自动安装在与 **`javac`** 相同的目录下，启动它的控制台命令是 `jvisualvm` 。







### (1) 优化准则

- #### 避免为了性能牺牲代码的可读性。

- #### 不要独立地看待性能。衡量与带来的收益相比所需投入的工作量。

- #### 程序的大小很重要。性能优化通常只对运行了长时间的大型项目有价值。性能通常不是小项目的关注点。

- #### 运行起来程序比一心钻研它的性能具有更高的优先级。一旦你已经有了可工作的程序，如有必要的话，你可以使用剖析器提高它的效率。只有当性能是关键因素时，才需要在设计/开发阶段考虑性能。

- #### 不要猜测瓶颈发生在哪。运行剖析器，让剖析器告诉你。

- #### 无论何时有可能的话，显式地设置实例为 null 表明你不再用它。这对垃圾收集器来说是个有用的暗示。

- #### **static final** 修饰的变量会被 JVM 优化从而提高程序的运行速度。因而程序中的常量应该声明 **static final**。











## 8. 风格检测

> #### 存在可以指出我们代码中不符合风格准则的工具。一个流行的风格检测器是 **`Checkstyle`** 。











## 9. 静态错误分析

> #### 存在其他的分析工具可以发现躲避 `javac` 检测的更加复杂的 bug 。一个这样的工具叫做 `Findbugs` 。











## 10. 代码重审

> #### ***`代码重审`*** 是一个或一群人的一段代码被另一个或一群人阅读和评估的众多方式之一。它的目标是找到程序中的错误，代码重审是最成功的能做到这点的途径之一。
>
> #### ***`代码重审`*** 可以作为 ***`结对编程`*** 的一部分，作为 ***`代码签入`*** 过程的一部分（另一个程序员自动安排上审查新代码的任务）或使用 ***`群组预排`*** 的方式，即每个人阅读代码并讨论之。











## 11. 结对编程

> #### ***`结对编程`*** 是指两个程序员一起编程的实践活动。通常来说，一个人“驱动”（敲击键盘，输入代码），另一人（观察者或指引者）重审和分析代码，同时也要思考策略。这产生了一种实时的代码重审。通常程序员会定期地互换角色。











## 12. 重构

> #### ***`技术负债`*** 是指迭代发展的软件中为了应急而生的丑陋解决方案从而导致设计难以理解，代码难以阅读的部分。

> #### ***`重构`*** 可以矫正技术负债。重构的关键是它能改善代码设计、结构和可读性，但是它不能改变代码的行为。

### (1) 重构基石

> #### 在开始重构代码之前，你需要有以下三个系统的支撑：
>
> - #### 测试系统，因此你能确保重构不会改变代码的行为。
>
> - #### 自动构建系统，因而你能轻松地构建代码，运行所有的测试。通过这种方式做些小修改并确保修改不会破坏任何事物是毫不费力的。
>
> - #### 版本控制系统，以便你能回退到可工作的代码版本，能够一直记录重构的每一步。例如可以使用 git 版本控制系统。







## 13. 持续集成

> #### 从 `瀑布流模型` 到 `持续集成模型` 。
>
> #### 当前 CI 技术的高峰是 `持续集成服务器` 。这是一台独立的机器或虚拟机，通常是由第三方公司托管的完全独立的服务。这些公司通常免费提供基本服务，如果你需要额外的特性如更多的处理器或内存或者专门的工具或系统，你需要付费。











## 14. 本章小结

> #### 代码校验不是单一的过程或技术。每种方法只能发现特定类型的 bug，作为程序员的你在开发过程中会明白每个额外的技术都能增加代码的可靠性和鲁棒性。
>
> #### 现代化开发意味着比仅仅编写代码更多的内容，每种你在开发过程中融入的测试技术—— 包括而且尤其是你创建的能适应特定应用的自定义工具——都会带来更好、更快和更加愉悦的开发过程，同时也能为客户提供更高的价值和满意度体验。















# [第十七章 文件](https://njuics.github.io/OnJava8/#/book/17-Files?id=第十七章-文件)

> #### `Java7` 对文件使用引入了巨大的改进，这些新元素被放在 **`java.nio.file`** 包下面，这里的 `nio` 应该当成是 **`non-blocking`** 非阻塞 **`io`** 。

## 1. 文件和目录路径

> #### 一个 `Path` 对象表示一个文件或者目录的路径，是一个跨操作系统和文件系统的抽象，目的是在构造路径时不必关注底层操作系统，代码可以在不进行修改的情况下运行在不同的操作系统上。

> #### **`java.nio.file.Paths`** 类包含一个重载方法 **`static get()`** ，该方法接受一系列 ***String** 字符串* 或一个*统一资源标识符*(URI)作为参数，并且进行转换返回一个 **Path** 对象

```
import java.nio.file.*;
import java.net.URI;
import java.io.File;
import java.io.IOException;

public class PathInfo {
    static void show(String id, Object p) {
        System.out.println(id + ": " + p);
    }

    static void info(Path p) {
        show("toString", p);	// 完整形式的路径
        show("Exists", Files.exists(p));	// 测试一个文件是否存在
        show("RegularFile", Files.isRegularFile(p)); // 测试是否是一个"普通"文件
        show("Directory", Files.isDirectory(p)); // 测试是否是一个目录
        show("Absolute", p.isAbsolute());
        show("FileName", p.getFileName()); 	// 返回当前文件名
        show("Parent", p.getParent());
        show("Root", p.getRoot());
        System.out.println("******************");
    }
    public static void main(String[] args) {
        System.out.println(System.getProperty("os.name"));
        info(Paths.get("C:", "path", "to", "nowhere", "NoFile.txt"));
        Path p = Paths.get("PathInfo.java");
        info(p);
        Path ap = p.toAbsolutePath();
        info(ap);
        info(ap.getParent());
        try {
            info(p.toRealPath());
        } catch(IOException e) {
           System.out.println(e);
        }
        URI u = p.toUri();
        System.out.println("URI: " + u);
        Path puri = Paths.get(u);
        System.out.println(Files.exists(puri));
        File f = ap.toFile(); // Don't be fooled
    }
}
```

> #### 调用 **`toFile()`** 方法会生成一个 **`File`** 对象。听起来似乎可以得到一个类似文件的东西，但是这个方法的存在仅仅是为了向后兼容。然看上去应该被称为"路径"，实际上却应该表示目录或者文件本身。这是个非常草率并且令人困惑的命名，但是由于 **`java.nio.file`** 的存在我们可以安全地忽略它的存在。

### (1) 选取路径部分片段

> #### **`Path`** 对象可以非常容易地生成路径的某一部分：

```
import java.nio.file.*;

public class PartsOfPaths {
    public static void main(String[] args) {
        System.out.println(System.getProperty("os.name"));
        Path p = Paths.get("PartsOfPaths.java").toAbsolutePath();
        for(int i = 0; i < p.getNameCount(); i++)
            System.out.println(p.getName(i));	// 通过 getName() 来索引 Path 的各个部分
        System.out.println("ends with '.java': " + p.endsWith(".java"));	// endsWith() 比较的是整个路径部分，而不会包含文件路径的后缀。
        for(Path pp : p) {
            System.out.print(pp + ": ");
            System.out.print(p.startsWith(pp) + " : ");
            System.out.println(p.endsWith(pp));
        }
        System.out.println("Starts with " + p.getRoot() + " " + p.startsWith(p.getRoot()));
    }
}
```







### (2) 路径分析

> #### **`Files`** 工具类包含一系列完整的方法用于获得 **`Path`** 相关的信息。

```
import java.nio.file.*;
import java.io.IOException;

public class PathAnalysis {
    static void say(String id, Object result) {
        System.out.print(id + ": ");
        System.out.println(result);
    }
    
    public static void main(String[] args) throws IOException {
        System.out.println(System.getProperty("os.name"));
        Path p = Paths.get("PathAnalysis.java").toAbsolutePath();
        say("Exists", Files.exists(p));
        say("Directory", Files.isDirectory(p));
        say("Executable", Files.isExecutable(p));
        say("Readable", Files.isReadable(p));
        say("RegularFile", Files.isRegularFile(p));
        say("Writable", Files.isWritable(p));
        say("notExists", Files.notExists(p));
        say("Hidden", Files.isHidden(p));
        say("size", Files.size(p));
        say("FileStore", Files.getFileStore(p));
        say("LastModified: ", Files.getLastModifiedTime(p));
        say("Owner", Files.getOwner(p));
        say("ContentType", Files.probeContentType(p));
        say("SymbolicLink", Files.isSymbolicLink(p));
        if(Files.isSymbolicLink(p))
            say("SymbolicLink", Files.readSymbolicLink(p));
        if(FileSystems.getDefault().supportedFileAttributeViews().contains("posix"))
            say("PosixFilePermissions",
        Files.getPosixFilePermissions(p));
    }
}
```

> #### 在调用最后一个测试方法 **`getPosixFilePermissions()`** 之前我们需要确认一下当前文件系统是否支持 **`Posix`** 接口，否则会抛出运行时异常。







### (3) Paths 的增减修改

> #### 我们可以通过对 **`Path`** 对象增加或者删除一部分来构造一个新的 **`Path`** 对象。使用 **`relativize()`** 移除 **`Path`** 的 根路径 ，使用 **`resolve()`** 添加 **`Path`** 的 尾路径 。

```
import java.nio.file.*;
import java.io.IOException;

public class AddAndSubtractPaths {
    static Path base = Paths.get("..", "..", "..").toAbsolutePath().normalize();
    
    static void show(int id, Path result) {
        if(result.isAbsolute())
            System.out.println("(" + id + ")r " + base.relativize(result));
        else
            System.out.println("(" + id + ") " + result);
        try {
            System.out.println("RealPath: " + result.toRealPath());
        } catch(IOException e) {
            System.out.println(e);
        }
    }
    
    public static void main(String[] args) {
        System.out.println(System.getProperty("os.name"));
        System.out.println(base);
        Path p = Paths.get("AddAndSubtractPaths.java").toAbsolutePath();
        show(1, p);
        Path convoluted = p.getParent().getParent()
        .resolve("strings").resolve("..")
        .resolve(p.getParent().getFileName());
        show(2, convoluted);
        show(3, convoluted.normalize());
        Path p2 = Paths.get("..", "..");
        show(4, p2);
        show(5, p2.normalize());
        show(6, p2.toAbsolutePath().normalize());
        Path p3 = Paths.get(".").toAbsolutePath();
        Path p4 = p3.resolve(p2);
        show(7, p4);
        show(8, p4.normalize());
        Path p5 = Paths.get("").toAbsolutePath();
        show(9, p5);
        show(10, p5.resolveSibling("strings"));
        show(11, Paths.get("nonexistent"));
    }
}
```











## 2. 目录

> #### **`Files`** 工具类包含大部分我们需要的目录操作和文件操作方法。









## 3. 文件系统

> #### 我们需要一种方法查找文件系统相关的其他信息。在这里，我们使用静态的 **`FileSystems`** 工具类获取"默认"的文件系统，但你同样也可以在 **`Path`** 对象上调用 **`getFileSystem()`** 以获取创建该 **`Path`** 的文件系统。我们可以获得给定 *URI* 的文件系统，还可以构建新的文件系统

```
import java.nio.file.*;

public class FileSystemDemo {
    static void show(String id, Object o) {
        System.out.println(id + ": " + o);
    }
    
    public static void main(String[] args) {
        System.out.println(System.getProperty("os.name"));
        FileSystem fsys = FileSystems.getDefault();
        for(FileStore fs : fsys.getFileStores())
            show("File Store", fs);
        for(Path rd : fsys.getRootDirectories())
            show("Root Directory", rd);
        show("Separator", fsys.getSeparator());
        show("UserPrincipalLookupService",
            fsys.getUserPrincipalLookupService());
        show("isOpen", fsys.isOpen());
        show("isReadOnly", fsys.isReadOnly());
        show("FileSystemProvider", fsys.provider());
        show("File Attribute Views",
        fsys.supportedFileAttributeViews());
    }
}
```











## 4. 路径监听

> #### 通过 **`WatchService`** 可以设置一个进程对目录中的更改做出响应。
>
> #### 你可能认为，如果说"监视这个目录"，自然会包含整个目录和下面子目录，但实际上：只会监视给定的目录，而不是下面的所有内容。如果需要监视整个树目录，必须在整个树的每个子目录上放置一个 **`Watchservice`**。











## 5. 文件查找

> #### `java.nio.file` 有更好的文件查找问题的解决方案：通过在 `FileSystem` 对象上调用 `getPathMatcher()` 获得一个 `PathMatcher`，然后传入您感兴趣的模式。模式有两个选项：`glob` 和 `regex`。
>
> - #### `glob` 比较简单，实际上功能非常强大，因此您可以使用 `glob` 解决许多问题。
>
> - #### 如果您的问题更复杂，可以使用 `regex` 。
>
> - #### 这将在接下来的 `Strings` 一章中解释。

> #### 在这里，我们使用 `glob` 查找以 `.tmp` 或 `.txt` 结尾的所有 `Path`：

```
import java.nio.file.*;

public class Find {
    public static void main(String[] args) throws Exception {
        Path test = Paths.get("test");
        Directories.refreshTestDir();
        Directories.populateTestDir();
        // Creating a *directory*, not a file:
        Files.createDirectory(test.resolve("dir.tmp"));

        PathMatcher matcher = FileSystems.getDefault()
          .getPathMatcher("glob:**/*.{tmp,txt}"); // 开头的 **/ 表示“当前目录及所有子目录”，这在当你不仅仅要匹配当前目录下特定结尾的 Path 时非常有用。单 * 表示“任何东西”，然后是一个点，然后大括号表示一系列的可能性
        Files.walk(test)
          .filter(matcher::matches)
          .forEach(System.out::println);
        System.out.println("***************");

        PathMatcher matcher2 = FileSystems.getDefault()
          .getPathMatcher("glob:*.tmp");
        Files.walk(test)
          .map(Path::getFileName)	// 添加 map() 操作会将完整路径减少到末尾的名称
          .filter(matcher2::matches)
          .forEach(System.out::println);
        System.out.println("***************");

        Files.walk(test) // Only look for files
          .filter(Files::isRegularFile)
          .map(Path::getFileName)
          .filter(matcher2::matches)
          .forEach(System.out::println);
    }
}
```











## 6. 文件读写

> #### 如果一个文件很“小”，也就是说“它运行得足够快且占用内存小”，那么 `java.nio.file.Files` 类中的实用程序将帮助你轻松读写 *文本* 和 *二进制文件* 。
>
> - #### `Files.readAllLines()` ： 一次读取整个文件（因此“小”文件很有必要），产生一个`List<String>`。

```
import java.util.*;
import java.nio.file.*;

public class ListOfLines {
    public static void main(String[] args) throws Exception {
        Files.readAllLines(
        Paths.get("../streams/Cheese.dat"))
        .stream()
        .filter(line -> !line.startsWith("//"))	// 跳过注释行
        .map(line ->
            line.substring(0, line.length()/2))	// 每行内容只打印一半
        .forEach(System.out::println);
    }
}
```

> - #### `Files.write()` 被重载以写入 `byte` 数组或任何 `Iterable` 对象（它也有 `Charset` 选项）：

```
import java.util.*;
import java.nio.file.*;

public class Writing {
    static Random rand = new Random(47);
    static final int SIZE = 1000;
    
    public static void main(String[] args) throws Exception {
        // Write bytes to a file:
        byte[] bytes = new byte[SIZE];
        rand.nextBytes(bytes);	// 产生随机数组
        Files.write(Paths.get("bytes.dat"), bytes);
        System.out.println("bytes.dat: " + Files.size(Paths.get("bytes.dat")));

        // Write an iterable to a file:
        List<String> lines = Files.readAllLines(
          Paths.get("../streams/Cheese.dat"));
        Files.write(Paths.get("Cheese.txt"), lines);
        System.out.println("Cheese.txt: " + Files.size(Paths.get("Cheese.txt")));
    }
}
```

> #### `Files.lines()` 方便地将文件转换为行的 `Stream`：

```
import java.nio.file.*;

public class ReadLineStream {
    public static void main(String[] args) throws Exception {
        Files.lines(Paths.get("PathInfo.java"))	// PathInfo.java 文件被转换为行的 Stream
          .skip(13) // 跳过13行
          .findFirst()	// 选择下一行
          .ifPresent(System.out::println);	// 如果存在则打印
    }
}
```

> #### 如何在 `Stream` 中读取、处理或写入：

```
import java.io.*;
import java.nio.file.*;
import java.util.stream.*;

public class StreamInAndOut {
    public static void main(String[] args) {
        try(
          Stream<String> input = Files.lines(Paths.get("StreamInAndOut.java"));
          PrintWriter output = new PrintWriter("StreamInAndOut.txt")
        ) {
            input.map(String::toUpperCase)
              	 .forEachOrdered(output::println);
        } catch(Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```











## 7. 本章小结

> #### 虽然本章对文件和目录操作做了相当全面的介绍，但是仍然有没被介绍的类库中的功能——一定要研究 `java.nio.file` 的 `Javadocs`，尤其是 `java.nio.file.Files` 这个类。















# [第十八章 字符串](https://njuics.github.io/OnJava8/#/book/18-Strings?id=第十八章-字符串)

## 1. 字符串的不可变

> #### `String` 对象是不可变的。查看 JDK 文档你就会发现，`String` 类中每一个看起来会修改 `String` 值的方法，实际上都是创建了一个全新的 `String` 对象，以包含修改后的字符串内容。而最初的 `String` 对象则丝毫未动。

```
public class Immutable { 
    public static String upcase(String s) { 
        return s.toUpperCase(); 
    } 
    public static void main(String[] args) { 
        String q = "howdy";
        System.out.println(q); // howdy 
        String qq = upcase(q); 
        System.out.println(qq); // HOWDY 
        System.out.println(q); // howdy 
    } 
} 
```











## 2. + 的重载与 StringBuilder

> #### `String` 对象是不可变的，你可以给一个 `String` 对象添加任意多的别名。因为 `String` 是只读的，所以指向它的任何引用都不可能修改它的值，因此，也就不会影响到其他引用。

```
// strings/WhitherStringBuilder.java

public class WhitherStringBuilder { 
    public String implicit(String[] fields) { // 每进行一次循环，会创建一个新的 StringBuilder 对象。
        String result = ""; 
        for(String field : fields) { 
            result += field;
        }
        return result; 
    }
    public String explicit(String[] fields) { // 只生成一个StringBuilder 对象
        StringBuilder result = new StringBuilder(); 
        for(String field : fields) { 
            result.append(field); 
        } 
        return result.toString(); 
    }
}
```

> #### 显式地创建 `StringBuilder` 还允许你预先为其指定大小。如果你已经知道最终字符串的大概长度，那预先指定 `StringBuilder` 的大小可以避免频繁地重新分配缓冲。
>
> - #### 因此，当你为一个类编写 `toString()` 方法时，如果字符串操作比较简单，那就可以信赖编译器，它会为你合理地构造最终的字符串结果。
>
> - #### 但是，如果你要在 `toString()` 方法中使用循环，且可能有性能问题，那么最好自己创建一个 `StringBuilder` 对象，用它来构建最终结果。

> #### `StringBuilder`提供了丰富而全面的方法，包括 `insert()`、`replace()`、`substring()`、`reverse()`、`append()`、`toString()`、`delete()`。











## 3. 意外递归

```
import java.util.*;
import java.util.stream.*; 
import generics.coffee.*;
public class ArrayListDisplay { 
    public static void main(String[] args) {
        List<Coffee> coffees = 
            Stream.generate(new CoffeeSupplier())
                .limit(10)
                .collect(Collectors.toList()); 
        System.out.println(coffees); 
    } 
}
```

> #### 如果你希望 `toString()` 打印出类的内存地址，也许你会考虑使用 `this` 关键字：

```
import java.util.*;
import java.util.stream.*;

public class InfiniteRecursion { 
    @Override 
    public String toString() { 
        return " InfiniteRecursion address: " + this + "\n";
    } 
    public static void main(String[] args) { 
        Stream.generate(InfiniteRecursion::new) 
            .limit(10) 
            .forEach(System.out::println); 
    } 
} 
```

> #### 上述代码第七行发生了自动类型转换，由 `InfiniteRecursion` 类型转换为 `String` 类型。而编译器会调用 `this` 上的 `toString()` 方法实现该转换，于是发生了递归调用。
>
> #### 所以如果真想要打印对象内存地址，应该调用 `Object.toString()` 方法，这才是负责此任务的方法。所以不要使用 `this` 而是调用 `super.toString()` 方法。











## 4. 字符串操作

|                  方法                  |                        参数，重载版本                        |                             作用                             |
| :------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|                构造方法                | 默认版本，`String`，`StringBuilder`，`StringBuffer`，`char`数组，`byte`数组 |                       创建`String`对象                       |
|               `length()`               |                                                              |                     `String`中字符的个数                     |
|               `charAt()`               |                          `int`索引                           |               获取`String`中索引位置上的`char`               |
|       `getChars()`，`getBytes()`       | 待复制部分的开始和结束索引，复制的目标数组，目标数组的开始索引 |              复制`char`或`byte`到一个目标数组中              |
|            `toCharArray()`             |                                                              |          生成一个`char[]`，包含`String`中的所有字符          |
|    `equals()`，`equalsIgnoreCase()`    |                    与之进行比较的`String`                    |    比较两个`String`的内容是否相同。如果相同，结果为`true`    |
| `compareTo()`，`compareToIgnoreCase()` |                    与之进行比较的`String`                    | 按词典顺序比较`String`的内容，比较结果为负数、零或正数。注意，大小写不等价 |
|              `contains()`              |                    要搜索的`CharSequence`                    |        如果该`String`对象包含参数的内容，则返回`true`        |
|           `contentEquals()`            |         与之进行比较的`CharSequence`或`StringBuffer`         |     如果该`String`对象与参数的内容完全一致，则返回`true`     |
|              `isEmpty()`               |                                                              |      返回`boolean`结果，以表明`String`对象的长度是否为0      |
|           `regionMatches()`            | 该`String`的索引偏移量，另一个`String`及其索引偏移量，要比较的长度。重载版本增加了“忽略大小写”功能 |         返回`boolean`结果，以表明所比较区域是否相等          |
|             `startsWith()`             |       可能的起始`String`。重载版本在参数中增加了偏移量       |    返回`boolean`结果，以表明该`String`是否以传入参数开始     |
|              `endsWith()`              |                 该`String`可能的后缀`String`                 |     返回`boolean`结果，以表明此参数是否是该字符串的后缀      |
|      `indexOf()`，`lastIndexOf()`      | 重载版本包括：`char`，`char`与起始索引，`String`，`String`与起始索引 | 如果该`String`并不包含此参数，就返回-1；否则返回此参数在`String`中的起始索引。`lastIndexOf`()是从后往前搜索 |
|              `matches()`               |                        一个正则表达式                        | 返回`boolean`结果，以表明该`String`和给出的正则表达式是否匹配 |
|               `split()`                |         一个正则表达式。可选参数为需要拆分的最大数量         |         按照正则表达式拆分`String`，返回一个结果数组         |
|        `join()`（Java8引入的）         | 分隔符，待拼字符序列。用分隔符将字符序列拼接成一个新的`String` |          用分隔符拼接字符片段，产生一个新的`String`          |
|   `substring()`（即`subSequence()`）   |            重载版本：起始索引；起始索引+终止索引             |        返回一个新的`String`对象，以包含参数指定的子串        |
|               `concat()`               |                       要连接的`String`                       | 返回一个新的`String`对象，内容为原始`String`连接上参数`String` |
|              `replace()`               | 要替换的字符，用来进行替换的新字符。也可以用一个`CharSequence`替换另一个`CharSequence` | 返回替换字符后的新`String`对象。如果没有替换发生，则返回原始的`String`对象 |
|            `replaceFirst()`            |          要替换的正则表达式，用来进行替换的`String`          |            返回替换首个目标字符串后的`String`对象            |
|             `replaceAll()`             |          要替换的正则表达式，用来进行替换的`String`          |            返回替换所有目标字符串后的`String`对象            |
|    `toLowerCase()`，`toUpperCase()`    |                                                              | 将字符的大小写改变后，返回一个新的`String`对象。如果没有任何改变，则返回原始的`String`对象 |
|                `trim()`                |                                                              | 将`String`两端的空白符删除后，返回一个新的`String`对象。如果没有任何改变，则返回原始的`String`对象 |
|        `valueOf()`（`static`）         | 重载版本：`Object`；`char[]`；`char[]`，偏移量，与字符个数；`boolean`；`char`；`int`；`long`；`float`；`double` |                返回一个表示参数内容的`String`                |
|               `intern()`               |                                                              |     为每个唯一的字符序列生成一个且仅生成一个`String`引用     |
|               `format()`               |         要格式化的字符串，要替换到格式化字符串的参数         |                    返回格式化结果`String`                    |











## 5. 格式化输出

> #### `Java SE5` 终于推出了C语言中 `printf()` 风格的格式化输出这一功能。这不仅使得控制输出的代码更加简单，同时也给与Java开发者对于输出格式与排列更强大的控制能力。

### (1) `printf()`

> #### 格式化字符串中的占位符被称作 `格式修饰符` ，它们不仅指明了插入数据的位置，同时还指明了将会插入什么类型的变量，以及如何格式化。







### (2) `System.out.format()`

> #### `Java SE5` 引入了 `format()` 方法，可用于`PrintStream` 或者 `PrintWriter` 对象，其中也包括 `System.out` 对象。
>
> #### `format()` 方法模仿了 C 语言的 `printf()`。如果你比较怀旧的话，也可以使用 `printf()`。
>
> #### `String` 类也有一个 `static format()` 方法，可以格式化字符串。

```
public class SimpleFormat {   
    public static void main(String[] args) {     
        int x = 5;     
        double y = 5.332542;     
        // The old way: 
        System.out.println("Row 1: [" + x + " " + y + "]"); 
        // The new way:     
        System.out.format("Row 1: [%d %f]%n", x, y);     
        // or     
        System.out.printf("Row 1: [%d %f]%n", x, y);   
    } 
} 
```







### (3) `Formatter` 类

> #### `Java` 中所有的格式化功能都是由 `java.util.Formatter` 类处理的。可以将 `Formatter` 看作一个翻译器，它将你的格式化字符串与数据翻译成需要的结果

```
import java.io.*;
import java.util.*;

public class Turtle {   
    private String name;   
    private Formatter f;  
    public Turtle(String name, Formatter f) {
        this.name = name;     
        this.f = f;   
    }   
    public void move(int x, int y) {     
        f.format("%s The Turtle is at (%d,%d)%n",       
            name, x, y);   
    }
    public static void main(String[] args) {    
        PrintStream outAlias = System.out;     
        Turtle tommy = new Turtle("Tommy", new Formatter(System.out));     
        Turtle terry = new Turtle("Terry", new Formatter(outAlias));     
        tommy.move(0,0);     
        terry.move(4,8);     
        tommy.move(3,4);     
        terry.move(2,5);     
        tommy.move(3,3);     
        terry.move(3,3);   
    } 
} 
```

> #### `Formatter` 的重载构造器支持输出到多个路径，不过最常用的还是 `PrintStream()`（如上例）、`OutputStream` 和 `File`。你可以在 [附录:流式 I/O](https://njuics.github.io/OnJava8/#/././Appendix-IO-Streams) 中了解更多信息。







### (4) 格式化修饰符

> #### 在插入数据时，如果想要优化空格与对齐，你需要更精细复杂的格式修饰符。通用语法如下：

```
%[argument_index$][flags][width][.precision]conversion 
```

> - #### 默认情况下，数据是右对齐的，不过可以通过使用 `-` 标志来改变对齐方向。
>
> - #### 控制一个字段的最小长度，这可以通过指定 *`width`* 来实现。
>
> - #### 与 *`width`* 相对的是 *`precision`*，用于指定最大长度。
>
>     - ##### 在将 *`precision`* 应用于 `String` 时，它表示打印 `string` 时输出字符的最大数量。
>
>     - ##### 而在将 *`precision`* 应用于浮点数时，它表示小数部分要显示出来的位数（默认是 6 位小数），如果小数位数过多则舍入，太少则在尾部补零。
>
>     - ##### 由于整数没有小数部分，所以 *precision* 无法应用于整数，如果你对整数应用 *precision*，则会触发异常。







### (5) `String.format()`

> #### Java SE5 也参考了 C 中的 `sprintf()` 方法，以生成格式化的 `String` 对象。
>
> #### `String.format()` 是一个 `static` 方法，它接受与 `Formatter.format()` 方法一样的参数，但返回一个 `String` 对象











## 6. 正则表达式

> #### 正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入 `String` 进行搜索。一旦找到了匹配这些模式的部分，你就能随心所欲地对它们进行处理。
>
> #### 正则表达式提供了一种完全通用的方式，能够解决各种 `String` 处理相关的问题： ***`匹配`*** 、 ***`选择`*** 、 ***`编辑`*** 、 ***`验证`***。

### (1) 基础

> #### Java对反斜线 `\` 具有不同的处理方式：
>
> - #### 在其他语言中，`\\` 表示“我想要在正则表达式中插入一个普通的（字面上的）反斜线，请不要给它任何特殊的意义。”
>
> - #### 而在Java中，`\\` 的意思是“我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。”
>
> #### 所以在 `Java` 中，如果你想表示一位数字，那么正则表达式应该是 `\\d`。如果你想插入一个普通的反斜线，应该这样写 `\\\`。不过换行符和制表符之类的东西只需要使用单反斜线：`\n\t`。

```
public class IntegerMatch {  
    public static void main(String[] args) {     
        System.out.println("-1234".matches("-?\\d+"));  // true 
        System.out.println("5678".matches("-?\\d+"));   // true
        System.out.println("+911".matches("-?\\d+"));   //false
        System.out.println("+911".matches("(-|\\+)?\\d+")); // true
    }
}
```

> #### `String`类还自带了一个非常有用的正则表达式工具——`split()` 方法，其功能是“将字符串从正则表达式匹配的地方切开。” ; `String.split()` 还有一个重载的版本，它允许你限制字符串分割的次数。

```
public class Splitting {
    public static String knights =   
      "Then, when you have found the shrubbery, " +
      "you must cut down the mightiest tree in the " +
      "forest...with... a herring!";
    public static void split(String regex) {
        System.out.println(
          Arrays.toString(knights.split(regex)));
        }
    public static void main(String[] args) {
        split(" "); // Doesn't have to contain regex chars
        split("\\W+"); // Non-word characters
        split("n\\W+"); // 'n' followed by non-words
    }
}
```

> #### 用正则表达式进行替换操作时，你可以只替换 第一处匹配 ，也可以替换 所有的匹配 ：

```
public class Replacing {
    static String s = Splitting.knights;   
    public static void main(String[] args) {
        System.out.println(
          s.replaceFirst("f\\w+", "located"));
        System.out.println(       
          s.replaceAll("shrubbery|tree|herring","banana"));   
    } 
}
```







### (2) 创建正则表达式

> #### 正则表达式的完整构造子列表，请参考JDK文档 `java.util.regex` 包中的 `Pattern` 类。

|  表达式  | 含义                                |
| :------: | :---------------------------------- |
|   `B`    | 指定字符`B`                         |
|  `\xhh`  | 十六进制值为`0xhh`的字符            |
| `\uhhhh` | 十六进制表现为`0xhhhh`的Unicode字符 |
|   `\t`   | 制表符Tab                           |
|   `\n`   | 换行符                              |
|   `\r`   | 回车                                |
|   `\f`   | 换页                                |
|   `\e`   | 转义（Escape）                      |

> #### 以下是一些创建字符类的典型方式，以及一些预定义的类：这里只列出了部分常用的表达式，你应该将JDK文档中 `java.util.regex.Pattern` 那一页加入浏览器书签中，以便在需要的时候方便查询。

|     表达式     | 含义                                           |
| :------------: | :--------------------------------------------- |
|      `.`       | 任意字符                                       |
|    `[abc]`     | 包含`a`、`b`或`c`的任何字符（和`a              |
|    `[^abc]`    | 除`a`、`b`和`c`之外的任何字符（否定）          |
|   `[a-zA-Z]`   | 从`a`到`z`或从`A`到`Z`的任何字符（范围）       |
|  `[abc[hij]]`  | `a`、`b`、`c`、`h`、`i`、`j`中的任意字符（与`a |
| `[a-z&&[hij]]` | 任意`h`、`i`或`j`（交）                        |
|      `\s`      | 空白符（空格、tab、换行、换页、回车）          |
|      `\S`      | 非空白符（`[^\s]`）                            |
|      `\d`      | 数字（`[0-9]`）                                |
|      `\D`      | 非数字（`[^0-9]`）                             |
|      `\w`      | 词字符（`[a-zA-Z_0-9]`）                       |
|      `\W`      | 非词字符（`[^\w]`）                            |

| 逻辑操作符      | 含义                                                         |
| :-------------- | :----------------------------------------------------------- |
| `XY`            | `Y`跟在`X`后面                                               |
| `X         | Y` |                                                              |
| `(X)`           | 捕获组（capturing group）。可以在表达式中用`\i`引用第i个捕获组 |

> #### 下面是不同的 ***`边界匹配符`*** ：

| 边界匹配符 | 含义             |
| :--------: | :--------------- |
|    `^`     | 一行的开始       |
|    `$`     | 一行的结束       |
|    `\b`    | 词的边界         |
|    `\B`    | 非词的边界       |
|    `\G`    | 前一个匹配的结束 |

```
public class Rudolph {   
    public static void main(String[] args) {     
        for(String pattern : new String[]{       
          "Rudolph",       
          "[rR]udolph",       
          "[rR][aeiou][a-z]ol.*",       
          "R.*" })       
        System.out.println("Rudolph".matches(pattern));   
    } 
} 
```







### (3) 量词

> #### 量词描述了一个模式捕获输入文本的方式：
>
> - #### **`贪婪型`**： 量词总是贪婪的，除非有其他的选项被设置。贪婪表达式会为所有可能的模式发现尽可能多的匹配。导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配。
>
> - #### **`勉强型`**： 用问号来指定，这个量词匹配满足模式所需的最少字符数。因此也被称作懒惰的、最少匹配的、非贪婪的或不贪婪的。
>
> - #### **`占有型`**： 目前，这种类型的量词只有在 Java 语言中才可用（在其他语言中不可用），并且也更高级，因此我们大概不会立刻用到它。当正则表达式被应用于 `String` 时，它会产生相当多的状态，以便在匹配失败时可以回溯。而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯。它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更高效。

|  贪婪型  |  勉强型   |  占有型   |          如何匹配           |
| :------: | :-------: | :-------: | :-------------------------: |
|   `X?`   |   `X??`   |   `X?+`   |        一个或零个`X`        |
|   `X*`   |   `X*?`   |   `X*+`   |        零个或多个`X`        |
|   `X+`   |   `X+?`   |   `X++`   |        一个或多个`X`        |
|  `X{n}`  |  `X{n}?`  |  `X{n}+`  |        恰好`n`次`X`         |
| `X{n,}`  | `X{n,}?`  | `X{n,}+`  |          至少`n`次          |
| `X{n,m}` | `X{n,m}?` | `X{n,m}+` | `X`至少`n`次，但不超过`m`次 |







### (4) `CharSequence`

> #### 接口 `CharSequence` 从 `CharBuffer`、`String`、`StringBuffer`、`StringBuilder` 类中抽象出了字符序列的一般化定义，这些类都实现了该接口。多数正则表达式操作都接受 `CharSequence` 类型参数。

```
interface CharSequence {   
    char charAt(int i);   
    int length();
    CharSequence subSequence(int start, int end);
    String toString(); 
}
```







### (5) `Pattern` 和 `Matcher`

> #### 导入 `java.util.regex` ，然后用 `static Pattern.compile()` 方法来编译正则表达式即可。它会根据 `String` 类型的正则表达式生成一个 `Pattern` 对象。接下来，把想要检索的字符串传入 `Pattern` 对象的 `matcher()` 方法。`matcher()` 方法会生成一个 `Matcher` 对象，它有很多功能可用（可以参考 `java.util.regext.Matcher` 的 JDK 文档）。

```
import java.util.regex.*; 

public class TestRegularExpression {
    public static void main(String[] args) {     
        if(args.length < 2) {     
            System.out.println( "Usage:\njava TestRegularExpression " + "characterSequence regularExpression+");      
            System.exit(0);    
        }
        System.out.println("Input: \"" + args[0] + "\"");     
        for(String arg : args) {       
            System.out.println("Regular expression: \"" + arg + "\"");       
            Pattern p = Pattern.compile(arg);       
            Matcher m = p.matcher(args[0]);       
            while(m.find()) {
                System.out.println( "Match \"" + m.group() + "\" at positions " +  m.start() + "-" + (m.end() - 1));       
            }     
        }  
    }
}
```

> #### `Pattern` 类还提供了一个`static`方法：

```
static boolean matches(String regex, CharSequence input)
```

> #### 该方法用以检查 `regex` 是否匹配整个 `CharSequence` 类型的 `input` 参数。
>
> #### 编译后的 `Pattern` 对象还提供了 `split()` 方法，它从匹配了 `regex` 的地方分割输入字符串，返回分割后的子字符串 `String` 数组。







### (6) `find()`

> #### `Matcher.find()` 方法可用来在 `CharSequence` 中查找多个匹配。

```
import java.util.regex.*; 

public class Finding {   
    public static void main(String[] args) {     
        Matcher m = Pattern.compile("\\w+")       
          .matcher(         
            "Evening is full of the linnet's wings");     
        while(m.find()) // find() 方法像迭代器那样向前遍历输入字符串。      
            System.out.print(m.group() + " ");   
        System.out.println();     
        int i = 0;     
        while(m.find(i)) {  // find() 接收一个整型参数，该整数表示字符串中字符的位置，并以其作为搜索的起点。
            System.out.print(m.group() + " ");       
            i++;     
        }   
    }
}
```







### (7) 组(Groups)

> #### 组是用括号划分的正则表达式，可以根据组的编号来引用某个组。组号为 0 表示整个表达式，组号 1 表示被第一对括号括起来的组，以此类推。

> #### `Matcher` 对象提供了一系列方法，用以获取与组相关的信息：
>
> - #### `public int groupCount()` 返回该匹配器的模式中的分组数目，组 0 不包括在内。
>
> - #### `public String group()` 返回前一次匹配操作的第 0 组（整个匹配）。
>
> - #### `public String group(int i)` 返回前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配输入字符串的任何部分，则将返回 `null`。
>
> - #### `public int start(int group)` 返回在前一次匹配操作中寻找到的组的起始索引。
>
> - #### `public int end(int group)` 返回在前一次匹配操作中寻找到的组的最后一个字符索引加一的值。

```
import java.util.regex.*; 

public class Groups {   
    public static final String POEM =     
      "Twas brillig, and the slithy toves\n" +     
      "Did gyre and gimble in the wabe.\n" +     
      "All mimsy were the borogoves,\n" +     
      "And the mome raths outgrabe.\n\n" +     
      "Beware the Jabberwock, my son,\n" +     
      "The jaws that bite, the claws that catch.\n" +     
      "Beware the Jubjub bird, and shun\n" +     
      "The frumious Bandersnatch.";   
    public static void main(String[] args) {     
        Matcher m = Pattern.compile(
          "(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))$")       
          .matcher(POEM);     
        while(m.find()) {       
            for(int j = 0; j <= m.groupCount(); j++)         
                System.out.print("[" + m.group(j) + "]"); 
            System.out.println();     
        }   
    } 
}
```







### (8) `start()` 和 `end()`

> #### 在匹配操作成功之后，`start()` 返回先前匹配的起始位置的索引，而 `end()` 返回所匹配的最后字符的索引加一的值。匹配操作失败之后（或先于一个正在进行的匹配操作去尝试）调用 `start()` 或 `end()` 将会产生 `IllegalStateException`。







### (9) `Pattern` 标记

> #### `Pattern` 类的 `compile()` 方法还有另一个版本，它接受一个标记参数，以调整匹配行为：

```
Pattern Pattern.compile(String regex, int flag)
```

> #### 其中的 `flag` 来自以下 `Pattern` 类中的常量

|            编译标记            | 效果                                                         |
| :----------------------------: | :----------------------------------------------------------- |
|       `Pattern.CANON_EQ`       | 当且仅当两个字符的完全规范分解相匹配时，才认为它们是匹配的。例如，如果我们指定这个标记，表达式`\u003F`就会匹配字符串`?`。默认情况下，匹配不考虑规范的等价性 |
| `Pattern.CASE_INSENSITIVE(?i)` | 默认情况下，大小写不敏感的匹配假定只有US-ASCII字符集中的字符才能进行。这个标记允许模式匹配不考虑大小写（大写或小写）。通过指定`UNICODE_CASE`标记及结合此标记。基于Unicode的大小写不敏感的匹配就可以开启了 |
|     `Pattern.COMMENTS(?x)`     | 在这种模式下，空格符将被忽略掉，并且以`#`开始直到行末的注释也会被忽略掉。通过嵌入的标记表达式也可以开启Unix的行模式 |
|      `Pattern.DOTALL(?s)`      | 在dotall模式下，表达式`.`匹配所有字符，包括行终止符。默认情况下，`.`不会匹配行终止符 |
|    `Pattern.MULTILINE(?m)`     | 在多行模式下，表达式`^`和`$`分别匹配一行的开始和结束。`^`还匹配输入字符串的开始，而`$`还匹配输入字符串的结尾。默认情况下，这些表达式仅匹配输入的完整字符串的开始和结束 |
|   `Pattern.UNICODE_CASE(?u)`   | 当指定这个标记，并且开启`CASE_INSENSITIVE`时，大小写不敏感的匹配将按照与Unicode标准相一致的方式进行。默认情况下，大小写不敏感的匹配假定只能在US-ASCII字符集中的字符才能进行 |
|    `Pattern.UNIX_LINES(?d)`    | 在这种模式下，在`.`、`^`和`$`的行为中，只识别行终止符`\n`    |

```
import java.util.regex.*; 

public class ReFlags {   
    public static void main(String[] args) {     
        Pattern p =  Pattern.compile("^java", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);     
        Matcher m = p.matcher(       
          "java has regex\nJava has regex\n" +       
          "JAVA has pretty good regular expressions\n" +       
          "Regular expressions are in Java");     
        while(m.find())       
            System.out.println(m.group());   
    } 
}
```







### (10) `split()`

> #### `split()`方法将输入 `String` 断开成 `String` 对象数组，断开边界由正则表达式确定：

```
String[] split(CharSequence input) 
String[] split(CharSequence input, int limit)
import java.util.regex.*; 
import java.util.*; 

public class SplitDemo {  
    public static void main(String[] args) {     
        String input =       
          "This!!unusual use!!of exclamation!!points";     
        System.out.println(Arrays.toString(       
        Pattern.compile("!!").split(input)));     
        // Only do the first three:     
        System.out.println(Arrays.toString(       
        Pattern.compile("!!").split(input, 3)));   
    }
}
```







### (11) 替换操作

> #### 正则表达式在进行文本替换时特别方便，它提供了许多方法：
>
> - #### `replaceFirst(String replacement)` ： 以参数字符串 `replacement` 替换掉第一个匹配成功的部分。
>
> - #### `replaceAll(String replacement)` ： 以参数字符串 `replacement` 替换所有匹配成功的部分。
>
> - #### `appendReplacement(StringBuffer sbuf, String replacement)` ： 执行渐进式的替换，而不是像 `replaceFirst()` 和 `replaceAll()` 那样只替换第一个匹配或全部匹配。这是一个非常重要的方法。它允许你调用其他方法来生成或处理 `replacement`（`replaceFirst()` 和 `replaceAll()` 则只能使用一个固定的字符串），使你能够以编程的方式将目标分割成组，从而具备更强大的替换功能。
>
> - #### `appendTail(StringBuffer sbuf)` ： 在执行了一次或多次 `appendReplacement()` 之后，调用此方法可以将输入字符串余下的部分复制到 `sbuf` 中。

```
import java.util.regex.*; 
import java.nio.file.*; 
import java.util.stream.*;

public class TheReplacements {   
    public static void main(String[] args) throws Exception {     
        String s = Files.lines(       
          Paths.get("TheReplacements.java"))       
          .collect(Collectors.joining("\n"));     
        // Match specially commented block of text above:     
        Matcher mInput = Pattern.compile(       
          "/\\*!(.*)!\\*/", Pattern.DOTALL).matcher(s);     
        if(mInput.find())       
            s = mInput.group(1); // Captured by parentheses     
        // Replace two or more spaces with a single space:     
        s = s.replaceAll(" {2,}", " ");     
        // Replace 1+ spaces at the beginning of each     
        // line with no spaces. Must enable MULTILINE mode:     
        s = s.replaceAll("(?m)^ +", "");     
        System.out.println(s);     
        s = s.replaceFirst("[aeiou]", "(VOWEL1)");     
        StringBuffer sbuf = new StringBuffer();     
        Pattern p = Pattern.compile("[aeiou]");     
        Matcher m = p.matcher(s);     
        // Process the find information as you     
        // perform the replacements:     
        while(m.find())      
            m.appendReplacement(sbuf, m.group().toUpperCase());     
        // Put in the remainder of the text:     
        m.appendTail(sbuf);     
        System.out.println(sbuf);
    } 
}
```







### (12) `reset()`

> #### 通过 `reset()` 方法，可以将现有的 `Matcher` 对象应用于一个新的字符序列：

```
import java.util.regex.*; 

public class Resetting {   
    public static void main(String[] args) throws Exception { 
        Matcher m = Pattern.compile("[frb][aiu][gx]")       
          .matcher("fix the rug with bags");     
        while(m.find())       
            System.out.print(m.group() + " ");     
        System.out.println();     
        m.reset("fix the rig with rags");     
        while(m.find())       
            System.out.print(m.group() + " ");   
    } 
} 
```







### (13) 正则表达式与 Java I/O

> #### `JGrep.java` 的灵感源自于 Unix 上的 *grep*。它有两个参数：文件名以及要匹配的正则表达式。输出的是每行有匹配的部分以及匹配部分在行中的位置：

```
import java.util.regex.*; 
import java.nio.file.*; 
import java.util.stream.*;

public class JGrep {  
    public static void main(String[] args) throws Exception {
        if(args.length < 2) {      
            System.out.println(        
              "Usage: java JGrep file regex");      
            System.exit(0);   
        }    
        Pattern p = Pattern.compile(args[1]);    
        // Iterate through the lines of the input file:    
        int index = 0;    
        Matcher m = p.matcher("");    
        for(String line: Files.readAllLines(Paths.get(args[0]))) {      
            m.reset(line);      
            while(m.find())        
                System.out.println(index++ + ": " + m.group() + ": " + m.start());    
        }  
    } 
} 
```





#### 如果想要更深入地学习正则表达式，你可以阅读 `Jeffrey E. F. Friedl` 的`《精通正则表达式（第2版）》`。网络上也有很多正则表达式的介绍，你还可以从 `Perl` 和 Python 等其他语言的文档中找到有用的信息。











## 7. 扫描输入

> #### 一般我们对于 “从文件或标准输入读取数据” 的解决办法是读入一行文本，对其进行分词，然后使用 `Integer`、`Double` 等类的各种解析方法来解析数据：

```
import java.io.*;

public class SimpleRead {  
    public static BufferedReader input = new BufferedReader(new StringReader("Sir Robin of Camelot\n22 1.61803"));  
    public static void main(String[] args) {    
        try {      
            System.out.println("What is your name?");      
            String name = input.readLine();      
            System.out.println(name);      
            System.out.println("How old are you? " +        
              "What is your favorite double?");      
            System.out.println("(input: <age> <double>)");      
            String numbers = input.readLine();      
            System.out.println(numbers);      
            String[] numArray = numbers.split(" ");      
            int age = Integer.parseInt(numArray[0]);      
            double favorite = Double.parseDouble(numArray[1]);      
            System.out.format("Hi %s.%n", name);      
            System.out.format("In 5 years you will be %d.%n", age + 5);      
            System.out.format("My favorite double is %f.", favorite / 2);    
        } catch(IOException e) {      
            System.err.println("I/O exception");    
        }  
    } 
}
```

> #### 而 `Java SE5` 新增了 `Scanner` 类，它可以大大减轻扫描输入的工作负担：

```
import java.util.*; 

public class BetterRead {
  public static void main(String[] args) {
    Scanner stdin = new Scanner(SimpleRead.input);
    System.out.println("What is your name?");
    String name = stdin.nextLine();
    System.out.println(name);
    System.out.println("How old are you? What is your favorite double?");
    System.out.println("(input: <age> <double>)");
    int age = stdin.nextInt();
    double favorite = stdin.nextDouble();
    System.out.println(age);
    System.out.println(favorite);
    System.out.format("Hi %s.%n", name);
    System.out.format("In 5 years you will be %d.%n", age + 5);
    System.out.format("My favorite double is %f.", favorite / 2);
  }
}
```

> #### `Scanner` 的构造器可以接收任意类型的输入对象，包括 `File`、`InputStream`、`String` 或者像此例中的`Readable` 实现类。`Readable` 是 Java SE5 中新加入的一个接口，表示 “具有 `read()` 方法的某种东西” 。
>
> #### `Scanner` 还有相应的 `hasNext` 方法，用以判断下一个输入分词是否是所需的类型，如果是则返回 `true

### (1) `Scanner`分隔符

> #### 默认情况下，`Scanner` 根据空白字符对输入进行分词，但是你可以用正则表达式指定自己所需的分隔符：

```
、import java.util.*;
public class ScannerDelimiter {  
    public static void main(String[] args) {    
        Scanner scanner = new Scanner("12, 42, 78, 99, 42");
        scanner.useDelimiter("\\s*,\\s*");    
        while(scanner.hasNextInt())    
            System.out.println(scanner.nextInt());  
    } 
}
```

> #### 我们可以用 `useDelimiter()` 来设置分隔符，同时，还有一个 `delimiter()` 方法，用来返回当前正在作为分隔符使用的 `Pattern` 对象。







### (2) 用正则表达式扫描

> #### 除了能够扫描基本类型之外，你还可以使用 自定义的正则表达式 进行扫描，这在扫描复杂数据时非常有用。

```
// strings/ThreatAnalyzer.java 
import java.util.regex.*; 
import java.util.*;
public class ThreatAnalyzer { 
    static String threatData =    
      "58.27.82.161@08/10/2015\n" +   
      "204.45.234.40@08/11/2015\n" +    
      "58.27.82.161@08/11/2015\n" +    
      "58.27.82.161@08/12/2015\n" +    
      "58.27.82.161@08/12/2015\n" +
      "[Next log section with different data format]";  
    public static void main(String[] args) { 
        Scanner scanner = new Scanner(threatData);    
        String pattern = "(\\d+[.]\\d+[.]\\d+[.]\\d+)@" + "(\\d{2}/\\d{2}/\\d{4})";    
        while(scanner.hasNext(pattern)) {      
            scanner.next(pattern);      
            MatchResult match = scanner.match();      
            String ip = match.group(1);      
            String date = match.group(2);      
            System.out.format("Threat on %s from %s%n", date,ip);    
        }  
    } 
} 
```

> #### 在配合正则表达式使用扫描时，有一点需要注意：它仅仅针对下一个输入分词进行匹配，如果你的正则表达式中含有分隔符，那永远不可能匹配成功。







### (3) `StringTokenizer` 类

> #### 在 Java 引入正则表达式（J2SE1.4）和 `Scanner` 类（Java SE5）之前，分割字符串的唯一方法是使用 `StringTokenizer` 来分词。下面的例子中，我们将 `StringTokenizer` 与另外两种技术简单地做了一个比较：

```
import java.util.*; 

public class ReplacingStringTokenizer {   
    public static void main(String[] args) {     
        String input = "But I'm not dead yet! I feel happy!"; 
        StringTokenizer stoke = new StringTokenizer(input);
        while(stoke.hasMoreElements())       
            System.out.print(stoke.nextToken() + " ");     
        System.out.println(); 
        System.out.println(Arrays.toString(input.split(" ")));
        Scanner scanner = new Scanner(input);     
        while(scanner.hasNext())       
            System.out.print(scanner.next() + " ");   
    }
} 
```

> #### 使用正则表达式或 `Scanner` 对象，我们能够以更加复杂的模式来分割一个字符串，而这对于 `StringTokenizer` 来说就很困难了。
>
> #### `基本上，我们可以放心地说，StringTokenizer 已经可以废弃不用了。`











## 8. 本章小结

> #### 到目前为止，Java 对字符串操作的支持已经很完善了。不过，有时你还要在细节上注意效率问题，例如恰当地使用 `StringBuilder` 等。













# [第十九章 类型信息](https://njuics.github.io/OnJava8/#/book/19-Type-Information?id=第十九章-类型信息)

> #### RTTI（运行时类型信息）能够在 程序运行时 发现和使用类型信息。

> #### Java 是如何在运行时识别对象和类信息的。主要有两种方式：
>
> - #### “传统的” RTTI：假定我们在编译时已经知道了所有的类型；
>
> - #### “反射”机制：允许我们在运行时发现和使用类的信息。

## 1. 为什么需要RTTI

```
import java.util.stream.*;

abstract class Shape {
    void draw() { System.out.println(this + ".draw()"); }
    @Override
    public abstract String toString();
}

class Circle extends Shape {
    @Override
    public String toString() { return "Circle"; }
}

class Square extends Shape {
    @Override
    public String toString() { return "Square"; }
}

class Triangle extends Shape {
    @Override
    public String toString() { return "Triangle"; }
}

public class Shapes {
    public static void main(String[] args) {
        Stream.of(new Circle(), new Square(), new Triangle())
              .forEach(Shape::draw);
    }
}
```

> #### 在 Java 中，所有类型转换的正确性检查都是在运行时进行的。这也是 `RTTI` 的含义所在 ： 在运行时，识别一个对象的类型 。

> #### 上述例子体现了我们编写代码的一般需求，通常我们希望大部分代码尽可能少了解对象的具体类型，而是至于对象家族中的一个通用表示打交道。这样代码会更容易编写、读取和维护；设计也更加容易实现。所以多态是面向对象的基本目标。

> #### 使用 `RTTI` ，我们可以查询某个 `Shape` 引用所指向的对象的确切类型，然后选择或剔除特例











## 2. Class 对象

> #### 类型信息在运行时的表示方式是由 `Class 对象` 完成的，它包含了与类有关的信息。实际上 `Class 对象` 就是用来创建该类所有 “常规” 对象的。
>
> #### Java 使用 `Class` 对象来实现 `RTTI` ，即便是类型转换也是用 `Class` 对象实现的。`Class` 类还提供了很多使用 RTTI 的其他方式。

> #### 类是程序的一部分，每个类都有一个 `Class` 对象。每当我们编写并编译了一个新类，就hi产生一个 `Class` 对象。为了生成这个类的对象，`JVM` 会先调用 “类加载器” 子系统把这个类加载到内存中。
>
> #### 类加载器子系统可能包含一条类加载器链，但有且只有一个 **`原生类加载器`** ，它是 JVM 实现的一部分。
>
> #### 原生类加载器加载的是 “可信类”(包含 Java API 类)，它们通常是从本地盘加载的，但如果有别的特殊需求也可以挂载额外的类加载器。

> #### 所有类都是在第一次使用时动态加载到 `JVM` 中的。因此 Java 程序在它开始运行之前并没有被完全加载，很多部分是在需要时才会加载。
>
> - #### 类加载器会首先检查这个类的 `Class` 对象是否已经加载，如果尚未加载，默认的类加载器就会根据类名查找 `.class` 文件(如果有附加的类加载器，可能就会在数据库中或者通过其他方式获得字节码)
>
> - #### 类的字节码被加载后，`JVM` 会对其进行验证，确保没有损坏，并且不包含不良的 Java 代码(这是 Java 安全防范的一种措施)
>
> - #### 一旦某个类的 `Class` 对象被载入内存，就可以用它来创建这个类的所有对象。

> #### `Class` 对象的 `newInstance()` 方法是实现“虚拟构造器”的一种途径，虚拟构造器可以让你在不知道一个类的确切类型的时候，创建这个类的对象。
>
> #### 另外，使用 `newInstance()` 来创建的类，必须带有无参数的构造器。在本章稍后部分，你将会看到如何通过 Java 的反射 API，用任意的构造器来动态地创建类的对象。

### (1) 类字面常量

> #### Java 提供另一种方法来生成类对象的引用： ***`类字面常量`*** 。这样做不仅更简单、更安全，因为它会在编译时就受到检查(因此不必放入 `try` 语句块中)；
>
> #### 并且它根除了对 `forName()` 方法的调用，所以效率更高。***`类字面常量`*** 可用于普通类、接口、数组、基本数据类型。
>
> #### 另外对于基本数据类型的包装类，还有一个标准字段 `TYPE` 。`TYPE` 字段是一个引用，指向对应的基本数据类型的 `Class` 对象，如下所示：

| ...等价于...  |                |
| :-----------: | :------------: |
| boolean.class |  Boolean.TYPE  |
|  char.class   | Character.TYPE |
|  byte.class   |   Byte.TYPE    |
|  short.class  |   Short.TYPE   |
|   int.class   |  Integer.TYPE  |
|  long.class   |   Long.TYPE    |
|  float.class  |   Float.TYPE   |
| double.class  |  Double.TYPE   |
|  void.class   |   Void.TYPE    |

> #### 当使用 `.class` 来创建对 `Class` 对象的引用时，不会自动的初始化该 `Class` 对象。直到第一次引用一个 `static` 方法或者非常量的 `static` 字段，才会进行类初始化。如果只是将一个字段设置成为 `static` 和 `final`，还不足以确保这种行为。
>
> #### 但与此相反，使用 `Class.forName()` 来产生 `Class` 引用会立即就进行初始化。
>
> #### 为了使用类而做的准备工作实际上包含三个步骤：
>
> - #### **`加载`** ： 这是由类加载器执行的。该步骤将查找字节码（通常在 classpath 所指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个 `Class` 对象。
>
> - #### **`链接`** ： 在链接阶段将验证类中的字节码，为 `static` 字段分配存储空间，并且如果需要的话，将解析这个类创建的对其他类的所有引用。
>
> - #### **`初始化`** ： 如果该类具有超类，则先初始化超类，执行 `static` 初始化器和 `static` 初始化块。







### (2) 泛化的 `Class` 引用

> #### `Class` 引用总是指向某个 `Class` 对象，而 `Class` 对象可以用于产生类的实例，并且包含可作用于这些实例的所有方法代码。它还包含该类的 `static` 成员。
>
> #### Java 引入泛型语法之后，我们可以使用 `泛型` 对 `Class` 引用所指向的 `Class` 对象的类型进行限定。 `普通的类引用` 可以重新赋值指向任何其他的 `Class` 对象，但是 `使用泛型限定的类引用`只能指向其声明的类型。

```
public class GenericClassReferences {
    public static void main(String[] args) {
        Class intClass = int.class;
        Class<Integer> genericIntClass = int.class;
        genericIntClass = Integer.class; // 同一个东西
        intClass = double.class;
        // genericIntClass = double.class; // 非法
    }
}
public class WildcardClassReferences {
    public static void main(String[] args) {
        Class<?> intClass = int.class;
        intClass = double.class;
    }
}
```

> #### 下面的示例使用了泛型语法，它保存了一个类引用，稍后又用 `newInstance()` 方法产生类的对象：

```
import java.util.function.*;
import java.util.stream.*;

class CountedInteger {
    private static long counter;
    private final long id = counter++;
    @Override
    public String toString() { return Long.toString(id); }
}

public class DynamicSupplier<T> implements Supplier<T> {
    private Class<T> type;
    public DynamicSupplier(Class<T> type) {
        this.type = type;
    }
    public T get() {
        try {
            return type.newInstance();
        } catch(InstantiationException |
                        IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
    public static void main(String[] args) {
        Stream.generate(
            new DynamicSupplier<>(CountedInteger.class))
            .skip(10)
            .limit(5)
            .forEach(System.out::println);
    }
}
```







### (3) `cast()` 方法

> #### `cast()` 方法接受参数对象，并将其转换为 `Class` 引用的对象。`cast()` 在无法使用普通类型转换的情况下非常有用，在我们编写泛型代码时，如果你保存了 `Class` 引用，并希望以后通过这个引用来执行转型，我们就需要用到 `cast()` 。

```
class Building {}
class House extends Building {}

public class ClassCasts {
    public static void main(String[] args) {
        Building b = new House();
        Class<House> houseType = House.class;
        House h = houseType.cast(b);
        h = (House)b; // ... 或者这样做.
    }
}
```

> #### Java 类库中另一个没有任何用处的特性就是 `Class.asSubclass()`，该方法允许你将一个 `Class` 对象转型为更加具体的类型。











## 3. 类型转换检测

> #### 直到现在，我们已知的 RTTI 类型包括：
>
> - #### 传统的类型转换，如 “`(Shape)`”，由 RTTI 确保转换的正确性，如果执行了一个错误的类型转换，就会抛出一个 `ClassCastException` 异常。
>
> - #### 代表对象类型的 `Class` 对象. 通过查询 `Class` 对象可以获取运行时所需的信息。
>
> - #### RTTI 在 Java 中还有第三种形式，那就是关键字 `instanceof` 。它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。`instanceof` 有一个严格的限制：只可以将它与 `命名类型` 进行比较，而不能与 `Class` 对象作比较。

```
package typeinfo.pets;
import java.util.*;
import java.util.function.*;

public abstract class PetCreator implements Supplier<Pet> {
    private Random rand = new Random(47);

    // The List of the different types of Pet to create:
    public abstract List<Class<? extends Pet>> types();

    public Pet get() { // Create one random Pet
        int n = rand.nextInt(types().size());
        try {
            return types().get(n).newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
}
```

> #### 当你创建 `PetCreator` 的子类时，你需要为 `get()` 方法提供 `Pet` 类型的 `List`。`types()` 方法会简单地返回一个静态 `List` 的引用。下面是使用 `forName()` 的一个具体实现：

```
package typeinfo.pets;
import java.util.*;

public class ForNameCreator extends PetCreator {
    private static List<Class<? extends Pet>> types =
            new ArrayList<>();
    // 需要随机生成的类型名:
    private static String[] typeNames = {
            "typeinfo.pets.Mutt",
            "typeinfo.pets.Pug",
            "typeinfo.pets.EgyptianMau",
            "typeinfo.pets.Manx",
            "typeinfo.pets.Cymric",
            "typeinfo.pets.Rat",
            "typeinfo.pets.Mouse",
            "typeinfo.pets.Hamster"
    };// 由于 Pet 相关的文件在 typeinfo 包里面，所以使用它们的时候需要填写完整的包名。

    @SuppressWarnings("unchecked")	// 注解不能够直接放置在静态代码块之上。
    private static void loader() {
        try {
            for (String name : typeNames)
                types.add(
                        (Class<? extends Pet>) Class.forName(name)); // 为了使得 List 装入的是具体的 Class 对象，类型转换是必须的，它会产生一个编译时警告。
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }

    static {
        loader();
    }

    @Override
    public List<Class<? extends Pet>> types() {
        return types;
    }
}
```

### (1) 使用类字面量

> #### 如果我们使用类字面量重新实现 `PetCreator` 类的话，其结果在很多方面都会更清晰：

```
package typeinfo.pets;
import java.util.*;

public class LiteralPetCreator extends PetCreator {
    // try 代码块不再需要
    @SuppressWarnings("unchecked")
    public static final List<Class<? extends Pet>> ALL_TYPES =
            Collections.unmodifiableList(Arrays.asList(
                    Pet.class, Dog.class, Cat.class, Rodent.class,
                    Mutt.class, Pug.class, EgyptianMau.class,
                    Manx.class, Cymric.class, Rat.class,
                    Mouse.class, Hamster.class));
    // 用于随机创建的类型:
    private static final List<Class<? extends Pet>> TYPES =
            ALL_TYPES.subList(ALL_TYPES.indexOf(Mutt.class),
                    ALL_TYPES.size());

    @Override
    public List<Class<? extends Pet>> types() {
        return TYPES;
    }

    public static void main(String[] args) {
        System.out.println(TYPES);
    }
}
```

> #### 这次，`types` 的创建没有被 `try` 块包围，因为它是在编译时计算的，因此不会引发任何异常，不像 `Class.forName()`。







### (2) 一个动态 `instanceof` 函数

> #### `Class.isInstance()` 方法提供了一种动态测试对象类型的方法。

```
import java.util.*;
import java.util.stream.*;

import onjava.*;
import typeinfo.pets.*;

public class PetCount3 {
    static class Counter extends
            LinkedHashMap<Class<? extends Pet>, Integer> {
        Counter() {
            super(LiteralPetCreator.ALL_TYPES.stream()
                    .map(lpc -> Pair.make(lpc, 0))
                    .collect(
                            Collectors.toMap(Pair::key, Pair::value)));
        }

        public void count(Pet pet) {
            // Class.isInstance() 替换 instanceof:
            entrySet().stream()
                    .filter(pair -> pair.getKey().isInstance(pet))
                    .forEach(pair ->
                            put(pair.getKey(), pair.getValue() + 1));
        }

        @Override
        public String toString() {
            String result = entrySet().stream()
                    .map(pair -> String.format("%s=%s",
                            pair.getKey().getSimpleName(),
                            pair.getValue()))
                    .collect(Collectors.joining(", "));
            return "{" + result + "}";
        }
    }

    public static void main(String[] args) {
        Counter petCount = new Counter();
        Pets.stream()
                .limit(20)
                .peek(petCount::count)
                .forEach(p -> System.out.print(
                        p.getClass().getSimpleName() + " "));
        System.out.println("n" + petCount);
    }
}
```

> #### `isInstance()` 方法消除了对 `instanceof` 表达式的需要。此外，这意味着你可以通过更改 `LiteralPetCreator.types` 数组来添加新类型的 `Pet`；程序的其余部分不需要修改。







### (3) 递归计数

> #### 我们可以使用 `Class.isAssignableFrom()` 而不是预加载 `Map` ，并创建一个不限于计数 `Pet` 的通用工具：

```
package onjava;
import java.util.*;
import java.util.stream.*;

public class TypeCounter extends HashMap<Class<?>, Integer> {
    private Class<?> baseType;

    public TypeCounter(Class<?> baseType) {
        this.baseType = baseType;
    }

    public void count(Object obj) {
        Class<?> type = obj.getClass();
        if(!baseType.isAssignableFrom(type))
              throw new RuntimeException(
                obj + " incorrect type: " + type +
                ", should be type or subtype of " + baseType);
        countClass(type);
    }

    private void countClass(Class<?> type) {
        Integer quantity = get(type);
        put(type, quantity == null ? 1 : quantity + 1);
        Class<?> superClass = type.getSuperclass();
        if(superClass != null &&
               baseType.isAssignableFrom(superClass))
              countClass(superClass);
    }

    @Override
    public String toString() {
        String result = entrySet().stream()
              .map(pair -> String.format("%s=%s",
                pair.getKey().getSimpleName(),
                pair.getValue()))
              .collect(Collectors.joining(", "));
        return "{" + result + "}";
    }
}
```

> #### `count()` 方法获取其参数的 `Class`，并使用 `isAssignableFrom()` 进行运行时检查，以验证传递的对象实际上属于感兴趣的层次结构。`countClass()` 首先计算类的确切类型。然后，如果 `baseType` 可以从超类赋值，则在超类上递归调用 `countClass()`。

```
import typeinfo.pets.*;
import onjava.*;

public class PetCount4 {
    public static void main(String[] args) {
        TypeCounter counter = new TypeCounter(Pet.class);
        Pets.stream()
              .limit(20)
              .peek(counter::count)
              .forEach(p -> System.out.print( p.getClass().getSimpleName() + " "));
        System.out.println("n" + counter);
  }
}
```











## 4. 注册工厂

> #### 使用 ***`工厂方法`*** 设计模式将对象的创建推迟到类本身。工厂方法可以以多态方式调用，并为你创建适当类型的对象。











## 5. 类的等价比较

> #### 令人放心的是，`instanceof` 和 `isInstance()` 产生的结果相同， `equals()` 和 `==` 产生的结果也相同。
>
> #### `instanceof` 说的是“你是这个类，还是从这个类派生的类？”。而如果使用 `==` 比较实际的`Class` 对象，则与继承无关 —— 它要么是确切的类型，要么不是。











## 6. 反射：运行时类信息

> #### 如果你不知道对象的确切类型，`RTTI` 会告诉你。但是，有一个限制： 必须在编译时知道类型，才能使用 `RTTI` 检测它，并对信息做一些有用的事情。 换句话说，编译器必须知道你使用的所有类。

> #### 在 ***`运行时发现类信息`*** 的另一个令人信服的动机是提供跨网络在远程平台上创建和执行对象的能力。这称为*远程方法调用*（RMI），它使 Java 程序的对象分布在许多机器上。

> #### 类 `Class` 支持*反射*的概念， `java.lang.reflect` 库中包含类 `Field`、`Method` 和 `Constructor`（每一个都实现了 `Member` 接口）。
>
> #### 这些类型的对象由 JVM 在运行时创建，以表示未知类中的对应成员。
>
> - #### 可以使用 `Constructor` 创建新对象；
>
> - #### `get()` 和 `set()` 方法读取和修改与 `Field` 对象关联的字段；
>
> - #### `invoke()` 方法调用与 `Method` 对象关联的方法。
>
> - #### 此外，还可以调用便利方法 `getFields()`、`getMethods()`、`getConstructors()` 等，以返回表示字段、方法和构造函数的对象数组。
>
> - #### （你可以通过在 JDK 文档中查找类 `Class` 来了解更多信息。）

> #### 因此，匿名对象的类信息可以在运行时完全确定，编译时不需要知道任何信息。

> #### ***`RTTI`*** 和 ***`反射`*** 的真正区别在于：
>
> - #### 使用 `RTTI` 时，`编译器`在编译时会打开并检查 `.class` 文件。换句话说，你可以用“正常”的方式调用一个对象的所有方法。
>
> - #### 通过反射，`.class` 文件在编译时不可用；它由运行时环境打开并检查。

### (1) 类方法提取器

> #### 反射是用来支持其他 Java 特性的，例如对象序列化，但有时动态提取有关类的信息很有用。

> #### 反射提供了一种方法，可以简单地编写一个工具类自动地向你展示所有的接口：

```
import java.lang.reflect.*;
import java.util.regex.*;

public class ShowMethods {
    private static String usage =
            "usage:\n" +
            "ShowMethods qualified.class.name\n" +
            "To show all methods in class or:\n" +
            "ShowMethods qualified.class.name word\n" +
            "To search for methods involving 'word'";
    private static Pattern p = Pattern.compile("\\w+\\.");

    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println(usage);
            System.exit(0);
        }
        int lines = 0;
        try {
            Class<?> c = Class.forName(args[0]);
            Method[] methods = c.getMethods();
            Constructor[] ctors = c.getConstructors();
            if (args.length == 1) {
                for (Method method : methods)
                    System.out.println(
                            p.matcher(
                                    method.toString()).replaceAll(""));
                for (Constructor ctor : ctors)
                    System.out.println(
                            p.matcher(ctor.toString()).replaceAll(""));
                lines = methods.length + ctors.length;
            } else {
                for (Method method : methods)
                    if (method.toString().contains(args[1])) {
                        System.out.println(p.matcher(
                                method.toString()).replaceAll(""));
                        lines++;
                    }
                for (Constructor ctor : ctors)
                    if (ctor.toString().contains(args[1])) {
                        System.out.println(p.matcher(
                                ctor.toString()).replaceAll(""));
                        lines++;
                    }
            }
        } catch (ClassNotFoundException e) {
            System.out.println("No such class: " + e);
        }
    }
}
```











## 7. 动态代理

> #### ***`代理`\***是基本的设计模式之一。一个对象封装真实对象，代替其提供其他或不同的操作---这些操作通常涉及到与“真实”对象的通信，因此代理通常充当中间对象。

```
interface Interface {
    void doSomething();

    void somethingElse(String arg);
}

class RealObject implements Interface {
    @Override
    public void doSomething() {
        System.out.println("doSomething");
    }

    @Override
    public void somethingElse(String arg) {
        System.out.println("somethingElse " + arg);
    }
}

class SimpleProxy implements Interface {
    private Interface proxied;

    SimpleProxy(Interface proxied) {
        this.proxied = proxied;
    }

    @Override
    public void doSomething() {
        System.out.println("SimpleProxy doSomething");
        proxied.doSomething();
    }

    @Override
    public void somethingElse(String arg) {
        System.out.println(
                "SimpleProxy somethingElse " + arg);
        proxied.somethingElse(arg);
    }
}

class SimpleProxyDemo {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse("bonobo");
    }

    public static void main(String[] args) {
        consumer(new RealObject());
        consumer(new SimpleProxy(new RealObject()));
    }
}
```

> Java 的***`动态代理`***更进一步，不仅动态创建代理对象而且动态处理对代理方法的调用。在动态代理上进行的所有调用都被重定向到单个***`调用处理程序`***，该处理程序负责 ***发现调用的内容并决定如何处理*** 。

```
import java.lang.reflect.*;

class DynamicProxyHandler implements InvocationHandler { // 接口 InvocationHandler 的一个实现
    private Object proxied;

    DynamicProxyHandler(Object proxied) {
        this.proxied = proxied;
    }

    @Override
    public Object
    invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        System.out.println(
                "**** proxy: " + proxy.getClass() +
                        ", method: " + method + ", args: " + args);
        if (args != null)
            for (Object arg : args)
                System.out.println("  " + arg);
        return method.invoke(proxied, args);
    }
}

class SimpleDynamicProxy {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse("bonobo");
    }

    public static void main(String[] args) {
        RealObject real = new RealObject();
        consumer(real);
        // Insert a proxy and call again:
        Interface proxy = (Interface) Proxy.newProxyInstance( // 可以通过调用静态方法 Proxy.newProxyInstance() 来创建动态代理，该方法需要一
                Interface.class.getClassLoader(), // 一个类加载器（通常可以从已加载的对象中获取），
                new Class[]{Interface.class},	  // 希望代理实现的接口列表（不是类或抽象类），
                new DynamicProxyHandler(real));	  // 以及接口 InvocationHandler 的一个实现。
        consumer(proxy);
    }
}
```

> #### 通常执行代理操作，然后使用 `Method.invoke()` 将请求转发给被代理对象，并携带必要的参数。这在一开始看起来是有限制的，好像你只能执行一般的操作。但是，可以过滤某些方法调用，同时传递其他方法调用：

```
import java.lang.reflect.*;

class MethodSelector implements InvocationHandler {
    private Object proxied;

    MethodSelector(Object proxied) {
        this.proxied = proxied;
    }

    @Override
    public Object
    invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        if (method.getName().equals("interesting"))
            System.out.println(
                    "Proxy detected the interesting method");
        return method.invoke(proxied, args);
    }
}

interface SomeMethods {
    void boring1();

    void boring2();

    void interesting(String arg);

    void boring3();
}

class Implementation implements SomeMethods {
    @Override
    public void boring1() {
        System.out.println("boring1");
    }

    @Override
    public void boring2() {
        System.out.println("boring2");
    }

    @Override
    public void interesting(String arg) {
        System.out.println("interesting " + arg);
    }

    @Override
    public void boring3() {
        System.out.println("boring3");
    }
}

class SelectingMethods {
    public static void main(String[] args) {
        SomeMethods proxy =
                (SomeMethods) Proxy.newProxyInstance(
                        SomeMethods.class.getClassLoader(),
                        new Class[]{ SomeMethods.class },
                        new MethodSelector(new Implementation()));
        proxy.boring1();
        proxy.boring2();
        proxy.interesting("bonobo");
        proxy.boring3();
    }
}
```











## 8. Optional类

> #### `java.util.Optional` 为 `null` 值提供了一个轻量级代理，`Optional` 对象可以防止你的代码直接抛出 `NullPointException`。

> #### `Optional` 最有用武之地的是在那些“更接近数据”的地方，在问题空间中代表实体的对象上。
>
> #### 举个简单的例子，很多系统中都有 `Person` 类型，代码中有些情况下你可能没有一个实际的 `Person` 对象。这时，在传统方法下，你会用到一个 `null` 引用，并且在使用的时候测试它是不是 `null`。而现在，我们可以使用 `Optional`：

```
import onjava.*;
import java.util.*;

class Person {
    public final Optional<String> first;
    public final Optional<String> last;
    public final Optional<String> address;
    // etc.
    public final Boolean empty;

    Person(String first, String last, String address) {
        this.first = Optional.ofNullable(first);
        this.last = Optional.ofNullable(last);
        this.address = Optional.ofNullable(address);
        empty = !this.first.isPresent()
                && !this.last.isPresent()
                && !this.address.isPresent();
    }

    Person(String first, String last) {
        this(first, last, null);
    }

    Person(String last) {
        this(null, last, null);
    }

    Person() {
        this(null, null, null);
    }

    @Override
    public String toString() {
        if (empty)
            return "<Empty>";
        return (first.orElse("") +
                " " + last.orElse("") +
                " " + address.orElse("")).trim();
    }

    public static void main(String[] args) {
        System.out.println(new Person());
        System.out.println(new Person("Smith"));
        System.out.println(new Person("Bob", "Smith"));
        System.out.println(new Person("Bob", "Smith",
                "11 Degree Lane, Frostbite Falls, MN"));
    }
}
```

> #### 如果想使用 `Person`，就必须使用 `Optional` 接口才能访问它的 `String` 字段，这样就不会意外触发 `NullPointException` 了。

### (1) 标记接口

> #### 有时使用一个 ***`标记接口`*** 来表示空值会更方便。标记接口里边什么都没有，你只要把它的名字当做标签来用就可以。

```
public interface Null {}
```

> #### 如果你用接口取代具体类，那么就可以使用 `DynamicProxy` 来自动地创建 `Null` 对象。







### (2) Mock 对象和桩

> #### *`Mock 对象`*和 *`桩（Stub）`*在逻辑上都是 `Optional` 的变体。他们都是最终程序中所使用的“实际”对象的代理。不过，Mock 对象和桩都是假扮成那些可以传递实际信息的实际对象，而不是像 `Optional` 那样把包含潜在 `null` 值的对象隐藏。
>
> #### Mock 对象和桩之间的的差别在于程度不同。
>
> - #### Mock 对象往往是轻量级的，且用于自测试。
>
> - #### 而桩只是返回桩数据，它通常是重量级的，并且经常在多个测试中被复用。桩可以根据它们被调用的方式，通过配置进行修改。因此，桩是一种复杂对象，它可以做很多事情











## 9. 接口和类型

> #### `interface` 关键字的一个重要目标就是允许程序员隔离组件，进而降低耦合度。使用接口可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去 ———— ***`接口并不是对解耦的一种无懈可击的保障`***。

> #### 一种解决方案是直接声明，如果开发者决定使用实际的类而不是接口，他们需要自己对自己负责。

> #### 最简单的方式是让实现类只具有包访问权限，这样在包外部的客户端就看不到它了。但是，通过使用反射，仍然可以调用所有方法，甚至是 `private` 方法！如果知道方法名，你就可以在其 `Method` 对象上调用 `setAccessible(true)` 。
>
> #### 而使用内部 `private` 类和匿名类都不能阻止反射调用那些非公共访问权限的方法。对于字段来说也是这样，即便是 `private` 字段。

> #### 通常，所有这些违反访问权限的操作并不是什么十恶不赦的。如果有人使用这样的技术去调用标志为 `private` 或包访问权限的方法，那么对他们来说，如果你修改了这些方法的某些地方，他们不应该抱怨。另一方面，总是在类中留下后门，也许会帮助你解决某些特定类型的问题（这些问题往往除此之外，别无它法）。总之，不可否认，反射给我们带来了很多好处。











## 10. 本章小结

> #### `RTTI` 允许通过匿名类的引用来获取类型信息。面向对象编程语言是想让我们尽可能地使用多态机制，只在非用不可的时候才使用 `RTTI` 。
>
> #### 如果只是为了方便某个特定的类，就将某个特性放进基类里边，这将使得从那个基类派生出的所有其它子类都带有这些可能毫无意义的东西。这会导致接口更加不清晰，因为我们必须覆盖从基类继承而来的所有抽象方法，事情就变得很麻烦。

> #### 动态代码是将 `Java` 与其它诸如 `C++` 这样的语言区分开的重要工具之一。















# [第二十章 泛型](https://njuics.github.io/OnJava8/#/book/20-Generics?id=第二十章-泛型)

> #### ***`多态`*** 是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。
>
> #### 拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。
>
> #### 如果方法以 ***`接口`*** 而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
>
> #### 即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。

> #### `Java 5` 的重大变化之一，就是引入了泛型的概念。 ***`泛型`*** 实现了 *参数化类型* ，这样你编写的组件（通常是集合）可以适用于多种类型。
>
> #### ***`“泛型”`*** 这个术语的含义是 ***“适用于很多类型”*** 。

## 1. 与 C++ 的比较

> #### `Java` 中的泛型需要与 `C++` 进行对比，理由有两个：
>
> - #### 理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。
>
> - #### 第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。











## 2. 简单泛型

> #### 促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](https://njuics.github.io/OnJava8/#/book/12-Collections) 章节。我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：

```
class Automobile {}

public class Holder1 {
    private Automobile a;
    public Holder1(Automobile a) { this.a = a; }
    Automobile get() { return a; }
}
```

> #### 一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。

> #### ***`类型参数`*** ：用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。

```
public class GenericHolder<T> {
    private T a;
    public GenericHolder() {}
    public void set(T a) { this.a = a; }
    public T get() { return a; }
    
    public static void main(String[] args) {
        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
        h3.set(new Automobile()); // 此处有类型校验
        Automobile a = h3.get();  // 无需类型转换
        //- h3.set("Not an Automobile"); // 报错
        //- h3.set(1);  // 报错
    }
}
```

> #### Java 泛型的核心概念：只需告诉编译器要是用什么类型，剩下的细节交给它来处理。

### (1) 一个元组类库

> #### ***`元组`*** ：将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象(这个概念也称为 *数据传输对象* 或 *信使* )。

> #### 通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。

```
package onjava;

public class Tuple2<A, B> {
    public final A a1;
    public final B a2;
    public Tuple2(A a, B b) { a1 = a; a2 = b; }
    public String rep() { return a1 + ", " + a2; }
  
    @Override
    public String toString() {
        return "(" + rep() + ")";
    }
}
```

> #### 我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：

```
package onjava;

public class Tuple3<A, B, C> extends Tuple2<A, B> {
    public final C a3;
    public Tuple3(A a, B b, C c) {
        super(a, b);
        a3 = c;
    }
    
    @Override
    public String rep() {
        return super.rep() + ", " + a3;
    }
}

package onjava;

public class Tuple4<A, B, C, D>
  extends Tuple3<A, B, C> {
    public final D a4;
    public Tuple4(A a, B b, C c, D d) {
        super(a, b, c);
        a4 = d;
    }
    
    @Override
    public String rep() {
        return super.rep() + ", " + a4;
    }
}

// onjava/Tuple5.java
package onjava;

public class Tuple5<A, B, C, D, E>
  extends Tuple4<A, B, C, D> {
    public final E a5;
    public Tuple5(A a, B b, C c, D d, E e) {
        super(a, b, c, d);
        a5 = e;
    }
    
    @Override
    public String rep() {
        return super.rep() + ", " + a5;
    }
}
import onjava.*;

public class TupleTest {
    static Tuple2<String, Integer> f() {
        return new Tuple2<>("hi", 47);
    }
  
    static Tuple3<Amphibian, String, Integer> g() {
        return new Tuple3<>(new Amphibian(), "hi", 47);
    }
  
    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
    }
  
    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
    }
  
    public static void main(String[] args) {
        Tuple2<String, Integer> ttsi = f();
        System.out.println(ttsi);
        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
        System.out.println(g());
        System.out.println(h());
        System.out.println(k());
    }
}
```







### (2) 一个堆栈类

```
public class LinkedStack<T> {
    private static class Node<U> {
        U item;
        Node<U> next;
    
        Node() { item = null; next = null; }
        
        Node(U item, Node<U> next) {
            this.item = item;
            this.next = next;
        }
    
        boolean end() {
            return item == null && next == null;
        }
    }
  
    private Node<T> top = new Node<>();  // 栈顶
  
    public void push(T item) {
        top = new Node<>(item, top);
    }
  
    public T pop() {
        T result = top.item;
        if (!top.end()) {
            top = top.next;
        }
        return result;
    }
  
    public static void main(String[] args) {
        LinkedStack<String> lss = new LinkedStack<>();
        for (String s : "Phasers on stun!".split(" ")) {
            lss.push(s);
        }
        String s;
        while ((s = lss.pop()) != null) {
            System.out.println(s);
        }
    }
}
```







### (3) RandomList

> #### 作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。

```
import java.util.*;
import java.util.stream.*;

public class RandomList<T> extends ArrayList<T> {
    private Random rand = new Random(47);
  
    public T select() {
        return get(rand.nextInt(size()));
    }
  
    public static void main(String[] args) {
        RandomList<String> rs = new RandomList<>();
        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
        IntStream.range(0, 11).forEach(i -> 
            System.out.print(rs.select() + " "));
    }
}
```











## 3. 泛型接口

> #### ***`泛型`*** 也可以应用于 ***`接口`*** 。例如 *生成器* 。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。

> #### 下面是一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：

```
import java.util.function.*;
import java.util.stream.*;

public class Fibonacci implements Supplier<Integer> {
    private int count = 0;
    @Override
    public Integer get() { return fib(count++); }
  
    private int fib(int n) {
        if(n < 2) return 1;
        return fib(n-2) + fib(n-1);
    }
  
    public static void main(String[] args) {
        Stream.generate(new Fibonacci())
              .limit(18)
              .map(n -> n + " ")
              .forEach(System.out::print);
    }
}
```

> #### 这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便的在基本类型和相应的包装类之间进行转换。

> #### 有多种方法可以实现 ***`适配器`*** 。例如，可以通过继承来创建适配器类：

```
import java.util.*;

public class IterableFibonacci
extends Fibonacci implements Iterable<Integer> {
    private int n;
    public IterableFibonacci(int count) { n = count; }
  
    @Override
    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            @Override
            public boolean hasNext() { return n > 0; }
            @Override
            public Integer next() {
                n--;
                return IterableFibonacci.this.get();
            }
            @Override
            public void remove() { // Not implemented
                throw new UnsupportedOperationException();
            }
        };
    }
  
    public static void main(String[] args) {
        for(int i : new IterableFibonacci(18))
            System.out.print(i + " ");
    }
}
```











## 4. 泛型方法

> #### 我们还可以参数化类中的方法，并且类本身的泛型与否和它的方法泛型与否没有关系。
>
> #### 作为准则，请“尽可能”使用 ***`泛型方法`*** 。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
>
> #### 要定义泛型方法，需要将泛型参数列表放置在返回值之前：

```
public class GenericMethods {
    public <T> void f(T x) {
        System.out.println(x.getClass().getName());
    }

    public static void main(String[] args) {
        GenericMethods gm = new GenericMethods();
        gm.f("");
        gm.f(1);
        gm.f(1.0);
        gm.f(1.0F);
        gm.f('c');
        gm.f(gm);
    }
}
```

> #### 对于泛型类，必须在实例化该类时指定类型参数 ； 使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 ***`类型参数推断`***。
>
> #### 所以这使得泛型方法的调用看起来和普通方法的调用一样。

### (1) 变长参数和泛型方法

> #### 变长参数列表和泛型方法可以很好的共存：

```
import java.util.ArrayList;
import java.util.List;

public class GenericVarargs {
    @SafeVarargs
    public static <T> List<T> makeList(T... args) {
        List<T> result = new ArrayList<>();
        for (T item : args)
            result.add(item);
        return result;
    }

    public static void main(String[] args) {
        List<String> ls = makeList("A");
        System.out.println(ls);
        ls = makeList("A", "B", "C");
        System.out.println(ls);
        ls = makeList(
                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
        System.out.println(ls);
    }
}
```

> #### `@SafeVarargs` 注解 ： 保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。







### (2) 一个泛型的Supplier

```
package onjava;

import java.util.function.Supplier;

public class BasicSupplier<T> implements Supplier<T> {
    private Class<T> type;

    public BasicSupplier(Class<T> type) {
        this.type = type;
    }

    @Override
    public T get() {
        try {
            // Assumes type is a public class:
            return type.newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    // Produce a default Supplier from a type token:
    public static <T> Supplier<T> create(Class<T> type) {
        return new BasicSupplier<>(type);
    }
}
```

> #### 此类提供了产生以下对象的基本实现：
>
> - #### 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
>
> - #### 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。

```
public class CountedObject {
    private static long counter = 0;
    private final long id = counter++;

    public long id() {
        return id;
    }

    @Override
    public String toString() {
        return "CountedObject " + id;
    }
}
```

> #### **CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：

```
import onjava.BasicSupplier;
import java.util.stream.Stream;

public class BasicSupplierDemo {
    public static void main(String[] args) {
        Stream.generate(
                BasicSupplier.create(CountedObject.class))
                .limit(5)
                .forEach(System.out::println);
    }
}
```

> #### 泛型方法减少了产生 `Supplier` 对象所需的代码量。 Java 泛型强制传递 `Class` 对象，以便在 `create()` 方法中将其用于类型推断。







### (3) 简化元组的使用

> #### 使用类型参数推断和静态导入，我们把早期的元组重写为更通用的库。在这里我们使用重载的静态方法创建元组：

```
package onjava;

public class Tuple {
    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
        return new Tuple2<>(a, b);
    }

    public static <A, B, C> Tuple3<A, B, C> tuple(A a, B b, C c) {
        return new Tuple3<>(a, b, c);
    }

    public static <A, B, C, D> Tuple4<A, B, C, D> tuple(A a, B b, C c, D d) {
        return new Tuple4<>(a, b, c, d);
    }

    public static <A, B, C, D, E> Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
        return new Tuple5<>(a, b, c, d, e);
    }
}
```







### (4) 一个 Set 工具

> #### 我们考虑由 Set 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：

```
package onjava;

import java.util.HashSet;
import java.util.Set;

public class Sets {
    public static <T> Set<T> union(Set<T> a, Set<T> b) {
        Set<T> result = new HashSet<>(a);
        result.addAll(b);
        return result;
    }

    public static <T>  Set<T> intersection(Set<T> a, Set<T> b) {
        Set<T> result = new HashSet<>(a);
        result.retainAll(b);
        return result;
    }

    public static <T> Set<T> difference(Set<T> superset, Set<T> subset) {
        Set<T> result = new HashSet<>(superset);
        result.removeAll(subset);
        return result;
    }

    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
        return difference(union(a, b), intersection(a, b));
    }
}
```











## 5. 构建复杂模型

> #### 泛型的一个重要好处就是 ： `能够简单安全地创建复杂模型`

```
import onjava.Tuple4;
import java.util.ArrayList;

public class TupleList<A, B, C, D> extends ArrayList<Tuple4<A, B, C, D>> {
    public static void main(String[] args) {
        TupleList<Vehicle, Amphibian, String, Integer> tl = new TupleList<>();
        tl.add(TupleTest2.h());
        tl.add(TupleTest2.h());
        tl.forEach(System.out::println);
    }
}
```











## 6. 泛型擦除

> #### 当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说 `ArrayList.class`，但不能说成 `ArrayList<Integer>.class` 。

```
import java.util.*;

public class ErasedTypeEquivalence {
    public static void main(String[] args) {
        Class c1 = new ArrayList<String>().getClass();
        Class c2 = new ArrayList<Integer>().getClass();
        System.out.println(c1 == c2);
    } 
}
```

> #### `ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。然而上面的程序认为它们是相同的类型。

```
import java.util.*;

class Frob {}
class Fnorkle {}
class Quark<Q> {}
class Particle<POSITION, MOMENTUM> {}

public class LostInformation {
    public static void main(String[] args) {
        List<Frob> list = new ArrayList<>();
        Map<Frob, Fnorkle> map = new HashMap<>();
        Quark<Fnorkle> quark = new Quark<>();
        Particle<Long, Double> p = new Particle<>();
        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
    }
}
```

> #### 在泛型代码内部，无法获取任何有关泛型参数类型的信息。因此我们可以指导如泛型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。

> #### Java 泛型是使用 ***`擦除`*** 实现的。这意味着当我们在使用这些泛型时，任何具体的类型信息都被擦除了，我们唯一知道的就是我们在使用一个对象。因而 ***`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。***

### (1) C++ 的方式

> #### 下面是使用模板的 `C++` 示例，其与类型参数的语法十分相似，因为 `Java` 是受 `C++` 启发的：

```
#include <iostream>
using namespace std;

template<class T> class Manipulator {
    T obj;
public:
    Manipulator(T x) { obj = x; }
    void manipulate() { obj.f(); }
};

class HasF {
public:
    void f() { cout << "HasF::f()" << endl; }
};

int main() {
    HasF hf;
    Manipulator<HasF> manipulator(hf);
    manipulator.manipulate();
}
```

> #### C++ 编译器会在实例化模板是进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 `HasF` 中含有一个方法 `f()` 。如果情况并非如此则会产生一个编译期错误，以保证类型安全。

> #### 所以使用 C++ 编写代码时，当模板被实例化时，模板代码就知道模板参数的类型。而 Java 泛型则不同：

```
public class HasF {
    public void f() {
        System.out.println("HasF.f()");
    }
}
class Manipulator<T> {
    private T obj;
    
    Manipulator(T x) {
        obj = x;
    }
    
    // Error: cannot find symbol: method f():
    public void manipulate() {
        obj.f();
    }
}

public class Manipulation {
    public static void main(String[] args) {
        HasF hf = new HasF();
        Manipulator<HasF> manipulator = new Manipulator<>(hf);
        manipulator.manipulate();
    }
}
```

> #### 因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 `obj` 的 `f()` 方法 这一需求映射到 *`HasF` 具有 `f()` 方法* 这个事实上。
>
> #### 所以为了调用 `f()` ，我们必须协助泛型类，使用 `extend` 关键字给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。

```
public class Manipulator2<T extends HasF> {
    private T obj;

    Manipulator2(T x) {
        obj = x;
    }

    public void manipulate() {
        obj.f();
    }
}
```

> #### ***`泛型`*** 只有在类型参数比某个具体类型(及其子类)更加泛化 ———— 代码能跨多个类工作 时才有用。







### (2) 迁移兼容性

> #### ***`擦除`*** 不是一个语言特性，它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。擦除减少了泛型的泛化性，这使得泛型在 Java 中不如他们本来设想的那么有用。

> #### ***`泛型类型`*** 不能在某些重要的上下文中使用。泛型类型只有在静态类型检测期间才出现，在此之后，程序中所有泛型类型都将被擦除到它的非泛型上界。
>
> #### 擦除的核心动机是 我们可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称之为 ***`“迁移兼容性”`*** 。
>
> #### Java 泛型不仅必须支持 `向后兼容性`，还必须支持 `迁移兼容性` ，使得类库能按照它们自己的步调变为泛型，当某个类库变成泛型时，不会破坏依赖于它的代码和应用。而 ***`擦除`*** 则成为了唯一可行的解决方案，擦除使得这种向泛型的迁移成为可能，允许非泛型代码和泛型代码共存。







### (3) 擦除的问题

> #### 擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。
>
> #### 擦除的代码是显著的。泛型不能用于显式地引用 运行时类型 的操作中，例如转型、instanceof、new。因为所有关于参数的类型信息都丢失了。







### (4) 边界处的动作

> #### 因为擦除，泛型最令人困惑的方面是可以表示没有任何意义的事物。

```
import java.lang.reflect.*;
import java.util.*;

public class ArrayMaker<T> {
    private Class<T> kind;

    public ArrayMaker(Class<T> kind) {
        this.kind = kind;
    }

    @SuppressWarnings("unchecked")
    T[] create(int size) {
        return (T[]) Array.newInstance(kind, size);
    }

    public static void main(String[] args) {
        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
        String[] stringArray = stringMaker.create(9);
        System.out.println(Arrays.toString(stringArray));
    }
}
```

> #### 虽然 `kind` 被存储为 `Class<T>` ，擦除也会使得它被存储为没有任何参数的 `Class` 。因此当我们使用它创建数组 ———— `Array.newInstance()` ，实际上并未拥有 `kind` 所蕴含的类型信息，因为该数组必须强制转型，这会产生一条警告。

> #### 因为擦除移除了方法体中的类型信息，所以在运行时的问题就是 *边界* ：即对象进入和离开方法的地点。这些事编译器在编译器执行类型检查并插入转型代码的地点。

> #### 记住： ***`“边界就是动作发生的地方”`***











## 7. 补偿擦除

> #### 因为擦除，我们将失去执行泛型代码中某些操作的能力，无法在运行时知道确切类型：

```
public class Erased<T> {
    private final int SIZE = 100;

    public void f(Object arg) {
        if (arg instanceof T) {} // error: illegal generic type for instanceof
        T var = new T();		// error: unexpected type
        T[] array = new T[SIZE];	// error: generic array creation
        T[] array = (T[]) new Object[SIZE];  // warning: [unchecked] unchecked cast
    }
}
```

> #### 例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：

```
class Building {}

class House extends Building {}

public class ClassTypeCapture<T> {
    Class<T> kind;

    public ClassTypeCapture(Class<T> kind) {
        this.kind = kind;
    }

    public boolean f(Object arg) {
        return kind.isInstance(arg);
    }

    public static void main(String[] args) {
        ClassTypeCapture<Building> ctt1 = new ClassTypeCapture<>(Building.class);
        System.out.println(ctt1.f(new Building()));
        System.out.println(ctt1.f(new House()));
        ClassTypeCapture<House> ctt2 = new ClassTypeCapture<>(House.class);
        System.out.println(ctt2.f(new Building()));
        System.out.println(ctt2.f(new House()));
    }
}
```

### (1) 创建类型的实例

> #### 在泛型代码中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 `Class` 对象，因此如果使用类型标记，则可使用 `newInstance()` 创建该类型的新对象：

```
import java.util.function.Supplier;

class ClassAsFactory<T> implements Supplier<T> {
    Class<T> kind;

    ClassAsFactory(Class<T> kind) {
        this.kind = kind;
    }

    @Override
    public T get() {
        try {
            return kind.newInstance();
        } catch (InstantiationException |
                IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
}

class Employee {
    @Override
    public String toString() {
        return "Employee";
    }
}

public class InstantiateGenericType {
    public static void main(String[] args) {
        ClassAsFactory<Employee> fe =
                new ClassAsFactory<>(Employee.class);
        System.out.println(fe.get());
        ClassAsFactory<Integer> fi =
                new ClassAsFactory<>(Integer.class);
        try {
            System.out.println(fi.get());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
```

> #### 上述代码可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 Integer 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创造者不赞成这种方法。
>
> #### 他们建议使用显示工厂(Supplier)并约束类型，以便只有实现该工厂的类可以这样创建对象：

> #### 另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：

```
abstract class GenericWithCreate<T> {
    final T element;

    GenericWithCreate() {
        element = create();
    }

    abstract T create();
}

class X {}

class XCreator extends GenericWithCreate<X> {
    @Override
    X create() {
        return new X();
    }

    void f() {
        System.out.println(element.getClass().getSimpleName());
    }
}

public class CreatorGeneric {
    public static void main(String[] args) {
        XCreator xc = new XCreator();
        xc.f();
    }
}
```







### (2) 泛型数组

> #### 我们无法创建泛型数组，通用的解决方案是在试图创建泛型数组的时候使用 `ArrayList` ：

```
import java.util.ArrayList;
import java.util.List;

public class ListOfGenerics<T> {
    private List<T> array = new ArrayList<>();

    public void add(T item) {
        array.add(item);
    }

    public T get(int index) {
        return array.get(index);
    }
}
```

> #### 有时仍然会创建泛型类型的数组。可以通过使编译器满意的方式定义对数组的通用引用：

```
class Generic<T> {}

public class ArrayOfGenericReference {
    static Generic<Integer>[] gia;
}
```

> #### 编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组。
>
> #### 由于所有数组都具有相同的结构，因此似乎可以创建一个 `Object` 数组并将其转换为所需的数组类型。实际上这确实可以编译，但会产生 `ClassCastExcepetion` ：

```
public class ArrayOfGeneric {
    static final int SIZE = 100;
    static Generic<Integer>[] gia;

    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        try {
            gia = (Generic<Integer>[]) new Object[SIZE];
        } catch (ClassCastException e) {
            System.out.println(e.getMessage());
        }
        // Runtime type is the raw (erased) type:
        gia = (Generic<Integer>[]) new Generic[SIZE];
        System.out.println(gia.getClass().getSimpleName());
        gia[0] = new Generic<>();
        //- gia[1] = new Object(); // Compile-time error
        // Discovers type mismatch at compile time:
        //- gia[2] = new Generic<Double>();
    }
}
```

> #### 问题在于数组会追踪其实际类型，而该类型是在创建数组是建立的。
>
> #### 成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。

```
public class GenericArray<T> {
    private T[] array;

    @SuppressWarnings("unchecked")
    public GenericArray(int sz) {
        array = (T[]) new Object[sz];
    }

    public void put(int index, T item) {
        array[index] = item;
    }

    public T get(int index) {
        return array[index];
    }

    // Method that exposes the underlying representation:
    public T[] rep() {
        return array;
    }

    public static void main(String[] args) {
        GenericArray<Integer> gai = new GenericArray<>(10);
        try {
            Integer[] ia = gai.rep();
        } catch (ClassCastException e) {
            System.out.println(e.getMessage());
        }
        // This is OK:
        Object[] oa = gai.rep();
    }
}
```

> #### `rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]` ，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **`ClassCastException`** ，这再次是因为实际的运行时类型为 `Object[]` 。

> #### 由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。

```
public class GenericArray2<T> {
    private Object[] array;

    public GenericArray2(int sz) {
        array = new Object[sz];
    }

    public void put(int index, T item) {
        array[index] = item;
    }

    @SuppressWarnings("unchecked")
    public T get(int index) {
        return (T) array[index];
    }

    @SuppressWarnings("unchecked")
    public T[] rep() {
        return (T[]) array; // Unchecked cast
    }

    public static void main(String[] args) {
        GenericArray2<Integer> gai =
                new GenericArray2<>(10);
        for (int i = 0; i < 10; i++)
            gai.put(i, i);
        for (int i = 0; i < 10; i++)
            System.out.print(gai.get(i) + " ");
        System.out.println();
        try {
            Integer[] ia = gai.rep();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
```

> #### 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。
>
> #### 在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入bug，尽管大多数此类错误会在运行时被迅速检测到。

> #### 然而不幸的是，如果查看 Java 标准库中的源代码，会发现导出都有从 Object 数组到参数化类型的转换。











## 8. 边界

> #### ***`边界`*** 允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。

> #### 为了应用约束，Java 泛型使用了 `extends` 关键字。
>
> #### 重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。

```
import java.util.List;

interface SuperPower {
}

interface XRayVision extends SuperPower {
    void seeThroughWalls();
}

interface SuperHearing extends SuperPower {
    void hearSubtleNoises();
}

interface SuperSmell extends SuperPower {
    void trackBySmell();
}

class SuperHero<POWER extends SuperPower> {
    POWER power;

    SuperHero(POWER power) {
        this.power = power;
    }

    POWER getPower() {
        return power;
    }
}

class SuperSleuth<POWER extends XRayVision>
        extends SuperHero<POWER> {
    SuperSleuth(POWER power) {
        super(power);
    }

    void see() {
        power.seeThroughWalls();
    }
}

class
CanineHero<POWER extends SuperHearing & SuperSmell>
        extends SuperHero<POWER> {
    CanineHero(POWER power) {
        super(power);
    }

    void hear() {
        power.hearSubtleNoises();
    }

    void smell() {
        power.trackBySmell();
    }
}

class SuperHearSmell
        implements SuperHearing, SuperSmell {
    @Override
    public void hearSubtleNoises() {
    }

    @Override
    public void trackBySmell() {
    }
}

class DogPerson extends CanineHero<SuperHearSmell> {
    DogPerson() {
        super(new SuperHearSmell());
    }
}

public class EpicBattle {
    // Bounds in generic methods:
    static <POWER extends SuperHearing>
    void useSuperHearing(SuperHero<POWER> hero) {
        hero.getPower().hearSubtleNoises();
    }

    static <POWER extends SuperHearing & SuperSmell>
    void superFind(SuperHero<POWER> hero) {
        hero.getPower().hearSubtleNoises();
        hero.getPower().trackBySmell();
    }

    public static void main(String[] args) {
        DogPerson dogPerson = new DogPerson();
        useSuperHearing(dogPerson);
        superFind(dogPerson);
        // You can do this:
        List<? extends SuperHearing> audioPeople;
        // But you can't do this:
        // List<? extends SuperHearing & SuperSmell> dogPs;
    }
}
```











## 9. 通配符

> #### 我们可以将派生类的数组赋值给基类的引用：

```
class Fruit {}

class Apple extends Fruit {}

class Jonathan extends Apple {}

class Orange extends Fruit {}

public class CovariantArrays {
    
    public static void main(String[] args) {
        Fruit[] fruit = new Apple[10];
        fruit[0] = new Apple(); // OK
        fruit[1] = new Jonathan(); // OK
        // Runtime type is Apple[], not Fruit[] or Orange[]:
        try {
            // Compiler allows you to add Fruit:
            fruit[0] = new Fruit(); // ArrayStoreException
        } catch (Exception e) {
            System.out.println(e);
        }
        try {
            // Compiler allows you to add Oranges:
            fruit[0] = new Orange(); // ArrayStoreException
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
```

> #### 在编译时都是允许的，但是运行时的数组机制知道它处理的是 **Apple[]** ，因此会在向数组中放置异构类型时抛出异常。

> #### 数组的这种赋值并不是那么可怕，因为在运行时我们可以发现插入了错误的类型。但是泛型的主要目标之一是 ***将这种错误检测移到编译期*** 。所以当我们试图使用泛型集合代替数组时，会发生什么呢？

```
import java.util.*;

public class NonCovariantGenerics {
    // Compile Error: incompatible types:
    List<Fruit> flist = new ArrayList<Apple>();
}
```

> #### 这段代码真正要表达的是： ***`“不能把一个涉及 Apple 的泛型赋值给一个涉及 Fruit 的泛型”`*** 。编译器不知道任何有关代码所涉及到的集合的信息，因此它拒绝向上转型，而且实际上这也不是向上转型 ———— ***`Apple 的 List 不是 Fruit 的List`*** 。 ***Apple 的 List 在类型上不等价于 Fruit 的 List，即使 Apple 是一种 Fruit 类型*** 。

> #### 与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但在使用泛型时，编译器和运行时系统不知道我们想用泛型做什么，以及该采用什么样的规则。
>
> #### 但是通配符可以在 两个类间 建立某种向上转型关系：

```
import java.util.*;

public class GenericsAndCovariance {
    
    public static void main(String[] args) {
        List<? extends Fruit> flist = new ArrayList<>();
        // Compile Error: can't add any type of object:
        // flist.add(new Apple());
        // flist.add(new Fruit());
        // flist.add(new Object());
        flist.add(null); // Legal but uninteresting
        // We know it returns at least Fruit:
        Fruit f = flist.get(0);
    }
    
}
```

> #### `List<? extends Fruit>` 可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。
>
> #### `List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
>
> #### 另一方面，如果调用了一个返回 `Fruit` 的方法，则是安全的，因为我们知道这个 `List` 中的任何对象至少具有 `Fruit` 类型，因此编译器允许这么做。

### (1) 编译器有多聪明

```
import java.util.*;

public class CompilerIntelligence {
    
    public static void main(String[] args) {
        List<? extends Fruit> flist = Arrays.asList(new Apple());
        Apple a = (Apple) flist.get(0); // No warning
        flist.contains(new Apple()); // Argument is 'Object'
        flist.indexOf(new Apple()); // Argument is 'Object'
    }
}
```

> #### 编译器没有那么聪明，`add()` 接受一个 ***泛型参数类型的参数*** ， `contains()` 和 `indexOf()` 接受的参数类型是 ***Object***。
>
> #### 所以当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了 `"? extends Fruit"` 。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。
>
> #### `contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。

> #### 如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。







### (2) 逆变

> #### 可以使用超类型通配符来声明通配符是由某个特定类的任何基类来界定的，方法是指定  `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>` 。

```
import java.util.*;
public class SuperTypeWildcards {
    static void writeTo(List<? super Apple> apples) {
        apples.add(new Apple());
        apples.add(new Jonathan());
        // apples.add(new Fruit()); // Error
    }
}
```

> #### 参数 **`apples`** 是 **`Apple`** 的某种基类型的 **`List`**，这样你就知道向其中添加 **`Apple`** 或 **`Apple`** 的子类型是安全的。是因为 **`Apple`** 是下界，所以你知道向这样的 **`List`** 中添加 **`Fruit`** 是不安全的。







### (3) 无界通配符

> #### 无界通配符 `<?>` 实际上是在声明：***“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”***
>
> #### 无界通配符的一个重要应用是，当我们在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其它参数确定某种特定类型的这种能力会显得很重要。

> #### 令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。 事实上，因为泛型参数擦除到它的第一个边界，所以`List<?>` 看起来等价于 `List<Object>` ，而 **`List`** 实际上也是 `List<Object>` 。
>
> - #### `List` 实际上表示 “持有任何 Object 类型的原生 List”
>
> - #### `List<?>` 表示 “具有某种特定类型的非原生 List ，只是我们不知道类型是什么”







### (4) 捕获转换

> #### 如果向一个使用 `<?>` 的方法传递原生类型，那么编译器可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。这种技术被称为 ***`捕获转换`*** ，因为位置的的通配符类型被捕获，并被转换为确切类型：

```
public class CaptureConversion {
    static <T> void f1(Holder<T> holder) {
        T t = holder.get();
        System.out.println(t.getClass().getSimpleName());
    }
  
    static void f2(Holder<?> holder) { // 在调用 f2() 的过程中捕获了参数类型，并在调用 f1() 时使用了这种类型。
        f1(holder); // Call with captured type
    }
    
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        Holder raw = new Holder<>(1);
        f1(raw); // warning: [unchecked] unchecked method invocation:
        f2(raw); // No warnings
        
        Holder rawBasic = new Holder();
        rawBasic.set(new Object()); // warning: [unchecked] unchecked call to set(T) as a member of the raw type Holder
        f2(rawBasic); // No warnings
        
        // Upcast to Holder<?>, still figures it out:
        Holder<?> wildcarded = new Holder<>(1.0);
        f2(wildcarded);
    }
}
```

> #### ***`捕获转换`*** 只有在这样的情况下才可以工作：在方法内部且需要使用确切的类型。   捕获转换十分有趣但非常受限。











## 10. 问题

### (1) 任何基本类型都不能作为类型参数

> #### 因此不能创建 `ArrayList<int>` 之类的东西。解决方法是使用基本类型的包装器类以及自动装箱机制。
>
> #### 自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **`org.apache.commons.collections.primitives`** 。
>
> #### 自动装箱不适用于数组。







### (2) 实现参数化接口

> #### 一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口：

```
package generics;

interface Payable<T> {}

class Employee implements Payable<Employee> {}

class Hourly extends Employee implements Payable<Hourly> {}
```

> #### **Hourly** 不能编译，因为擦除会将 `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。







### (3) 转型和警告

> #### 使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。

```
import java.util.*;
import java.util.stream.*;

class FixedSizeStack<T> {
    private final int size;
    private Object[] storage;
    private int index = 0;
    
    FixedSizeStack(int size) {
        this.size = size;
        storage = new Object[size];
    }
    
    public void push(T item) {
        if(index < size)
            storage[index++] = item;
    }
    
    @SuppressWarnings("unchecked")
    public T pop() {
        return index == 0 ? null : (T)storage[--index];
    }
    
    @SuppressWarnings("unchecked")
    Stream<T> stream() {
        return (Stream<T>)Arrays.stream(storage);
    }
}

public class GenericCast {
    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
  
    public static void main(String[] args) {
        FixedSizeStack<String> strings = new FixedSizeStack<>(letters.length);
        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
              .forEach(strings::push);
        System.out.println(strings.pop());
        strings.stream()
            .map(s -> s + " ")
            .forEach(System.out::print);
    }
}
```

> #### `pop()` 方法实际上并没有执行任何转型，这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。 







### (4) 重载

> #### 下面的程序是不能编译的，即使它看起来是合理的：

```
import java.util.*;

public class UseList<W, T> {
    void f(List<T> v) {}
    void f(List<W> v) {}
}
```

> #### 因为擦除，所以重载方法产生了相同的类型签名。







### (5) 基类劫持接口

```
public class ComparablePet implements Comparable<ComparablePet> {
    @Override
    public int compareTo(ComparablePet o) {
        return 0;
    }
}
class Cat extends ComparablePet implements Comparable<Cat> {
    // error: Comparable cannot be inherited with
    // different arguments: <Cat> and <ComparablePet>
    // class Cat
    // ^
    // 1 error
    public int compareTo(Cat arg) {
        return 0;
    }
}
```

> #### 一旦 **`Comparable`** 的类型参数设置为 **`ComparablePet`** ，其他的实现类只能比较 **`ComparablePet`**：

```
public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
    @Override
    public int compareTo(ComparablePet arg) {
        return 0;
    }
}
// Or just:
class Gecko extends ComparablePet {
    public int compareTo(ComparablePet arg) {
        return 0;
    }
}
```

> #### **`Hamster`** 显示了重新实现 **`ComparablePet`** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **`Gecko`** 中所示，这与直接覆写基类的方法完全相同。











## 11. 自限定的类型

```
class SelfBounded<T extends SelfBounded<T>> { // ...
```

> #### 这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。当你首次看到它时，很难去解析它，它强调的是当 `extend` 关键字 ***用于边界*** 与 ***用来创建子类*** 明显是不同的。

### (1) 古怪的循环泛型

> #### 不能直接继承一个泛型参数，但是可以继承在其自己的定义中使用这个泛型参数的类：

```
class GenericType<T> {}

public class CuriouslyRecurringGeneric
  extends GenericType<CuriouslyRecurringGeneric> {}
```

> #### “古怪的循环” 是指类相当古怪地出现在它自己的基类中这一事实。即 “我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为参数。”
>
> #### 我们可以在一个古怪的循环泛型中使用 `BasicHolder` ：

```
class Subtype extends BasicHolder<Subtype> {}

public class CRGWithBasicHolder {
    public static void main(String[] args) {
        Subtype st1 = new Subtype(), st2 = new Subtype();
        st1.set(st2);
        Subtype st3 = st1.get();
        st1.f();
    }
}
```







### (2) 自限定

> #### **`BasicHolder`** 可以使用任何类型作为其泛型参数，就像下面看到的那样：

```
class Other {}
class BasicOther extends BasicHolder<Other> {}

public class Unconstrained {
    public static void main(String[] args) {
        BasicOther b = new BasicOther();
        BasicOther b2 = new BasicOther();
        b.set(new Other());
        Other other = b.get();
        b.f();
    }
}
```

> #### 自限定所做的，就是要求在继承关系中，像下面这样使用这个类：

```
class A extends SelfBounded<A>{}
```

> #### 这会强制要求将正在定义的类作为参数传递给基类。
>
> #### 自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。
>
> #### 自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。







### (3) 参数协变

> #### 自限定类型的价值在于它们可以产生 *`协变参数类型`* ———— 方法参数类型会随子类而变化。

> #### ***`协变返回类型`*** 如下：

```
class Base {}
class Derived extends Base {}

interface OrdinaryGetter {
    Base get();
}

interface DerivedGetter extends OrdinaryGetter {
    // Overridden method return type can vary:
    @Override
    Derived get();
}

public class CovariantReturnTypes {
    void test(DerivedGetter d) {
        Derived d2 = d.get();
    }
}
```

> #### 自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中看到的一样：

```
interface GenericGetter<T extends GenericGetter<T>> {
    T get();
}

interface Getter extends GenericGetter<Getter> {}

public class GenericsAndReturnTypes {
    void test(Getter g) {
        Getter result = g.get();
        GenericGetter gg = g.get(); // Also the base type
    }
}
```

> #### 注意，这段代码不能编译，除非是使用囊括了协变返回类型的 `Java 5`。然而，在非泛型代码中，参数类型不能随子类型发生变化：

```
class OrdinarySetter {
    void set(Base base) {
        System.out.println("OrdinarySetter.set(Base)");
    }
}

class DerivedSetter extends OrdinarySetter {
    void set(Derived derived) {
        System.out.println("DerivedSetter.set(Derived)");
    }
}

public class OrdinaryArguments {
    public static void main(String[] args) {
        Base base = new Base();
        Derived derived = new Derived();
        DerivedSetter ds = new DerivedSetter();
        ds.set(derived);
        // Compiles--overloaded, not overridden!:
        ds.set(base);
    }
}
```

> #### `set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。

#### (略)









## 12. 动态类型安全

> #### 因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。

> #### 受检查的集合在你试图插入类型不正确的对象时抛出 **`ClassCastException`** ，这与泛型之前的（原生）集合形成了对比。
>
> #### 对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。











## 13. 泛型异常

> #### 由于擦除的原因，`catch` 语句不能捕获泛型类型的异常。
>
> - #### 因为在编译期和运行时都必须知道异常的确切类型。
>
> - #### 泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
>
> #### 但我们可以编写随检查型异常类型变化的泛型代码：

```
import java.util.*;

interface Processor<T, E extends Exception> {
    void process(List<T> resultCollector) throws E;
}

class ProcessRunner<T, E extends Exception>
extends ArrayList<Processor<T, E>> {
    List<T> processAll() throws E {
        List<T> resultCollector = new ArrayList<>();
        for(Processor<T, E> processor : this)
            processor.process(resultCollector);
        return resultCollector;
    }
}

class Failure1 extends Exception {}

class Processor1
implements Processor<String, Failure1> {
    static int count = 3;
    @Override
    public void process(List<String> resultCollector)
    throws Failure1 {
        if(count-- > 1)
            resultCollector.add("Hep!");
        else
            resultCollector.add("Ho!");
        if(count < 0)
            throw new Failure1();
    }
}

class Failure2 extends Exception {}

class Processor2
implements Processor<Integer, Failure2> {
    static int count = 2;
    @Override
    public void process(List<Integer> resultCollector)
    throws Failure2 {
        if(count-- == 0)
            resultCollector.add(47);
        else {
            resultCollector.add(11);
        }
        if(count < 0)
            throw new Failure2();
    }
}

public class ThrowGenericException {
    public static void main(String[] args) {
        ProcessRunner<String, Failure1> runner =
            new ProcessRunner<>();
        for(int i = 0; i < 3; i++)
            runner.add(new Processor1());
        try {
            System.out.println(runner.processAll());
        } catch(Failure1 e) {
            System.out.println(e);
        }

        ProcessRunner<Integer, Failure2> runner2 =
            new ProcessRunner<>();
        for(int i = 0; i < 3; i++)
            runner2.add(new Processor2());
        try {
            System.out.println(runner2.processAll());
        } catch(Failure2 e) {
            System.out.println(e);
        }
    }
}
/* Output:
[Hep!, Hep!, Ho!]
Failure2
*/
```

> #### **`Processor`** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**`ProcessRunner`** 有一个 `processAll()` 方法，它会在所持有的每个 **`Process`** 对象执行，并返回 **`resultCollector`** 。 如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。











## 14. 混型

> #### ***`混型`*** 的最基本概念是 ***混合多个类的能力，以产生一个可以表示混型中所有类型的类*** 。它将使组装多个类变得简单易行。混型的价值之一是它们 ***可以将特性和行为一致地应用于多个类之上*** 。

### (1) C++ 中的混型

> #### C++ 使用多重继承的最大理由就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为 ***`混型就是继承自其类型参数的类`*** 。

```
#include <string>
#include <ctime>
#include <iostream>
using namespace std;

template<class T> class TimeStamped : public T {
    long timeStamp;
public:
    TimeStamped() { timeStamp = time(0); }
    long getStamp() { return timeStamp; }
};

template<class T> class SerialNumbered : public T {
    long serialNumber;
    static long counter;
public:
    SerialNumbered() { serialNumber = counter++; }
    long getSerialNumber() { return serialNumber; }
};

// Define and initialize the static storage:
template<class T> long SerialNumbered<T>::counter = 1;

class Basic {
    string value;
public:
    void set(string val) { value = val; }
    string get() { return value; }
};

int main() {
    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
    mixin1.set("test string 1");
    mixin2.set("test string 2");
    cout << mixin1.get() << " " << mixin1.getStamp() <<
      " " << mixin1.getSerialNumber() << endl;
    cout << mixin2.get() << " " << mixin2.getStamp() <<
      " " << mixin2.getSerialNumber() << endl;
}
/* Output:
test string 1 1452987605 1
test string 2 1452987605 2
*/
```

> #### 泛型类不能直接继承自一个泛型参数







### (2) 与接口混合

> #### 一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：

```
import java.util.*;

interface TimeStamped { long getStamp(); }

class TimeStampedImp implements TimeStamped {
    private final long timeStamp;
    TimeStampedImp() {
        timeStamp = new Date().getTime();
    }
    @Override
    public long getStamp() { return timeStamp; }
}

interface SerialNumbered { long getSerialNumber(); }

class SerialNumberedImp implements SerialNumbered {
    private static long counter = 1;
    private final long serialNumber = counter++;
    @Override
    public long getSerialNumber() { return serialNumber; }
}

interface Basic {
    void set(String val);
    String get();
}

class BasicImp implements Basic {
    private String value;
    @Override
    public void set(String val) { value = val; }
    @Override
    public String get() { return value; }
}

class Mixin extends BasicImp
implements TimeStamped, SerialNumbered {
    private TimeStamped timeStamp = new TimeStampedImp();
    private SerialNumbered serialNumber =
        new SerialNumberedImp();
    @Override
    public long getStamp() {
        return timeStamp.getStamp();
    }
    @Override
    public long getSerialNumber() {
        return serialNumber.getSerialNumber();
    }
}

public class Mixins {
    public static void main(String[] args) {
        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
        mixin1.set("test string 1");
        mixin2.set("test string 2");
        System.out.println(mixin1.get() + " " +
            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
        System.out.println(mixin2.get() + " " +
            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
    }
}
/* Output:
test string 1 1494331663026 1
test string 2 1494331663027 2
*/
```







### (3) 使用装饰器模式

> #### 混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
>
> #### 前面的示例可以被改写为使用装饰器：

```
package generics.decorator;
import java.util.*;

class Basic {
    private String value;
    public void set(String val) { value = val; }
    public String get() { return value; }
}

class Decorator extends Basic {
    protected Basic basic;
    Decorator(Basic basic) { this.basic = basic; }
    @Override
    public void set(String val) { basic.set(val); }
    @Override
    public String get() { return basic.get(); }
}

class TimeStamped extends Decorator {
    private final long timeStamp;
    TimeStamped(Basic basic) {
        super(basic);
        timeStamp = new Date().getTime();
    }
    public long getStamp() { return timeStamp; }
}

class SerialNumbered extends Decorator {
    private static long counter = 1;
    private final long serialNumber = counter++;
    SerialNumbered(Basic basic) { super(basic); }
    public long getSerialNumber() { return serialNumber; }
}

public class Decoration {
    public static void main(String[] args) {
        TimeStamped t = new TimeStamped(new Basic());
        TimeStamped t2 = new TimeStamped(
            new SerialNumbered(new Basic()));
        //- t2.getSerialNumber(); // Not available
        SerialNumbered s = new SerialNumbered(new Basic());
        SerialNumbered s2 = new SerialNumbered(
            new TimeStamped(new Basic()));
        //- s2.getStamp(); // Not available
  }
}
```







### (4) 与动态代理混合

> #### 可以使用 ***`动态代理`*** 来创建一种比装饰器更贴近混型模型的机制。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
>
> #### 由于动态代理的限制，每个被混入的类都必须是某个接口的实现：

```
import java.lang.reflect.*;
import java.util.*;
import onjava.*;
import static onjava.Tuple.*;

class MixinProxy implements InvocationHandler {
    Map<String, Object> delegatesByMethod;
    @SuppressWarnings("unchecked")
    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
        delegatesByMethod = new HashMap<>();
        for(Tuple2<Object, Class<?>> pair : pairs) {
            for(Method method : pair.a2.getMethods()) {
                String methodName = method.getName();
                // The first interface in the map
                // implements the method.
                if(!delegatesByMethod.containsKey(methodName))
                    delegatesByMethod.put(methodName, pair.a1);
            }
        }
    }
    @Override
    public Object invoke(Object proxy, Method method,
      Object[] args) throws Throwable {
        String methodName = method.getName();
        Object delegate = delegatesByMethod.get(methodName);
        return method.invoke(delegate, args);
    }
    
    @SuppressWarnings("unchecked")
    public static Object newInstance(Tuple2... pairs) {
        Class[] interfaces = new Class[pairs.length];
        for(int i = 0; i < pairs.length; i++) {
            interfaces[i] = (Class)pairs[i].a2;
        }
        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
    }
}

public class DynamicProxyMixin {
    public static void main(String[] args) {
        Object mixin = MixinProxy.newInstance(
          tuple(new BasicImp(), Basic.class),
          tuple(new TimeStampedImp(), TimeStamped.class),
          tuple(new SerialNumberedImp(), SerialNumbered.class));
        Basic b = (Basic)mixin;
        TimeStamped t = (TimeStamped)mixin;
        SerialNumbered s = (SerialNumbered)mixin;
        b.set("Hello");
        System.out.println(b.get());
        System.out.println(t.getStamp());
        System.out.println(s.getSerialNumber());
    }
}
/* Output:
Hello
1494331653339
1
*/
```











## 15. 潜在类型机制

> #### “持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
>
> #### 当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。
>
> #### 在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。

> #### ***`潜在类型机制`*** 或 ***`结构化类型机制`*** ，更古怪的术语称为 ***`鸭子类型机制`*** ，即 ***“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”***
>
> #### 泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集而不是某个特定类或接口，从而放松了这种限制。
>
> #### 这使得 ***潜在类型机制\*** 可以横跨类继承接口，调用不属于某个公共接口的方法。因此我们可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”

> #### 潜在类型机制的语言包括 Python、C++、Ruby、SmallTalk、Go。潜在类型机制不要求静态或动态类型检查。

### (1) Python 中的潜在类型

```
class Dog:
    def speak(self):
        print("Arf!")
    def sit(self):
        print("Sitting")
    def reproduce(self):
        pass

class Robot:
    def speak(self):
        print("Click!")
    def sit(self):
        print("Clank!")
    def oilChange(self):
        pass

def perform(anything):
    anything.speak()
    anything.sit()

a = Dog()
b = Robot()
perform(a)
perform(b)
```

> #### `perform(anything)` 中，没有任何针对 **`anything`** 的类型，**`anything`** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口 ———— 它是潜在的。
>
> #### `perform()` 不关心其参数的类型，因此我可以向它传递任何对象，***只要该对象支持 `speak()` 和 `sit()` 方法。***如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。







### (2) C++中的潜在类型

```
#include <iostream>
using namespace std;

class Dog {
public:
    void speak() { cout << "Arf!" << endl; }
    void sit() { cout << "Sitting" << endl; }
    void reproduce() {}
};

class Robot {
public:
    void speak() { cout << "Click!" << endl; }
    void sit() { cout << "Clank!" << endl; }
    void oilChange() {}
};

template<class T> void perform(T anything) {
    anything.speak();
    anything.sit();
}

int main() {
    Dog d;
    Robot r;
    perform(d);
    perform(r);
}
```

> #### 从类型的观点来看，`Dog` 和 `Robot` 是完全不同的类型。但是 `perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
>
> #### C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息。
>
> #### C++ 在编译器，Python 在运行时实现了潜在类型机制，但这两种语言都可以确保类型不会被误用，因此被认为是 `强类型` 的。潜在类型机制没有损害强类型机制。







### (3) Go 中的潜在类型

```
package main
import "fmt"

type Dog struct {}
func (this Dog) speak() { fmt.Printf("Arf!\n")}
func (this Dog) sit() { fmt.Printf("Sitting\n")}
func (this Dog) reproduce() {}

type Robot struct {}
func (this Robot) speak() { fmt.Printf("Click!\n") }
func (this Robot) sit() { fmt.Printf("Clank!\n") }
func (this Robot) oilChange() {}

func perform(speaker interface { speak(); sit() }) {
  speaker.speak();
  speaker.sit();
}

func main() {
  perform(Dog{})
  perform(Robot{})
}
```

> #### `perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和 `sit()` 方法即可。 该接口在此处匿名定义，内联。







### (4) Java 中的直接潜在类型

> #### Java 没有对潜在类型机制这种特性的支持。

```
public interface Performs {
    void speak();
    void sit();
}
import typeinfo.pets.*;

class PerformingDog extends Dog implements Performs {
    @Override
    public void speak() { System.out.println("Woof!"); }
    @Override
    public void sit() { System.out.println("Sitting"); }
    public void reproduce() {}
}

class Robot implements Performs {
    public void speak() { System.out.println("Click!"); }
    public void sit() { System.out.println("Clank!"); }
    public void oilChange() {}
}

class Communicate {
    public static <T extends Performs>
      void perform(T performer) {
        performer.speak();
        performer.sit();
    }
}

public class DogsAndRobots {
    public static void main(String[] args) {
        Communicate.perform(new PerformingDog());
        Communicate.perform(new Robot());
    }
}
```

> #### `perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：

```
class CommunicateSimply {
    static void perform(Performs performer) {
        performer.speak();
        performer.sit();
    }
}

public class SimpleDogsAndRobots {
    public static void main(String[] args) {
        CommunicateSimply.perform(new PerformingDog());
        CommunicateSimply.perform(new Robot());
    }
}
```











## 16. 对缺乏潜在类型机制的补偿

### (1) 反射

```
import java.lang.reflect.*;

// Does not implement Performs:
class Mime {
    public void walkAgainstTheWind() {}
    public void sit() {
        System.out.println("Pretending to sit");
    }
    public void pushInvisibleWalls() {}
    @Override
    public String toString() { return "Mime"; }
}

// Does not implement Performs:
class SmartDog {
    public void speak() { System.out.println("Woof!"); }
    public void sit() { System.out.println("Sitting"); }
    public void reproduce() {}
}

class CommunicateReflectively {
    public static void perform(Object speaker) {
        Class<?> spkr = speaker.getClass();
        try {
            try {
                Method speak = spkr.getMethod("speak");
                speak.invoke(speaker);
            } catch(NoSuchMethodException e) {
                System.out.println(speaker + " cannot speak");
            }
            try {
                Method sit = spkr.getMethod("sit");
                sit.invoke(speaker);
            } catch(NoSuchMethodException e) {
                System.out.println(speaker + " cannot sit");
            }
        } catch(SecurityException |
            IllegalAccessException |
            IllegalArgumentException |
            InvocationTargetException e) {
            throw new RuntimeException(speaker.toString(), e);
        }
    }
}

public class LatentReflection {
    public static void main(String[] args) {
        CommunicateReflectively.perform(new SmartDog());
        CommunicateReflectively.perform(new Robot());
        CommunicateReflectively.perform(new Mime());
    }
}
```

> #### 上例中的类完全是彼此分离的，没有任何公共基类或接口。通过反射，`CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。甚至可以部分实现 **Mime** 只具有一个必需的方法。







### (2) 将一个方法应用于序列

> #### 反射将所有的类型检查都转移到了运行时，因此在许多情况下这并不是我们所希望的。
>
> #### 假设我们想创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。可以用反射解决该问题：

```
import java.lang.reflect.*;
import java.util.*;

public class Apply {
    public static <T, S extends Iterable<T>>
      void apply(S seq, Method f, Object... args) {
        try {
            for(T t: seq)
                f.invoke(t, args);
        } catch(IllegalAccessException |
            IllegalArgumentException |
            InvocationTargetException e) {
            // Failures are programmer errors
            throw new RuntimeException(e);
        }
    }
}
import java.util.*;
import java.util.function.*;
import onjava.*;

public class ApplyTest {
    public static
    void main(String[] args) throws Exception {
        List<Shape> shapes =
          Suppliers.create(ArrayList::new, Shape::new, 3);
        Apply.apply(shapes, Shape.class.getMethod("rotate"));
        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);

        List<Square> squares =
          Suppliers.create(ArrayList::new, Square::new, 3);
        Apply.apply(squares, Shape.class.getMethod("rotate"));
        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);

        Apply.apply(new FilledList<>(Shape::new, 3),
          Shape.class.getMethod("rotate"));
        Apply.apply(new FilledList<>(Square::new, 3),
          Shape.class.getMethod("rotate"));

        SimpleQueue<Shape> shapeQ = Suppliers.fill(
          new SimpleQueue<>(), SimpleQueue::add,
          Shape::new, 3);
        Suppliers.fill(shapeQ, SimpleQueue::add,
          Square::new, 3);
        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
    }
}
```

> #### 反射通常比非反射要慢，因为在运行时发生了很多事情。
>
> #### 所以我们也可以使用 Java8 的函数式方法，并在解决了特殊需求时才诉诸反射。因此我们可以利用 Java8 的流和函数工具对上述代码进行重写：

```
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
import onjava.*;

public class ApplyFunctional {
    public static void main(String[] args) {
        Stream.of(
          Stream.generate(Shape::new).limit(2),
          Stream.generate(Square::new).limit(2))
        		.flatMap(c -> c) // flatten into one stream
        		.peek(Shape::rotate)
        		.forEach(s -> s.resize(7));

        new FilledList<>(Shape::new, 2)
          .forEach(Shape::rotate);
        new FilledList<>(Square::new, 2)
          .forEach(Shape::rotate);

        SimpleQueue<Shape> shapeQ = Suppliers.fill(
          new SimpleQueue<>(), SimpleQueue::add,
          Shape::new, 2);
        Suppliers.fill(shapeQ, SimpleQueue::add,
          Square::new, 2);
        shapeQ.forEach(Shape::rotate);
    }
}
```

> #### 使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从 `main()` 引发异常。











## 17. Java8 中的辅助潜在类型

> #### Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。

```
import typeinfo.pets.*;
import java.util.function.*;

class PerformingDogA extends Dog {
    public void speak() { System.out.println("Woof!"); }
    public void sit() { System.out.println("Sitting"); }
    public void reproduce() {}
}

class RobotA {
    public void speak() { System.out.println("Click!"); }
    public void sit() { System.out.println("Clank!"); }
    public void oilChange() {}
}

class CommunicateA {
    public static <P> void perform(P performer,
      Consumer<P> action1, Consumer<P> action2) {
        action1.accept(performer);
        action2.accept(performer);
    }
}

public class DogsAndRobotMethodReferences {
    public static void main(String[] args) {
        CommunicateA.perform(new PerformingDogA(),
          PerformingDogA::speak, PerformingDogA::sit);
        CommunicateA.perform(new RobotA(),
          RobotA::speak, RobotA::sit);
        CommunicateA.perform(new Mime(),
          Mime::walkAgainstTheWind,
          Mime::pushInvisibleWalls);
    }
}
```

> #### `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当调用 **`Consumer`** 的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。
>
> #### 之所以称其为“辅助”，是因为 ***必须显式地为 `perform()` 提供要使用的方法引用*** 。 它不能只按名称调用方法。

### (1) 使用 Suppliers 类的通用方法

```
package onjava;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class Suppliers {
    // Create a collection and fill it:
    public static <T, C extends Collection<T>> C
      create(Supplier<C> factory, Supplier<T> gen, int n) {
        return Stream.generate(gen)
            .limit(n)
            .collect(factory, C::add, C::addAll);
    }
    
    // Fill an existing collection:
    public static <T, C extends Collection<T>>
      C fill(C coll, Supplier<T> gen, int n) {
        Stream.generate(gen)
            .limit(n)
            .forEach(coll::add);
        return coll;
    }
    
    // Use an unbound method reference to
    // produce a more general method:
    public static <H, A> H fill(H holder,
      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
        Stream.generate(gen)
            .limit(n)
            .forEach(a -> adder.accept(holder, a));
        return holder;
    }
}
```











## 18. 类型转换真的如此之糟吗？

> #### 我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](https://njuics.github.io/OnJava8/#/book/24-Concurrent-Programming) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。

> #### 泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。
>
> #### 在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。











## 19. 进阶阅读

#### 泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 [http://java.oracle.com](http://java.oracle.com/) 获取。

#### Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。

#### 你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。

#### Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。



















# [第二十一章 数组](https://njuics.github.io/OnJava8/#/book/21-Arrays?id=第二十一章-数组)

## 1. 数组特性

> #### 将数组和其他类型的集合区分开来的原因有三：`效率`、`类型`、`保存基本数据类型的能力` 。数组的高速的代价是，数组对象的大小是固定的，且在该数组的生存期内不能更改。
>
> #### `ArrayList` 将数组封装起来，必要时自动分配更多数组空间和复制旧数组。这种灵活性需要开销，所以 `ArrayList` 效率不如数组。在极少数情况下效率会成为问题，所以这种时候可以直接使用数组。

> #### 在泛型前，集合类以一种宽泛的方式处理对象，而数组是优于 ***预泛型*** 的，因为创建一个数组就可以保存特定类型的数据。这意味着我们获得了一个编译时的类型检查。
>
> #### 一个数组可以保存基本数据类型，而一个预泛型的集合则不可以。

> #### 在概念上，数组和 `ArrayList` 之间很容易切换，而且集合的功能明显多于数组，随着自动装箱技术的出现，通过集合使用基本数据类型几乎和通过数组一样简单，数组的唯一优势就是效率。然而数组在解决一个更加普遍的问题时可能限制太多，在这种情形下可以使用集合类。

### (1) 用于显示数组的实用程序

> #### Java 提供了 `Arrays.toString()` 来将数组转换为可读字符串，然后可以在控制台上显示。然而这种方式视觉上干扰太大。

```
package onjava;
import java.util.*;

public interface ArrayShow {
  static void show(Object[] a) {System.out.println(Arrays.toString(a));}
  static void show(boolean[] a) {System.out.println(Arrays.toString(a));}
  static void show(byte[] a) {System.out.println(Arrays.toString(a));}
  static void show(char[] a) {System.out.println(Arrays.toString(a));}
  static void show(short[] a) {System.out.println(Arrays.toString(a));}
  static void show(int[] a) {System.out.println(Arrays.toString(a));}
  static void show(long[] a) {System.out.println(Arrays.toString(a));}
  static void show(float[] a) {System.out.println(Arrays.toString(a));}
  static void show(double[] a) {System.out.println(Arrays.toString(a));
  // Start with a description:
  static void show(String info, Object[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, boolean[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, byte[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, char[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, short[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, int[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, long[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, float[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, double[] a) {
    System.out.print(info + ": ");
    show(a);
  }
}
```











## 2. 一等对象

> #### 下面的例子总结了初始化数组的多种方式，并且展示了如何给不同的数组对象分配数组引用。

```
import java.util.*;
import static onjava.ArrayShow.*;

public class ArrayOptions {
  public static void main(String[] args) {
    BerylliumSphere[] a; // Uninitialized local
    BerylliumSphere[] b = new BerylliumSphere[5];

    show("b", b);
    BerylliumSphere[] c = new BerylliumSphere[4];
    for(int i = 0; i < c.length; i++)
      if(c[i] == null) // Can test for null reference
        c[i] = new BerylliumSphere();

    BerylliumSphere[] d = {
      new BerylliumSphere(),
      new BerylliumSphere(),
      new BerylliumSphere()
    };

    a = new BerylliumSphere[]{
      new BerylliumSphere(), new BerylliumSphere(),
    };	

    System.out.println("a.length = " + a.length);
    System.out.println("b.length = " + b.length);
    System.out.println("c.length = " + c.length);
    System.out.println("d.length = " + d.length);
    a = d;
    System.out.println("a.length = " + a.length);

    int[] e; // Null reference
    int[] f = new int[5];
      
    show("f", f);
    int[] g = new int[4];
    for(int i = 0; i < g.length; i++)
      g[i] = i*i;
    int[] h = { 11, 47, 93 };

    //  Compile error: variable e not initialized:
    //- System.out.println("e.length = " + e.length);
    System.out.println("f.length = " + f.length);
    System.out.println("g.length = " + g.length);
    System.out.println("h.length = " + h.length);
    e = h;
    System.out.println("e.length = " + e.length);
    e = new int[]{ 1, 2 };
    System.out.println("e.length = " + e.length);
  }
}
```

> #### 数组对象的大小并不是真正存储在数组中对象的个数。然而，当你创建一个数组对象，其引用将自动初始化为 **null**，因此你可以通过检查特定数组元素中的引用是否为 **null** 来判断其中是否有对象。
>
> #### **`ArrayOptions.java`** 的第二部分展示了基元数组的语法就像对象数组一样，除了基元数组直接保存基本数据类型的值。











## 3. 返回数组

> #### 在 Java 中可以返回数组，永远不用为数组担心，只要需要它，它就可用，垃圾收集器会在用完后把它清理干净。

```
import java.util.*;
import static onjava.ArrayShow.*;

public class IceCreamFlavors {
  private static SplittableRandom rand = new SplittableRandom(47);
  static final String[] FLAVORS = {
    "Chocolate", "Strawberry", "Vanilla Fudge Swirl",
    "Mint Chip", "Mocha Almond Fudge", "Rum Raisin",
    "Praline Cream", "Mud Pie"
  };
  public static String[] flavorSet(int n) {
    if(n > FLAVORS.length)
      throw new IllegalArgumentException("Set too big");
    String[] results = new String[n];
    boolean[] picked = new boolean[FLAVORS.length];
    for(int i = 0; i < n; i++) {
      int t;
      do
        t = rand.nextInt(FLAVORS.length);
      while(picked[t]);
      results[i] = FLAVORS[t];
      picked[t] = true;
    }
    return results;
  }
  public static void main(String[] args) {
    for(int i = 0; i < 7; i++)
      show(flavorSet(3));
  }
}
```

> #### 如果必须要返回一系列不同类型的元素，可以使用 [泛型](https://njuics.github.io/OnJava8/#/book/20-Generics) 中介绍的 **元组** 。











## 4. 多维数组

> #### 可以初始化赋值，可以 new 分配数组，也可以实现不规则数组，也可以利用自动装箱技术。











## 5. 泛型数组

> #### 不能实例化 参数化类型 的数组，因为类型擦除需要删除参数类型信息，而数组必须知道它们所保存的确切类型，以强制保证类型安全。但可以参数化数组本身的类型。

```
class ClassParameter<T> {
  public T[] f(T[] arg) { return arg; }
}

class MethodParameter {
  public static <T> T[] f(T[] arg) { return arg; }
}

public class ParameterizedArrayType {
  public static void main(String[] args) {
    Integer[] ints = { 1, 2, 3, 4, 5 };
    Double[] doubles = { 1.1, 2.2, 3.3, 4.4, 5.5 };
    Integer[] ints2 =
      new ClassParameter<Integer>().f(ints);
    Double[] doubles2 =
      new ClassParameter<Double>().f(doubles);
    ints2 = MethodParameter.f(ints);
    doubles2 = MethodParameter.f(doubles);
  }
}
```

> #### 编译器不会让我们 ***`实例化`*** 一个泛型的数组。但它允许我们创建对此类数组的引用。尽管不能创建包含泛型的实际数组对象，但是我们可以创建一个非泛型的数组并对其进行强制类型转换：

```
import java.util.*;

public class ArrayOfGenerics {
  @SuppressWarnings("unchecked")
  public static void main(String[] args) {
    List<String>[] ls;
    List[] la = new List[10];
    ls = (List<String>[])la; // Unchecked cast
    ls[0] = new ArrayList<>();

    //- ls[1] = new ArrayList<Integer>();
    // error: incompatible types: ArrayList<Integer>
    // cannot be converted to List<String>
    //     ls[1] = new ArrayList<Integer>();
    //             ^

    // The problem: List<String> is a subtype of Object
    Object[] objects = ls; // So assignment is OK
    // Compiles and runs without complaint:
    objects[1] = new ArrayList<>();

    // However, if your needs are straightforward it is
    // possible to create an array of generics, albeit
    // with an "unchecked cast" warning:
    List<BerylliumSphere>[] spheres =
      (List<BerylliumSphere>[])new List[10];
    Arrays.setAll(spheres, n -> new ArrayList<>());
  }
}
```

> #### 一般来说，泛型在类或方法的边界上是有效的。在内部，擦除常常会使泛型不可使用。











## 6. Arrays 的 fill 方法

> #### Java 标准库 **`Arrays`** 类包括一个普通的 **`fill()`** 方法，该方法将单个值复制到整个数组，或者在对象数组的情况下，将相同的引用复制到整个数组。











## 7. Arrays 的 setAll 方法

> #### `ArrayOfGenerics.java.Array.setAll()` 使用一个生成器并生成不同的值，可以选择基于数组的索引元素。**`static Arrays.setAll()`** 的重载签名为：
>
> - #### **void setAll(int[] a, IntUnaryOperator gen)**
>
> - #### **void setAll(long[] a, IntToLongFunction gen)**
>
> - #### **void setAll(double[] a, IntToDoubleFunctiongen)**
>
> - #### **void setAll(T[] a, IntFunction<? extendsT> gen)**

```
import java.util.*;
import static onjava.ArrayShow.*;

class Bob {
  final int id;
  Bob(int n) { id = n; }
  @Override
  public String toString() { return "Bob" + id; }
}

public class SimpleSetAll {
  public static final int SZ = 8;
  static int val = 1;
  static char[] chars = "abcdefghijklmnopqrstuvwxyz"
    .toCharArray();
  static char getChar(int n) { return chars[n]; }
  public static void main(String[] args) {
    int[] ia = new int[SZ];
    long[] la = new long[SZ];
    double[] da = new double[SZ];
    Arrays.setAll(ia, n -> n); // [1]
    Arrays.setAll(la, n -> n);
    Arrays.setAll(da, n -> n);
    show(ia);
    show(la);
    show(da);
    Arrays.setAll(ia, n -> val++); // [2]
    Arrays.setAll(la, n -> val++);
    Arrays.setAll(da, n -> val++);
    show(ia);
    show(la);
    show(da);

    Bob[] ba = new Bob[SZ];
    Arrays.setAll(ba, Bob::new); // [3]
    show(ba);

    Character[] ca = new Character[SZ];
    Arrays.setAll(ca, SimpleSetAll::getChar); // [4]
    show(ca);
  }
}
```











## 8. 增量生成(略)

> #### 增量生成是一个方法库，用于为不同类型生成增量值。这些被作为内部类来生成容易记住的名字。











## 9. 随机生成(略)











## 10. 泛型和基本数组

> #### 泛型不能和基元一起工作。在这种情况下，我们必须从基元数组转换为包装类型的数组，并且还必须从另一个方向转换。下面是一个转换器可以同时对所有类型的数据执行操作：

```
package onjava;

public interface ConvertTo {
  static boolean[] primitive(Boolean[] in) {
    boolean[] result = new boolean[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i]; // Autounboxing
    return result;
  }
  static char[] primitive(Character[] in) {
    char[] result = new char[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static byte[] primitive(Byte[] in) {
    byte[] result = new byte[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static short[] primitive(Short[] in) {
    short[] result = new short[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static int[] primitive(Integer[] in) {
    int[] result = new int[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static long[] primitive(Long[] in) {
    long[] result = new long[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static float[] primitive(Float[] in) {
    float[] result = new float[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static double[] primitive(Double[] in) {
    double[] result = new double[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  // Convert from primitive array to wrapped array:
  static Boolean[] boxed(boolean[] in) {
    Boolean[] result = new Boolean[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i]; // Autoboxing
    return result;
  }
  static Character[] boxed(char[] in) {
    Character[] result = new Character[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static Byte[] boxed(byte[] in) {
    Byte[] result = new Byte[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static Short[] boxed(short[] in) {
    Short[] result = new Short[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static Integer[] boxed(int[] in) {
    Integer[] result = new Integer[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static Long[] boxed(long[] in) {
    Long[] result = new Long[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static Float[] boxed(float[] in) {
    Float[] result = new Float[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
  static Double[] boxed(double[] in) {
    Double[] result = new Double[in.length];
    for(int i = 0; i < in.length; i++)
      result[i] = in[i];
    return result;
  }
}
```











## 11. 数组元素修改

> #### 传递给 `Array.setAll()` 的`生成器函数`可以使用它接收到的数组索引修改现有的数组元素：

```
import java.util.*;
import onjava.*;
import static onjava.ArrayShow.*;

public class ModifyExisting {
    public static void main(String[] args) {
        double[] da = new double[7];
        Arrays.setAll(da, new Rand.Double()::get);
        show(da);
        Arrays.setAll(da, n -> da[n] / 100); // [1]
        show(da);

    }
}
```











## 12. 数组并行

> #### 用简单的方法编写代码。不要开始处理并行性，除非它成为一个问题。

> #### 我们将会遇到不同的情况：
>
> - #### 所提供的惟一选项是并行的。这很简单，因为我们别无选择，只能使用它。这种情况是比较罕见的。
>
> - #### 多个选项，但是并行版本(通常是最新的版本)被设计成在任何地方都可以使用(甚至在那些不关心并行性的代码中)，如案例#1。我们将按预期使用并行版本。
>
> - #### 案例1和案例2并不经常发生。相反，您将遇到某些算法的两个版本，一个用于并行使用，另一个用于正常使用。我将描述并行的一个，但不会在普通代码中使用它，因为它也许会产生所有可能的问题。

### (1) parallelSetAll()

> #### 假设我们想创建一个数值从零开始填充的长数组：

```
import java.util.stream.LongStream;

public class CountUpward {
    static long[] fillCounted(int size) {
        return LongStream.iterate(0, i -> i + 1).limit(size).toArray();
    }

    public static void main(String[] args) {
        long[] l1 = fillCounted(20); // No problem
        show(l1);
        // On my machine, this runs out of heap space:
        // - long[] l2 = fillCounted(10_000_000);
    }
}
```

> #### 如果速度成为一个问题， `Arrays.parallelSetAll()` 将(可能)更快地执行初始化。

```
import onjava.*;
import java.util.Arrays;

public class ParallelSetAll {
    static final int SIZE = 10_000_000;

    static void intArray() {
        int[] ia = new int[SIZE];
        Arrays.setAll(ia, new Rand.Pint()::get);
        Arrays.parallelSetAll(ia, new Rand.Pint()::get);
    }

    static void longArray() {
        long[] la = new long[SIZE];
        Arrays.setAll(la, new Rand.Plong()::get);
        Arrays.parallelSetAll(la, new Rand.Plong()::get);
    }

    public static void main(String[] args) {
        intArray();
        longArray();
    }
}
```











## 13. Arrays 工具类

> - #### **`asList()`**: 获取任何序列或数组，并将其转换为一个 **列表集合** （集合章节介绍了此方法）。
>
> - #### **`copyOf()`**：以新的长度创建现有数组的新副本。
>
> - #### **`copyOfRange()`**：创建现有数组的一部分的新副本。
>
> - #### **`equals()`**：比较两个数组是否相等。
>
> - #### **`deepEquals()`**：多维数组的相等性比较。
>
> - #### **`stream()`**：生成数组元素的流。
>
> - #### **`hashCode()`**：生成数组的哈希值(您将在附录中了解这意味着什么:理解equals()和hashCode())。
>
> - #### **`deepHashCode()`**: 多维数组的哈希值。
>
> - #### **`sort()`**：排序数组
>
> - #### **`parallelSort()`**：对数组进行并行排序，以提高速度。
>
> - #### **`binarySearch()`**：在已排序的数组中查找元素。
>
> - #### **`parallelPrefix()`**：使用提供的函数并行累积(以获得速度)。基本上，就是数组的reduce()。
>
> - #### **`spliterator()`**：从数组中产生一个Spliterator;这是本书没有涉及到的流的高级部分。
>
> - #### **`toString()`**：为数组生成一个字符串表示。你在整个章节中经常看到这种用法。
>
> - #### **`deepToString()`**：为多维数组生成一个字符串。你在整个章节中经常看到这种用法。对于所有基本类型和对象，所有这些方法都是重载的。











## 14. 数组拷贝

> #### 与使用 for 循环手工执行拷贝相比， **`copyOf()`** 和 **`copyOfRange()`** 拷贝数组要快得多。这些方法被重载以处理所有类型。

```
import onjava.*;
import java.util.Arrays;
import static onjava.ArrayShow.*;

class Sup {
    private int id;
	
    Sup(int n) { id = n; }

    @Override
    public String toString() { return getClass().getSimpleName() + id; }
}

class Sub extends Sup {
    Sub(int n) { super(n); }
}

public class ArrayCopying {
    public static final int SZ = 15;

    public static void main(String[] args) {
        int[] a1 = new int[SZ];
        Arrays.setAll(a1, new Count.Integer()::get);
        show("a1", a1);
        int[] a2 = Arrays.copyOf(a1, a1.length); // [1]
        // Prove they are distinct arrays:
        Arrays.fill(a1, 1);
        show("a1", a1);
        show("a2", a2);
        // Create a shorter result:
        a2 = Arrays.copyOf(a2, a2.length / 2); // [2]
        show("a2", a2);
        // Allocate more space:
        a2 = Arrays.copyOf(a2, a2.length + 5);
        show("a2", a2);
        // Also copies wrapped arrays:
        Integer[] a3 = new Integer[SZ]; // [3]
        Arrays.setAll(a3, new Count.Integer()::get);
        Integer[] a4 = Arrays.copyOfRange(a3, 4, 12);
        show("a4", a4);
        Sub[] d = new Sub[SZ / 2];
        Arrays.setAll(d, Sub::new); // Produce Sup[] from Sub[]:
        Sup[] b = Arrays.copyOf(d, d.length, Sup[].class); // [4]
        show(b); // This "downcast" works fine:
        Sub[] d2 = Arrays.copyOf(b, b.length, Sub[].class); // [5]
        show(d2); // Bad "downcast" compiles but throws exception:
        Sup[] b2 = new Sup[SZ / 2];
        Arrays.setAll(b2, Sup::new);
        try {
            Sub[] d3 = Arrays.copyOf(b2, b2.length, Sub[].class); // [6]
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
```











## 15. 数组比较

> #### 数组提供了 `eaquals()` 来比较一维数组，以及 `deepEquals()` 来比较多维数组。对于所有原生类型和对象，这些方法都是重载的。
>
> #### 数组相等的含义：数组必须有相同数量的元素，并且每个元素必须与另一个数组中的对应元素相等，对每个元素使用 `equals()` 。

```
import java.util.*;
import onjava.*;

public class ComparingArrays {
    public static final int SZ = 15;

    static String[][] twoDArray() {
        String[][] md = new String[5][];
        Arrays.setAll(md, n -> new String[n]);
        for (int i = 0; i < md.length; i++) Arrays.setAll(md[i], new Rand.String()::get);
        return md;
    }

    public static void main(String[] args) {
        int[] a1 = new int[SZ], a2 = new int[SZ];
        Arrays.setAll(a1, new Count.Integer()::get);
        Arrays.setAll(a2, new Count.Integer()::get);
        System.out.println("a1 == a2: " + Arrays.equals(a1, a2));
        a2[3] = 11;
        System.out.println("a1 == a2: " + Arrays.equals(a1, a2));
        Integer[] a1w = new Integer[SZ], a2w = new Integer[SZ];
        Arrays.setAll(a1w, new Count.Integer()::get);
        Arrays.setAll(a2w, new Count.Integer()::get);
        System.out.println("a1w == a2w: " + Arrays.equals(a1w, a2w));
        a2w[3] = 11;
        System.out.println("a1w == a2w: " + Arrays.equals(a1w, a2w));
        String[][] md1 = twoDArray(), md2 = twoDArray();
        System.out.println(Arrays.deepToString(md1));
        System.out.println("deepEquals(md1, md2): " + Arrays.deepEquals(md1, md2));
        System.out.println("md1 == md2: " + Arrays.equals(md1, md2));
        md1[4][1] = "#$#$#$#";
        System.out.println(Arrays.deepToString(md1));
        System.out.println("deepEquals(md1, md2): " + Arrays.deepEquals(md1, md2));
    }
}
```











## 16. 流和数组

> #### `stream()` 方法很容易从某些类型的数组中生成元素流：

```
import java.util.*;
import onjava.*;

public class StreamFromArray {
    public static void main(String[] args) {
        String[] s = new Rand.String().array(10);
        Arrays.stream(s).skip(3).limit(5).map(ss -> ss + "!").forEach(System.out::println);
        int[] ia = new Rand.Pint().array(10);
        Arrays.stream(ia).skip(3).limit(5)
              .map(i -> i * 10).forEach(System.out::println);
        Arrays.stream(new long[10]);
        Arrays.stream(new double[10]);
        // Only int, long and double work:
        // - Arrays.stream(new boolean[10]);
        // - Arrays.stream(new byte[10]);
        // - Arrays.stream(new char[10]);
        // - Arrays.stream(new short[10]);
        // - Arrays.stream(new float[10]);
        // For the other types you must use wrapped arrays:
        float[] fa = new Rand.Pfloat().array(10);
        Arrays.stream(ConvertTo.boxed(fa));
        Arrays.stream(new Rand.Float().array(10));
    }
}
```

> #### 只有 “原生类型” `int`、`long` 和 `double` 可以与 `Arrays.stream()` 一起使用。对于其他的，必须以某种方式获得一个包装类型的数组。











## 17. 数组排序

> #### 编程设计的一个主要目标是“将易变的元素与稳定的元素分开”，在这里保持不变的代码是一般的排序算法，但是变化的是对象的比较方式。因此，使用 ***`策略设计模式`*** 而不是将比较代码放入许多不同的排序源码中。此时变化的代码被封装到一个被称为策略对象的类中。

> #### Java 有两种方式提供比较功能：
>
> - #### 第一种方法是通过实现 **`java.lang.Comparable`** 接口的原生方法。创建一个实现 **`Comparator`** 接口的单独的类。它有两个方法，**`compare(`)** 和 **`equals()`**。但除了特殊的性能需求外，不需要实现 `equals()`**，因为无论何时创建一个类，它都是隐式地继承自** Object**，**Object 有一个`equals()`。
>
> - #### 还可以编写自己的比较器。

```
import onjava.*;
import java.util.Arrays;
import java.util.SplittableRandom;

import static onjava.ArrayShow.*;

public class CompType implements Comparable<CompType> {
    private static int count = 1;
    private static SplittableRandom r = new SplittableRandom(47);
    int i;
    int j;

    public CompType(int n1, int n2) {
        i = n1;
        j = n2;
    }

    public static CompType get() {
        return new CompType(r.nextInt(100), r.nextInt(100));
    }

    public static void main(String[] args) {
        CompType[] a = new CompType[12];
        Arrays.setAll(a, n -> get());
        show("Before sorting", a);
        Arrays.sort(a);
        show("After sorting", a);
    }

    @Override
    public String toString() {
        String result = "[i = " + i + ", j = " + j + "]";
        if (count++ % 3 == 0) result += "\n";
        return result;
    }

    @Override
    public int compareTo(CompType rv) {
        return (i < rv.i ? -1 : (i == rv.i ? 0 : 1));
    }
}
```











## 18. Arrays.sort 的使用

```
import onjava.*;
import java.util.Arrays;
import java.util.Collections;
import static onjava.ArrayShow.*;

public class StringSorting {
    public static void main(String[] args) {
        String[] sa = new Rand.String().array(20);
        show("Before sort", sa);
        Arrays.sort(sa);
        show("After sort", sa);
        Arrays.sort(sa, Collections.reverseOrder());
        show("Reverse sort", sa);
        Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER);
        show("Case-insensitive sort", sa);
    }
}
```

> #### Java标准库中使用的排序算法被设计为最适合正在排序的类型 ---- 原生类型的快速排序和对象的归并排序。











## 19. 并行排序

> #### 如果排序性能是一个问题，那么可以使用 Java 8 的 `parallelSort()` ，它为所有不可预见的情况(包括数组的排序区域或使用了比较器)提供了重载版本。

```
package arrays.jmh;

import onjava.*;
import org.openjdk.jmh.annotations.*;
import java.util.Arrays;

@State(Scope.Thread)
public class ParallelSort {
    private long[] la;

    @Setup
    public void setup() { la = new Rand.Plong().array(100_000); }

    @Benchmark
    public void sort() { Arrays.sort(la); }

    @Benchmark
    public void parallelSort() { Arrays.parallelSort(la); }
}
```











## 20. binarySearch 二分查找

> #### 一旦数组有序，就可以通过使用 `Arrays.binarySearch()` 来执行对特定项的快速搜索。

```
import onjava.*;
import java.util.Arrays;
import static onjava.ArrayShow.*;

public class ArraySearching {
    public static void main(String[] args) {
        Rand.Pint rand = new Rand.Pint();
        int[] a = new Rand.Pint().array(25);
        Arrays.sort(a);
        show("Sorted array", a);
        while (true) {
            int r = rand.getAsInt();
            int location = Arrays.binarySearch(a, r);
            if (location >= 0) {
                System.out.println("Location of " + r + " is " + location + ", a[" + location + "] is " + a[location]);
                break; // Out of while loop
            }
        }
    }
}
```

> #### 如果使用比较器对 对象数组 进行排序，那么在执行 `binarySearch()` 时必须包含相同的比较器：

```
import onjava.*;
import java.util.Arrays;
import static onjava.ArrayShow.*;

public class AlphabeticSearch {
    public static void main(String[] args) {
        String[] sa = new Rand.String().array(30);
        Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER);
        show(sa);
        int index = Arrays.binarySearch(sa, sa[10], String.CASE_INSENSITIVE_ORDER);	// 比较器必须作为第三个参数传递给重载的 binarySearch() 。
        System.out.println("Index: " + index + "\n" + sa[index]);
    }
}
```











## 21. parallelPrefix 并行前缀

> #### `parallelPrefix()` 类似于 `Stream` 类中的 `reduce()` 方法：***它对前一个元素和当前元素执行一个操作，并将结果放入当前元素位置***：

```
import onjava.*;
import java.util.Arrays;
import static onjava.ArrayShow.*;

public class ParallelPrefix1 {
    public static void main(String[] args) {
        int[] nums = new Count.Pint().array(10);
        show(nums);
        System.out.println(Arrays.stream(nums).reduce(Integer::sum).getAsInt());
        Arrays.parallelPrefix(nums, Integer::sum);
        show(nums);
        System.out.println(Arrays.stream(new Count.Pint().array(6)).reduce(Integer::sum).getAsInt());
    }
}
```

> #### 使用 **`Stream.reduce()`** ，只能得到最终结果，而使用 **`Arrays.parallelPrefix()`** ，还可以得到所有中间计算，以确保它们是有用的。

```
import onjava.*;
import java.util.Arrays;
import static onjava.ArrayShow.*;

public class ParallelPrefix2 {
    public static void main(String[] args) {
        String[] strings = new Rand.String(1).array(8);
        show(strings);
        Arrays.parallelPrefix(strings, (a, b) -> a + b);
        show(strings);
    }
}
```

> #### 上例中使用流进行初始化，这非常优雅但是浪费内存空间。而使用 `setAll()` 执行初始化更节省内存：

```
import java.util.Arrays;

public class ParallelPrefix3 {
    static final int SIZE = 10_000_000;
    public static void main(String[] args) {
        long[] nums = new long[SIZE];
        Arrays.setAll(nums, n -> n);
        Arrays.parallelPrefix(nums, Long::sum);
        System.out.println("First 20: " + nums[19]);
        System.out.println("First 200: " + nums[199]);
        System.out.println("All: " + nums[nums.length - 1]);
    }
}
```

> #### 正确使用 `parallelPrefix()` 可能相当复杂，所以通常应该只在存在内存或速度问题时使用。否则，`Stream.reduce()` 应该是首选。











## 22. 本章小结

> #### 集合支持得到了显著的改进，现在集合在除性能外的所有方面都优于数组，即使这样，集合的性能也得到了显著的改进。
>
> #### 尝试使用泛型时，您将看到泛型对数组是相当不友好的。通常，即使可以让泛型和数组以某种形式一起工作(，在编译期间仍然会出现“unchecked”警告。
>
> #### 在使用 Java 的最新版本进行编程时，应该“优先选择集合而不是数组”。
>
> #### 如果不考虑将 原生类型 和 低级数组 放在该语言中，就有可能开发出一种真正纯粹的面向对象语言(尽管有这样的说法，Java并不是一种纯粹的面向对象语言，这正是因为它的底层缺陷)。















# [第二十二章 枚举](https://njuics.github.io/OnJava8/#/book/22-Enumerations?id=第二十二章-枚举)

## 1. 基本 enum 特性

> #### 调用 `enum` 的 `values()` 方法，可以遍历 `enum` 实例，返回 `enum` 实例的数组，而在该数组中的元素严格保持其在 `enum` 中声明时的顺序。
>
> #### 创建 `enum` 时，编译器会为你生成一个相关的类，这个类继承自 `Java.lang.Enum` 。

```
enum Shrubbery { GROUND, CRAWLING, HANGING }
public class EnumClass {
    public static void main(String[] args) {
        for(Shrubbery s : Shrubbery.values()) {
            System.out.println(
                    s + " ordinal: " + s.ordinal());
            System.out.print(
                    s.compareTo(Shrubbery.CRAWLING) + " ");
            System.out.print(
                    s.equals(Shrubbery.CRAWLING) + " ");
            System.out.println(s == Shrubbery.CRAWLING);
            System.out.println(s.getDeclaringClass());
            System.out.println(s.name());
            System.out.println("********************");
        }
// Produce an enum value from a String name:
        for(String s :
                "HANGING CRAWLING GROUND".split(" ")) {
            Shrubbery shrub =
                    Enum.valueOf(Shrubbery.class, s);
            System.out.println(shrub);
        }
    }
}
```

> - #### `ordinal()` 方法返回一个 int 值，这是每个 enum 实例在声明时的次序，从 0 开始。
>
> - #### 可以使用==来比较 `enum` 实例，编译器会自动为你提供 `equals()` 和 `hashCode()` 方法。
>
> - #### `Enum` 类实现了 `Comparable` 接口，所以它具有 `compareTo()` 方法。同时，它还实现了 `Serializable` 接口。
>
> - #### 在 `enum` 实例上调用 `getDeclaringClass()` 方法，我们就能知道其所属的 `enum` 类。
>
> - #### `name()` 方法返回 `enum` 实例声明时的名字，这与使用 `toString()` 方法效果相同。
>
> - #### `valueOf()` 是在 `Enum` 中定义的 `static` 方法，它根据给定的名字返回相应的 `enum` 实例，如果不存在给定名字的实例，将会抛出异常。

### (1) 将静态类型导入用于 enum

```
package enums;
public enum SpicinessEnum {
    NOT, MILD, MEDIUM, HOT, FLAMING
}

package enums;
import static enums.SpicinessEnum.*;
public class Burrito2 {
    SpicinessEnum degree;
    public Burrito2(SpicinessEnum degree) {
        this.degree = degree;
    }
    @Override
    public String toString() {
        return "Burrito is "+ degree;
    }
    public static void main(String[] args) {
        System.out.println(new Burrito2(NOT));
        System.out.println(new Burrito2(MEDIUM));
        System.out.println(new Burrito2(HOT));
    }
}
```

> #### 使用 `static import` 能够将 `enum` 实例的标识符带入当前的命名空间，所以无需再用 `enum` 类型来修饰 `enum` 实例。编译器可以确保你使用的是正确的类型。
>
> #### 所以唯一需要担心的是，使用静态导入会不会导致你的代码令人难以理解。多数情况下，使用 `static import` 还是有好处的，不过，程序员还是应该对具体情况进行具体分析。











## 2. 方法添加

> #### 我们基本上可以将 `enum` 看作一个常规的类，除了不能继承一个 `enum` 。所以我们是可以向 `enum` 中添加方法的。
>
> #### 一般来说，我们希望每个枚举实例能够返回对自身的描述，而不仅仅只是默认的 `toString()` 实现，这只能返回枚举实例的名字。

```
public enum OzWitch {
    WEST("Miss Gulch, aka the Wicked Witch of the West"),
    NORTH("Glinda, the Good Witch of the North"),
    EAST("Wicked Witch of the East, wearer of the Ruby " +
            "Slippers, crushed by Dorothy's house"),
    SOUTH("Good by inference, but missing");
    private String description;
    // Constructor must be package or private access:
    private OzWitch(String description) { this.description = description; }
    public String getDescription() { return description; }
    public static void main(String[] args) {
        for(OzWitch witch : OzWitch.values())
            System.out.println(witch + ": " + witch.getDescription());
    }
}
```

> #### 在定义自己的方法之前，必须在 `enum` 实例序列的最后添加一个分号。同时 Java 要求必须先定义 `enum` 实例。
>
> #### 我们只能在 `enum` 定义的内部使用其构造器创建 `enum` 实例。一旦 `enum` 的定义结束，编译器就不允许我们再使用其构造器来创建任何实例了。所以 `enum` 的构造器默认是 `private` 的。

### (1) 覆盖 `enum` 的方法

> #### 覆盖 `toString()` 方法，给我们提供了另一种方式来为枚举实例生成不同的字符串描述信息。

```
import java.util.stream.*;
public enum SpaceShip {
    SCOUT, CARGO, TRANSPORT,
    CRUISER, BATTLESHIP, MOTHERSHIP;
    @Override
    public String toString() {
        String id = name();
        String lower = id.substring(1).toLowerCase();
        return id.charAt(0) + lower;
    }
    public static void main(String[] args) {
        Stream.of(values())
                .forEach(System.out::println);
    }
}
```











## 3. switch 语句中的 enum

> #### 在 `switch` 中使用 `enum`，是 `enum` 提供的一项非常便利的功能。虽然一般情况下我们必须使用 `enum` 类型来修饰 `enum` 实例，但是在 `case` 语句中却不必如此：

```
enum Signal { GREEN, YELLOW, RED, }

public class TrafficLight {
    Signal color = Signal.RED;
    public void change() {
        switch(color) {
            case RED: color = Signal.GREEN;
                break;
            case GREEN: color = Signal.YELLOW;
                break;
            case YELLOW: color = Signal.RED;
                break;
        }
    }
    @Override
    public String toString() {
        return "The traffic light is " + color;
    }
    public static void main(String[] args) {
        TrafficLight t = new TrafficLight();
        for(int i = 0; i < 7; i++) {
            System.out.println(t);
            t.change();
        }
    }
}
```

> #### 编译器并没有抱怨 `switch` 中没有 `default` 语句，但这并不是因为每一个 `Signal` 都有对应的 `case` 语句。如果你注释掉其中的某个 `case` 语句，编译器同样不会抱怨什么。这意味着，你必须确保自己覆盖了所有的分支。但是，如果在 `case` 语句中调用 `return`，那么编译器就会抱怨缺少 `default` 语句了。这与是否覆盖了 `enum` 的所有实例无关。











## 4. values 方法的神秘之处

> #### 编译器创建的 `enum` 类都继承自 `Enum` 类。然而 `Enum` 类并没有 `values()` 方法。

```
import java.lang.reflect.*;
import java.util.*;
import onjava.*;
enum Explore { HERE, THERE }
public class Reflection {
    public static
    Set<String> analyze(Class<?> enumClass) {
        System.out.println(
                "_____ Analyzing " + enumClass + " _____");
        System.out.println("Interfaces:");
        for(Type t : enumClass.getGenericInterfaces())
            System.out.println(t);
        System.out.println(
                "Base: " + enumClass.getSuperclass());
        System.out.println("Methods: ");
        Set<String> methods = new TreeSet<>();
        for(Method m : enumClass.getMethods())
            methods.add(m.getName());
        System.out.println(methods);
        return methods;
    }
    public static void main(String[] args) {
        Set<String> exploreMethods =
                analyze(Explore.class);
        Set<String> enumMethods = analyze(Enum.class);
        System.out.println(
                "Explore.containsAll(Enum)? " +
                        exploreMethods.containsAll(enumMethods));
        System.out.print("Explore.removeAll(Enum): ");
        exploreMethods.removeAll(enumMethods);
        System.out.println(exploreMethods);
// Decompile the code for the enum:
        OSExecute.command(
                "javap -cp build/classes/main Explore");
    }
}
```

> #### `values()` 是由编译器添加的 `static` 方法。编译器还将 `Explore` 标记为 `final` 类，因而无法继承自 `enum` 。
>
> #### 在 `Class` 中有一个 `getEnumConstants()` 方法，所以即便 `Enum` 接口中没有 `values()` 方法，我们依然可以通过 `Class` 对象取得所有 `enum` 实例。

```
enum Search { HITHER, YON }
public class UpcastEnum {
    public static void main(String[] args) {
        Search[] vals = Search.values();
        Enum e = Search.HITHER; // Upcast
		// e.values(); // No values() in Enum
        for(Enum en : e.getClass().getEnumConstants())
            System.out.println(en);
    }
}
```











## 5. 实现而非继承

> #### 由于 Java 不支持多继承，所以继承了 `Java.lang.Enum` 的 `enum` 不能在继承其他类。但是可以实现一个或多个接口：

```
package enums.cartoons;
import java.util.*;
import java.util.function.*;
enum CartoonCharacter
        implements Supplier<CartoonCharacter> {
    SLAPPY, SPANKY, PUNCHY,
    SILLY, BOUNCY, NUTTY, BOB;
    private Random rand =
            new Random(47);
    @Override
    public CartoonCharacter get() {
        return values()[rand.nextInt(values().length)];
    }
}
public class EnumImplementation {
    public static <T> void printNext(Supplier<T> rg) {
        System.out.print(rg.get() + ", ");
    }
    public static void main(String[] args) {
		// Choose any instance:
        CartoonCharacter cc = CartoonCharacter.BOB;
        for(int i = 0; i < 10; i++)
            printNext(cc);
    }
}
```











## 6. 随机选择

> #### 我们可以利用泛型，使得随机选择更一般化，并将其加入到我们的工具库中。

```
package onjava;
import java.util.*;
public class Enums {
    private static Random rand = new Random(47);
    
    public static <T extends Enum<T>> T random(Class<T> ec) {
        return random(ec.getEnumConstants());
    }
    
    public static <T> T random(T[] values) {
        return values[rand.nextInt(values.length)];
    }
}
import onjava.*;
enum Activity { SITTING, LYING, STANDING, HOPPING,
    RUNNING, DODGING, JUMPING, FALLING, FLYING }
    
public class RandomTest {
    public static void main(String[] args) {
        for(int i = 0; i < 20; i++)
            System.out.print(Enums.random(Activity.class) + " ");
    }
}
```











## 7. 使用接口组织枚举

> #### 在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的。

```
package enums.menu;
public interface Food {
    enum Appetizer implements Food {
        SALAD, SOUP, SPRING_ROLLS;
    }
    enum MainCourse implements Food {
        LASAGNE, BURRITO, PAD_THAI,
        LENTILS, HUMMOUS, VINDALOO;
    }
    enum Dessert implements Food {
        TIRAMISU, GELATO, BLACK_FOREST_CAKE,
        FRUIT, CREME_CARAMEL;
    }
    enum Coffee implements Food {
        BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,
        LATTE, CAPPUCCINO, TEA, HERB_TEA;
    }
}
```

> #### 当需要和一大堆类型打交道时，接口就不如 `enum` 好用。例如，如果想创建一个 “枚举的枚举” ，那么可以创建一个新的 `enum` ，然后用其实例包装 `Food` 中的每个 `enum` 类。

```
package enums.menu;
import onjava.*;
public enum Course {
    APPETIZER(Food.Appetizer.class),
    MAINCOURSE(Food.MainCourse.class),
    DESSERT(Food.Dessert.class),
    COFFEE(Food.Coffee.class);
    private Food[] values;
    private Course(Class<? extends Food> kind) {
        values = kind.getEnumConstants();
    }
    public Food randomSelection() {
        return Enums.random(values);
    }
}
package enums.menu;
public class Meal {
    public static void main(String[] args) {
        for(int i = 0; i < 5; i++) {
            for(Course course : Course.values()) {
                Food food = course.randomSelection();
                System.out.println(food);
            }
            System.out.println("***");
        }
    }
}
```

> #### 还有一种更简洁的管理枚举的办法，就是将一个 `enum` 嵌套在另一个 `enum` 内：

```
import onjava.*;
enum SecurityCategory {
    STOCK(Security.Stock.class),
    BOND(Security.Bond.class);
    Security[] values;
    SecurityCategory(Class<? extends Security> kind) {
        values = kind.getEnumConstants();
    }
    interface Security {
        enum Stock implements Security {
            SHORT, LONG, MARGIN
        }
        enum Bond implements Security {
            MUNICIPAL, JUNK
        }
    }
    public Security randomSelection() {
        return Enums.random(values);
    }
    public static void main(String[] args) {
        for(int i = 0; i < 10; i++) {
            SecurityCategory category =
                    Enums.random(SecurityCategory.class);
            System.out.println(category + ": " +
                    category.randomSelection());
        }
    }
}
```











## 8. 使用 EnumSet 替代 Flags

> #### `enum` 要求其成员唯一，但不能从 `enum` 中删除或添加元素。 Java SE5 引入 `EnumSet` ，是为了通过 `enum` 创建一种替代品，以替代传统的基于 `int` 的“位标志”。
>
> #### `EnumSet` 的优点是，它在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。 `EnumSet` 中的元素必须来自一个 `enum` 。

```
package enums;
public enum AlarmPoints {
    STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3,
    OFFICE4, BATHROOM, UTILITY, KITCHEN
}
package enums;
import java.util.*;
import static enums.AlarmPoints.*;
public class EnumSets {
    public static void main(String[] args) {
        EnumSet<AlarmPoints> points =
                EnumSet.noneOf(AlarmPoints.class); // Empty
        points.add(BATHROOM);
        System.out.println(points);
        points.addAll(
                EnumSet.of(STAIR1, STAIR2, KITCHEN));
        System.out.println(points);
        points = EnumSet.allOf(AlarmPoints.class);
        points.removeAll(
                EnumSet.of(STAIR1, STAIR2, KITCHEN));
        System.out.println(points);
        points.removeAll(
                EnumSet.range(OFFICE1, OFFICE4));
        System.out.println(points);
        points = EnumSet.complementOf(points);
        System.out.println(points);
    }
}
```

> #### `EnumSet` 的方法的名字都相当直观，你可以查阅 `JDK` 文档找到其完整详细的描述。会发现 `of()` 方法被重载了很多次，不但为可变数量参数进行了重载，而且为接收 2 至 5 个显式的参数的情况都进行了重载。这也从侧面表现了 `EnumSet` 对性能的关注。因为，其实只使用单独的 `of()` 方法解决可变参数已经可以解决整个问题了，但是对比显式的参数，会有一点性能损失。

> #### `EnumSet` 的基础是 `long` (64位)，而一个 `enum` 实例只需一位bit表示其是否存在。也就是说，在不超过一个 `long` 的表达能力的情况下，你的 `EnumSet` 可以应用于最多不超过 64 个元素的 `enum`。

```
// enums/BigEnumSet.java
import java.util.*;
public class BigEnumSet {
    enum Big { A0, A1, A2, A3, A4, A5, A6, A7, A8, A9,
        A10, A11, A12, A13, A14, A15, A16, A17, A18, A19,
        A20, A21, A22, A23, A24, A25, A26, A27, A28, A29,
        A30, A31, A32, A33, A34, A35, A36, A37, A38, A39,
        A40, A41, A42, A43, A44, A45, A46, A47, A48, A49,
        A50, A51, A52, A53, A54, A55, A56, A57, A58, A59,
        A60, A61, A62, A63, A64, A65, A66, A67, A68, A69,
        A70, A71, A72, A73, A74, A75 }
    public static void main(String[] args) {
        EnumSet<Big> bigEnumSet = EnumSet.allOf(Big.class);
        System.out.println(bigEnumSet);
    }
}
```

> #### 但是 `EnumSet` 可以应用于多过 64 个元素的 `enum`，所以我猜测，`Enum` 会在必要的时候增加一个 `long`。











## 9. 使用 `EnumMap`

> #### `EnumMap` 是一种特殊的 `Map` ，它要求其中的键(key)必须来自一个 `enum` ，由于 `enum` 本身的限制，`EnumMap` 在内部可由数组实现。

```
package enums;
import java.util.*;
import static enums.AlarmPoints.*;
interface Command { void action(); }
public class EnumMaps {
    public static void main(String[] args) {
        EnumMap<AlarmPoints,Command> em =
                new EnumMap<>(AlarmPoints.class);
        em.put(KITCHEN,
                () -> System.out.println("Kitchen fire!"));
        em.put(BATHROOM,
                () -> System.out.println("Bathroom alert!"));
        for(Map.Entry<AlarmPoints,Command> e:
                em.entrySet()) {
            System.out.print(e.getKey() + ": ");
            e.getValue().action();
        }
        try { // If there's no value for a particular key:
            em.get(UTILITY).action();
        } catch(Exception e) {
            System.out.println("Expected: " + e);
        }
    }
}
```

> #### 与 `EnumSet` 一样，`enum` 实例定义时的次序决定了其在 `EnumMap` 中的顺序。`enum` 的每个实例作为一个键，总是存在的。但是，如果你没有为这个键调用 `put()` 方法来存入相应的值的话，其对应的值就是 `null`。

> #### 与常量相关的方法相比， `EnumMap` 有一个优点，就是它允许程序员改变值对象，而常量相关方法则在编译器就固定了。











## 10. 常量特定方法

> #### Java 的 `enum` 有一个特性，即它允许程序员为 `enum` 实例编写方法，而为每个 enum 实例赋予各自不同的行为。从而实现常量相关的方法。
>
> #### 首先我们需要为每个 `enum` 定义若干 `abstract` 方法，然后为每个 `enum` 实例实现该方法：

```
import java.util.*;
import java.text.*;
public enum ConstantSpecificMethod {
    DATE_TIME {
        @Override
        String getInfo() {
            return DateFormat.getDateInstance().format(new Date());
        }
    },
    CLASSPATH {
        @Override
        String getInfo() {
            return System.getenv("CLASSPATH");
        }
    },
    VERSION {
        @Override
        String getInfo() {
            return System.getProperty("java.version");
        }
    };
    abstract String getInfo();
    public static void main(String[] args) {
        for(ConstantSpecificMethod csm : values())
            System.out.println(csm.getInfo());
    }
}
```

> #### 这种通过相应的 `enum` 实例调用其上的方法，通常被称为 `表驱动的代码` 。

> #### 在面向对象的程序设计中，不同的行为与不同的类关联。而通过常量相关的方法，每个 `enum` 实例可以具备自己独特的行为，这似乎说明每个 `enum` 实例就像一个独特的类。然而，`enum` 实例与类的相似之处也仅限于此了。我们并不能真的将 `enum` 实例作为一个类型来使用

```
enum LikeClasses {
    WINKEN {
        @Override
        void behavior() {System.out.println("Behavior1");}
    },
    BLINKEN {
        @Override
        void behavior() {System.out.println("Behavior2");}
    },
    NOD {
        @Override
        void behavior() {System.out.println("Behavior3");}
    };
    abstract void behavior();
}
public class NotClasses {
    // void f1(LikeClasses.WINKEN instance) {} // Nope
}
```

> #### 在方法 `f1()` 中，编译器不允许我们将一个 `enum` 实例当作 `class` 类型。因为每个 `enum` 元素都是一个 `LikeClasses` 类型的 `static final` 实例。同时，由于它们是 `static` 实例，无法访问外部类的非 `static` 元素或方法，所以对于内部的 `enum` 的实例而言，其行为与一般的内部类并不相同。

> #### 与使用 ***匿名内部类*** 相比较，定义常量相关方法的语法更高效、简洁。而且除了实现 `abstract` 方法以外，还可以覆盖常量相关方法。

```
// enums/OverrideConstantSpecific.java
public enum OverrideConstantSpecific {
    NUT, BOLT,
    WASHER {
        @Override
        void f() {System.out.println("Overridden method");}
    };
    void f() {System.out.println("default behavior");}
    public static void main(String[] args) {
        for(OverrideConstantSpecific ocs : values()) {
            System.out.print(ocs + ": ");
            ocs.f();
        }
    }
}
```

> #### ***虽然 enum 有某些限制，但是一般而言，我们还是可以将其看作是类。***

### (1) 使用 `enum` 的职责链

> #### 职责链设计模式，以多种不同的方式来解决一个问题，然后将它们链接在一起。当一个请求到来时，它遍历这个链，直到链中的某个解决方案能够处理该请求。

```
import java.util.*;
import onjava.*;
class Mail {
    // The NO's reduce probability of random selection:
    enum GeneralDelivery {YES,NO1,NO2,NO3,NO4,NO5}
    enum Scannability {UNSCANNABLE,YES1,YES2,YES3,YES4}
    enum Readability {ILLEGIBLE,YES1,YES2,YES3,YES4}
    enum Address {INCORRECT,OK1,OK2,OK3,OK4,OK5,OK6}
    enum ReturnAddress {MISSING,OK1,OK2,OK3,OK4,OK5}
    GeneralDelivery generalDelivery;
    Scannability scannability;
    Readability readability;
    Address address;
    ReturnAddress returnAddress;
    static long counter = 0;
    long id = counter++;
    @Override
    public String toString() { return "Mail " + id; }
    public String details() {
        return toString() +
                ", General Delivery: " + generalDelivery +
                ", Address Scanability: " + scannability +
                ", Address Readability: " + readability +
                ", Address Address: " + address +
                ", Return address: " + returnAddress;
    }
    // Generate test Mail:
    public static Mail randomMail() {
        Mail m = new Mail();
        m.generalDelivery =
                Enums.random(GeneralDelivery.class);
        m.scannability =
                Enums.random(Scannability.class);
        m.readability =
                Enums.random(Readability.class);
        m.address = Enums.random(Address.class);
        m.returnAddress =
                Enums.random(ReturnAddress.class);
        return m;
    }
    public static
    Iterable<Mail> generator(final int count) {
        return new Iterable<Mail>() {
            int n = count;
            @Override
            public Iterator<Mail> iterator() {
                return new Iterator<Mail>() {
                    @Override
                    public boolean hasNext() {
                        return n-- > 0;
                    }
                    @Override
                    public Mail next() {
                        return randomMail();
                    }
                    @Override
                    public void remove() { // Not implemented
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }
}
public class PostOffice {
    enum MailHandler {
        GENERAL_DELIVERY {
            @Override
            boolean handle(Mail m) {
                switch(m.generalDelivery) {
                    case YES:
                        System.out.println(
                                "Using general delivery for " + m);
                        return true;
                    default: return false;
                }
            }
        },
        MACHINE_SCAN {
            @Override
            boolean handle(Mail m) {
                switch(m.scannability) {
                    case UNSCANNABLE: return false;
                    default:
                        switch(m.address) {
                            case INCORRECT: return false;
                            default:
                                System.out.println(
                                        "Delivering "+ m + " automatically");
                                return true;
                        }
                }
            }
        },
        VISUAL_INSPECTION {
            @Override
            boolean handle(Mail m) {
                switch(m.readability) {
                    case ILLEGIBLE: return false;
                    default:
                        switch(m.address) {
                            case INCORRECT: return false;
                            default:
                                System.out.println(
                                        "Delivering " + m + " normally");
                                return true;
                        }
                }
            }
        },
        RETURN_TO_SENDER {
            @Override
            boolean handle(Mail m) {
                switch(m.returnAddress) {
                    case MISSING: return false;
                    default:
                        System.out.println(
                                "Returning " + m + " to sender");
                        return true;
                }
            }
        };
        abstract boolean handle(Mail m);
    }
    static void handle(Mail m) {
        for(MailHandler handler : MailHandler.values())
            if(handler.handle(m))
                return;
        System.out.println(m + " is a dead letter");
    }
    public static void main(String[] args) {
        for(Mail mail : Mail.generator(10)) {
            System.out.println(mail.details());
            handle(mail);
            System.out.println("*****");
        }
    }
}
```







### (2) 使用 enum 的状态机

> #### 枚举类型非常适合用来创建状态机。一个状态机可以具有有限个特定的状态，它通常根据输入，从一个状态转移到下一个状态，不过也可能存在瞬时状态，而一旦任务执行结束，状态机就会立刻离开瞬时状态。

```
import java.util.*;
public enum Input {
    NICKEL(5), DIME(10), QUARTER(25), DOLLAR(100),
    TOOTHPASTE(200), CHIPS(75), SODA(100), SOAP(50),
    ABORT_TRANSACTION {
        @Override
        public int amount() { throw new RuntimeException("ABORT.amount()"); }
    },
    STOP { // This must be the last instance.
        @Override
        public int amount() { throw new RuntimeException("SHUT_DOWN.amount()"); }
    };
    int value; // In cents
    Input(int value) { this.value = value; }
    Input() {}
    int amount() { return value; }; // In cents
    static Random rand = new Random(47);
    public static Input randomSelection() {
        // Don't include STOP:
        return values()[rand.nextInt(values().length - 1)];
    }
}
import java.util.*;
import java.io.IOException;
import java.util.function.*;
import java.nio.file.*;
import java.util.stream.*;
enum Category {
    MONEY(Input.NICKEL, Input.DIME, Input.QUARTER, Input.DOLLAR),
    ITEM_SELECTION(Input.TOOTHPASTE, Input.CHIPS, Input.SODA, Input.SOAP),
    QUIT_TRANSACTION(Input.ABORT_TRANSACTION),
    SHUT_DOWN(Input.STOP);
    private Input[] values;
    Category(Input... types) { values = types; }
    private static EnumMap<Input,Category> categories =
            new EnumMap<>(Input.class);
    static {
        for(Category c : Category.class.getEnumConstants())
            for(Input type : c.values)
                categories.put(type, c);
    }
    public static Category categorize(Input input) {
        return categories.get(input);
    }
}

public class VendingMachine {
    private static State state = State.RESTING;
    private static int amount = 0;
    private static Input selection = null;
    enum StateDuration { TRANSIENT } // Tagging enum
    enum State {
        RESTING {
            @Override
            void next(Input input) {
                switch(Category.categorize(input)) {
                    case MONEY:
                        amount += input.amount();
                        state = ADDING_MONEY;
                        break;
                    case SHUT_DOWN:
                        state = TERMINAL;
                    default:
                }
            }
        },
        ADDING_MONEY {
            @Override
            void next(Input input) {
                switch(Category.categorize(input)) {
                    case MONEY:
                        amount += input.amount();
                        break;
                    case ITEM_SELECTION:
                        selection = input;
                        if(amount < selection.amount())
                            System.out.println(
                                    "Insufficient money for " + selection);
                        else state = DISPENSING;
                        break;
                    case QUIT_TRANSACTION:
                        state = GIVING_CHANGE;
                        break;
                    case SHUT_DOWN:
                        state = TERMINAL;
                    default:
                }
            }
        },
        DISPENSING(StateDuration.TRANSIENT) {
            @Override
            void next() {
                System.out.println("here is your " + selection);
                amount -= selection.amount();
                state = GIVING_CHANGE;
            }
        },
        GIVING_CHANGE(StateDuration.TRANSIENT) {
            @Override
            void next() {
                if(amount > 0) {
                    System.out.println("Your change: " + amount);
                    amount = 0;
                }
                state = RESTING;
            }
        },
        TERMINAL {@Override
        void output() { System.out.println("Halted"); } };
        private boolean isTransient = false;
        State() {}
        State(StateDuration trans) { isTransient = true; }
        void next(Input input) {
            throw new RuntimeException("Only call " +
                    "next(Input input) for non-transient states");
        }
        void next() {
            throw new RuntimeException(
                    "Only call next() for " +
                            "StateDuration.TRANSIENT states");
        }
        void output() { System.out.println(amount); }
    }
    static void run(Supplier<Input> gen) {
        while(state != State.TERMINAL) {
            state.next(gen.get());
            while(state.isTransient)
                state.next();
            state.output();
        }
    }
    public static void main(String[] args) {
        Supplier<Input> gen = new RandomInputSupplier();
        if(args.length == 1)
            gen = new FileInputSupplier(args[0]);
        run(gen);
    }
}

// For a basic sanity check:
class RandomInputSupplier implements Supplier<Input> {
    @Override
    public Input get() { return Input.randomSelection(); }
}

// Create Inputs from a file of ';'-separated strings:
class FileInputSupplier implements Supplier<Input> {
    private Iterator<String> input;
    FileInputSupplier(String fileName) {
        try {
            input = Files.lines(Paths.get(fileName))
                    .skip(1) // Skip the comment line
                    .flatMap(s -> Arrays.stream(s.split(";")))
                    .map(String::trim)
                    .collect(Collectors.toList())
                    .iterator();
        } catch(IOException e) {
            throw new RuntimeException(e);
        }
    }
    @Override
    public Input get() {
        if(!input.hasNext())
            return null;
        return Enum.valueOf(Input.class, input.next().trim());
    }
}
```

> #### 这种设计有一个缺陷，它要求 `enum State` 实例访问的 `VendingMachine` 属性必须声明为 `static`，这意味着，你只能有一个 `VendingMachine` 实例。











## 11. 多路分发

> #### 当你要处理多种交互类型时，程序可能会变得相当杂乱。举例来说，如果一个系统要分析和执行数学表达式。我们可能会声明 `Number.plus(Number)`，`Number.multiple(Number)` 等等，然而，当你声明 `a.plus(b)` 时，`并不知道 a 或 b 的确切类型`，那你如何能让它们正确地交互呢？
>
> #### Java 只支持单路分发，也就是说，如果要执行的操作包含了不止一个类型未知的对象时，那么 Java 的动态绑定机制只能处理其中一个的类型。
>
> #### 解决上面问题的办法就是 ***`多路分发`*** 。 ***多态只能发生在方法调用时***，所以如果想使用两路分发就必须有两个方法调用：
>
> - #### 第一个方法调用决定第一个未知类型；
>
> - #### 第二个方法调用决定第二个未知类型；

```
package enums;
public enum Outcome { WIN, LOSE, DRAW }

package enums;
import java.util.*;
import static enums.Outcome.*;

interface Item {
    Outcome compete(Item it);
    Outcome eval(Paper p);
    Outcome eval(Scissors s);
    Outcome eval(Rock r);
}
class Paper implements Item {
    @Override
    public Outcome compete(Item it) { return it.eval(this); }
    @Override
    public Outcome eval(Paper p) { return DRAW; }
    @Override
    public Outcome eval(Scissors s) { return WIN; }
    @Override
    public Outcome eval(Rock r) { return LOSE; }
    @Override
    public String toString() { return "Paper"; }
}
class Scissors implements Item {
    @Override
    public Outcome compete(Item it) { return it.eval(this); }
    @Override
    public Outcome eval(Paper p) { return LOSE; }
    @Override
    public Outcome eval(Scissors s) { return DRAW; }
    @Override
    public Outcome eval(Rock r) { return WIN; }
    @Override
    public String toString() { return "Scissors"; }
}
class Rock implements Item {
    @Override
    public Outcome compete(Item it) { return it.eval(this); }
    @Override
    public Outcome eval(Paper p) { return WIN; }
    @Override
    public Outcome eval(Scissors s) { return LOSE; }
    @Override
    public Outcome eval(Rock r) { return DRAW; }
    @Override
    public String toString() { return "Rock"; }
}
public class RoShamBo1 {
    static final int SIZE = 20;
    private static Random rand = new Random(47);
    public static Item newItem() {
        switch(rand.nextInt(3)) {
            default:
            case 0: return new Scissors();
            case 1: return new Paper();
            case 2: return new Rock();
        }
    }
    public static void match(Item a, Item b) {
        System.out.println( a + " vs. " + b + ": " + a.compete(b));
    }
    public static void main(String[] args) {
        for(int i = 0; i < SIZE; i++)
            match(newItem(), newItem());
    }
}
```

> #### `RoShamBo1.match()` 有两个 `Item` 参数，通过调用 `Item.compete()` 方法开始两路分发。要判定 `a` 的类型，分发机制会在 `a` 的实际类型的 `compete()` 方法通过调用 `eval(`) 来为另一个类型实现第二次分发。

### (1) 使用 enum 分发

> #### `enum` 实例不是类型，所以不能将 `enum` 实例作为参数的类型，从而无法重载 `eval()` 方法。不过还有很多方式可以实现多路分发。
>
> #### 一种方式是使用构造器来初始化每个 `enum` 实例，并以“一组”结果作为参数。这二者放在一块，形成了类似查询表的结构

```
package enums;
import static enums.Outcome.*;
public enum RoShamBo2 implements Competitor<RoShamBo2> {
    PAPER(DRAW, LOSE, WIN),
    SCISSORS(WIN, DRAW, LOSE),
    ROCK(LOSE, WIN, DRAW);
    private Outcome vPAPER, vSCISSORS, vROCK;
    RoShamBo2(Outcome paper, Outcome scissors, Outcome rock) {
        this.vPAPER = paper;
        this.vSCISSORS = scissors;
        this.vROCK = rock;
    }
    @Override
    public Outcome compete(RoShamBo2 it) {
        switch(it) {
            default:
            case PAPER: return vPAPER;
            case SCISSORS: return vSCISSORS;
            case ROCK: return vROCK;
        }
    }
    public static void main(String[] args) {
        RoShamBo.play(RoShamBo2.class, 20);
    }
}
```

> #### 在上面的例子中，只有第一次分发是实际的方法调用，第二个分发使用的是 `switch` ，不过这样做是安全的，因为 `enum` 限制了 `switch` 语句的选择分支。







### (2) 使用常量相关的方法

> #### 常量相关的方法允许我们为每个 `enum` 实例提供方法的不同实现。不过，`enum` 实例仍然不是类型，不能将其作为方法签名中的参数类型来使用。最好的办法是将 `enum` 用在 `switch` 语句中：

```
package enums;
import static enums.Outcome.*;
public enum RoShamBo3 implements Competitor<RoShamBo3> {
    PAPER {
        @Override
        public Outcome compete(RoShamBo3 it) {
            switch(it) {
                default: // To placate the compiler
                case PAPER: return DRAW;
                case SCISSORS: return LOSE;
                case ROCK: return WIN;
            }
        }
    },
    SCISSORS {
        @Override
        public Outcome compete(RoShamBo3 it) {
            switch(it) {
                default:
                case PAPER: return WIN;
                case SCISSORS: return DRAW;
                case ROCK: return LOSE;
            }
        }
    },
    ROCK {
        @Override
        public Outcome compete(RoShamBo3 it) {
            switch(it) {
                default:
                case PAPER: return LOSE;
                case SCISSORS: return WIN;
                case ROCK: return DRAW;
            }
        }
    };
    @Override
    public abstract Outcome compete(RoShamBo3 it);
    public static void main(String[] args) {
        RoShamBo.play(RoShamBo3.class, 20);
    }
}
```

> #### 以上代码还可以再压缩简化一下：

```
package enums;
public enum RoShamBo4 implements Competitor<RoShamBo4> {
    ROCK {
        @Override
        public Outcome compete(RoShamBo4 opponent) {
            return compete(SCISSORS, opponent);
        }
    },
    SCISSORS {
        @Override
        public Outcome compete(RoShamBo4 opponent) {
            return compete(PAPER, opponent);
        }
    },
    PAPER {
        @Override
        public Outcome compete(RoShamBo4 opponent) {
            return compete(ROCK, opponent);
        }
    };
    Outcome compete(RoShamBo4 loser, RoShamBo4 opponent) {
        return ((opponent == this) ? Outcome.DRAW
                : ((opponent == loser) ? Outcome.WIN
                : Outcome.LOSE));
    }
    public static void main(String[] args) {
        RoShamBo.play(RoShamBo4.class, 20);
    }
}
```







### (3) 使用 `EnumMap` 进行分发

> #### 使用 `EnumMap` 能够实现“真正的”两路分发。

```
package enums;
import java.util.*;
import static enums.Outcome.*;
enum RoShamBo5 implements Competitor<RoShamBo5> {
    PAPER, SCISSORS, ROCK;
    static EnumMap<RoShamBo5,EnumMap<RoShamBo5,Outcome>>
            table = new EnumMap<>(RoShamBo5.class);
    static {
        for(RoShamBo5 it : RoShamBo5.values())
            table.put(it, new EnumMap<>(RoShamBo5.class));
        initRow(PAPER, DRAW, LOSE, WIN);
        initRow(SCISSORS, WIN, DRAW, LOSE);
        initRow(ROCK, LOSE, WIN, DRAW);
    }
    static void initRow(RoShamBo5 it,
                        Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK) {
        EnumMap<RoShamBo5,Outcome> row =
                RoShamBo5.table.get(it);
        row.put(RoShamBo5.PAPER, vPAPER);
        row.put(RoShamBo5.SCISSORS, vSCISSORS);
        row.put(RoShamBo5.ROCK, vROCK);
    }
    @Override
    public Outcome compete(RoShamBo5 it) {
        return table.get(this).get(it);
    }
    public static void main(String[] args) {
        RoShamBo.play(RoShamBo5.class, 20);
    }
}
```







### (4) 使用二维数组

> #### 我们可以使用 ***`二维数组`*** ，将竞争者映射到竞争结果。采用这种方式能够获得最简洁、最直接的解决方案

```
package enums;
mport static enums.Outcome.*;
enum RoShamBo6 implements Competitor<RoShamBo6> {
    PAPER, SCISSORS, ROCK;
    private static Outcome[][] table = {
            { DRAW, LOSE, WIN }, // PAPER
            { WIN, DRAW, LOSE }, // SCISSORS
            { LOSE, WIN, DRAW }, // ROCK
    };
    @Override
    public Outcome compete(RoShamBo6 other) {
        return table[this.ordinal()][other.ordinal()];
    }
    public static void main(String[] args) {
        RoShamBo.play(RoShamBo6.class, 20);
    }
}
```

> #### 上例是最简洁的一种解决方案，但它也是相当僵硬的方案，因为它只能针对给定的常量输入产生常量输出。对于某类问题而言， ***“表驱动式编码”*** 的概念具有非常强大的功能。











## 12. 本章小结

> #### 虽然 `Java` 中的枚举比 `C` 或 `C++` 中的 `enum` 更成熟，但它仍然是一个“小”功能。而本章正好说明了一个“小”功能所能带来的价值。有时恰恰因为它，你才能够优雅而干净地解决问题。















# [第二十三章 注解](https://njuics.github.io/OnJava8/#/book/23-Annotations?id=第二十三章-注解)

> #### 注解(也被称为元数据)为我们在代码中添加信息提供了一种形式化的方式，是我们可以在稍后某个时刻更容易地使用这些数据。
>
> #### ***`注解`*** 是 Java5 索隐入的众多语言变化之一。它们提供了 Java 无法表达的但却需要完整表述程序所需的信息。
>
> - #### ***`注解`*** 使得我们可以以编译器验证的格式存储程序的额外信息。
>
> - #### ***`注解`*** 可以生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。
>
> - #### 通过使用注解，你可以将***元数据***保存在 Java 源代码中。

> #### 注解的语法十分简单，主要是在现有语法中添加 @ 符号：
>
> - #### **`@Override`**：表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或者方法签名被错误拼写的时候，编译器就会发出错误提示。
>
> - #### **`@Deprecated`**：如果使用该注解的元素被调用，编译器就会发出警告信息。
>
> - #### **`@SuppressWarnings`**：关闭不当的编译器警告信息。
>
> - #### **`@SafeVarargs`**：在 Java 7 中加入用于禁止对具有泛型varargs参数的方法或构造函数的调用方发出警告。
>
> - #### **`@FunctionalInterface`**：Java 8 中加入用于表示类型声明为函数式接口

> #### 每当创建涉及重复工作的类或接口时，你通常可以使用注解来自动化和简化流程。
>
> #### 注解在源代码级别保存所有信息而不是通过注释文字，这使得代码更加整洁和便于维护。
>
> #### 注解是真正 语言层级 的概念，以前构造出来就享有编译器的类型检查保护。

## 1. 基本语法

> #### 我们使用 `@Test` 对 `testExecute()` 进行注解。该注解本身不做任何事情，但编译器要保证其类路径上有 `@Test` 注解的定义。

```
package annotations;
import onjava.atunit.*;
public class Testable {
    public void execute() { System.out.println("Executing.."); }
    @Test
    void testExecute() { execute(); }
}
```

> #### 被注解标注的方法和其他方法没有任何区别。在这个例子中，注解 `@Test` 可以和任何修饰符共同作用于方法。从语法角度来看，注解和修饰符的使用方式是一样的。

### (1) 定义注解

> #### 注解的定义看起来很像接口的定义。实际上它们和其它 Java 接口一样，也会被编译成 `class` 文件。

```
package onjava.atunit;
import java.lang.annotation.*;
@Target(ElementType.METHOD)			// 元注解
@Retention(RetentionPolicy.RUNTIME)	// 元注解
public @interface Test {}
```

> #### 除了 `@` 符号以外， `@Test` 的定义看起来更像一个空接口。注解的定义也需要一些元注解，比如 `@Target` (定义注解可以应用在哪里：方法或字段)； `@Retention` (定义注解在哪里可用：源代码`SOURCE`、class文件`CLASS`、运行时`RUNTIME`)。

> #### 注解通常会包含一些表示特定值的元素。注解的元素看起来很像接口的方法，但是可以指定默认值。不包含任何元素的注解称为 `标记注解`。
>
> #### 注解的元素在使用时表现为 名-值 对的形式，并且需要放置在 `@UseCase` 声明之后的括号内。

```
import java.lang.annotation.*;
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface UseCase {
    int id();
    String description() default "no description";
}
// annotations/PasswordUtils.java
import java.util.*;
public class PasswordUtils {
    @UseCase(id = 47, description =
            "Passwords must contain at least one numeric")
    public boolean validatePassword(String passwd) {
        return (passwd.matches("\\w*\\d\\w*"));
    }
    @UseCase(id = 48)
    public String encryptPassword(String passwd) {
        return new StringBuilder(passwd)
                .reverse().toString();
    }
    @UseCase(id = 49, description =
            "New passwords can't equal previously used ones")
    public boolean checkForNewPassword(
            List<String> prevPasswords, String passwd) {
        return !prevPasswords.contains(passwd);
    }
}
```







### (2) 元注解

> #### Java 语言目前有 `5种标准注解` 以及 `5种元注解` ，元注解用于注解其它注解

|    注解     | 解释                                                         |
| :---------: | :----------------------------------------------------------- |
|   @Target   | 表示注解可以用于哪些地方。可能的 **ElementType** 参数包括： **CONSTRUCTOR**：构造器的声明； **FIELD**：字段声明（包括 enum 实例）； **LOCAL_VARIABLE**：局部变量声明； **METHOD**：方法声明； **PACKAGE**：包声明； **PARAMETER**：参数声明； **TYPE**：类、接口（包括注解类型）或者 enum 声明。 |
| @Retention  | 表示注解信息保存的时长。可选的 **RetentionPolicy** 参数包括： **SOURCE**：注解将被编译器丢弃； **CLASS**：注解在 class 文件中可用，但是会被 VM 丢弃； **RUNTIME**：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。 |
| @Documented | 将此注解保存在 Javadoc 中                                    |
| @Inherited  | 允许子类继承父类的注解                                       |
| @Repeatable | 允许一个注解可以被使用一次或者多次（Java 8）。               |











## 2. 编写注解处理器

> #### 使用注解中一个很重要的部分就是，创建与使用注解处理器。`Java` 拓展了反射机制的 `API` 用于帮助你创造这类工具。同时他还提供了 `javac` 编译器钩子在编译时使用注解。

```
import java.util.*;
import java.util.stream.*;
import java.lang.reflect.*;
public class UseCaseTracker {
    public static void
    trackUseCases(List<Integer> useCases, Class<?> cl) {
        for(Method m : cl.getDeclaredMethods()) {
            UseCase uc = m.getAnnotation(UseCase.class);
            if(uc != null) {
                System.out.println("Found Use Case " +
                        uc.id() + "\n " + uc.description());
                useCases.remove(Integer.valueOf(uc.id()));
            }
        }
        useCases.forEach(i ->
                System.out.println("Missing use case " + i));
    }
    public static void main(String[] args) {
        List<Integer> useCases = IntStream.range(47, 51)
                .boxed().collect(Collectors.toList());
        trackUseCases(useCases, PasswordUtils.class);
    }
}
```

> #### 这个程序用了两个反射的方法：`getDeclaredMethods()` 和 `getAnnotation()`，它们都属于 **`AnnotatedElement`** 接口（**`Class`**，**`Method`** 与 **`Field`** 类都实现了该接口）。
>
> - #### `getAnnotation()` 方法返回指定类型的注解对象，在本例中就是 “**`UseCase`**”。如果被注解的方法上没有该类型的注解，返回值就为 **`null`**。

### (1) 注解元素

> #### 注解元素可用的类型如下所示：
>
> - #### 所有基本类型
>
> - #### String
>
> - #### Class
>
> - #### enum
>
> - #### Annotation
>
> - #### 以上类型的数组







### (2) 默认值限制

> #### 元素不能有不确定的值。所以元素要么有默认值，要么在注解时提供元素的值。任何非基本类型的元素，无论是在源代码声明时还是在注解接口种定义默认值时，都不能使用 `null` 作为其值。







### (3) 生成外部文件

> #### 假设想提供一些基本的对象/关系映射功能，能够自动生成数据库表。你可以使用 XML 描述文件来指明类的名字、每个成员以及数据库映射的相关信息。
>
> #### 但是，通过使用注解，你可以把所有信息都保存在 **`JavaBean`** 源文件中。为此你需要一些 *用于定义数据库表名称* 、*数据库列* 以及 *将 SQL 类型映射到属性* 的注解。

```
package annotations.database;
import java.lang.annotation.*;
@Target(ElementType.TYPE) // Applies to classes only
@Retention(RetentionPolicy.RUNTIME)
public @interface DBTable {
    String name() default "";
}
package annotations.database;
import java.lang.annotation.*;
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Constraints {
    boolean primaryKey() default false;
    boolean allowNull() default true;
    boolean unique() default false;
}
package annotations.database;
import java.lang.annotation.*;
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLString {
    int value() default 0;
    String name() default "";
    Constraints constraints() default @Constraints;
}
package annotations.database;
import java.lang.annotation.*;
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLInteger {
    String name() default "";
    Constraints constraints() default @Constraints;
}
```

> #### 下面是一个简单的，使用了如上注解的类：

```
package annotations.database;
@DBTable(name = "MEMBER")
public class Member {
    @SQLString(30) String firstName;
    @SQLString(50) String lastName;
    @SQLInteger Integer age;
    @SQLString(value = 30,
            constraints = @Constraints(primaryKey = true))
    String reference;
    static int memberCount;
    public String getReference() { return reference; }
    public String getFirstName() { return firstName; }
    public String getLastName() { return lastName; }
    @Override
    public String toString() { return reference; }
    public Integer getAge() { return age; }
}
```

> #### 如果你在注解中定义了名为 **`value`** 的元素，并且在使用该注解时，**`value`** 为唯一一个需要赋值的元素，你就不需要使用名—值对的语法，你只需要在括号中给出 **`value`** 元素的值即可。这可以应用于任何合法类型的元素。这利用的是快捷方式特性。这也限制了你必须将元素命名为 **`value`** 。







### (4) 替代方案

> #### 可以使用一个单一的注解类 **@TableColumn**，它拥有一个 **enum** 元素，元素值定义了 **STRING**，**INTEGER**，**FLOAT** 等类型。这消除了每个 SQL 类型都需要定义一个 **@interface** 的负担，不过也使得用额外信息修饰 SQL 类型变的不可能

> #### 也可以使用一个 **`Stri\ng`** 类型的元素来描述实际的 `SQL` 类型，比如 `“VARCHAR(30)”` 或者 `“INTEGER”`。这使得你可以修饰 `SQL` 类型，但是这也将 `Java` 类型到 `SQL` 类型的映射绑在了一起，这不是一个好的设计。

> #### 第三种可行的方案是一起使用两个注解，**`@Constraints`** 和相应的 `SQL` 类型去注解同一个字段。这可能会让代码有些混乱，但是编译器允许你对同一个目标使用多个注解。







### (5) 注解不支持继承

> #### 不能使用 `extend` 关键字来继承 `@interface` 。







### (6) 实现处理器

```
package annotations.database;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

public class TableCreator {
    public static void
    main(String[] args) throws Exception {
        if (args.length < 1) {
            System.out.println("arguments: annotated classes");
            System.exit(0);
        }
        for (String className : args) {
            Class<?> cl = Class.forName(className);
            DBTable dbTable = cl.getAnnotation(DBTable.class);
            if (dbTable == null) {
                System.out.println("No DBTable annotations in class " + className);
                continue;
            }
            String tableName = dbTable.name();
            // If the name is empty, use the Class name:
            if (tableName.length() < 1)
                tableName = cl.getName().toUpperCase();
            List<String> columnDefs = new ArrayList<>();
            for (Field field : cl.getDeclaredFields()) {
                String columnName = null;
                Annotation[] anns = field.getDeclaredAnnotations();
                if (anns.length < 1)
                    continue; // Not a db table column
                if (anns[0] instanceof SQLInteger) {
                    SQLInteger sInt = (SQLInteger) anns[0];
                    // Use field name if name not specified
                    if (sInt.name().length() < 1)
                        columnName = field.getName().toUpperCase();
                    else
                        columnName = sInt.name();
                    columnDefs.add(columnName + " INT" + getConstraints(sInt.constraints()));
                }
                if (anns[0] instanceof SQLString) {
                    SQLString sString = (SQLString) anns[0];
                    // Use field name if name not specified.
                    if (sString.name().length() < 1)
                        columnName = field.getName().toUpperCase();
                    else
                        columnName = sString.name();
                    columnDefs.add(columnName + " VARCHAR(" + sString.value() + ")" + getConstraints(sString.constraints()));
                }
                StringBuilder createCommand = new StringBuilder(
                        "CREATE TABLE " + tableName + "(");
                for (String columnDef : columnDefs)
                    createCommand.append(
                            "\n " + columnDef + ",");
                // Remove trailing comma
                String tableCreate = createCommand.substring( 0, createCommand.length() - 1) + ");";
                System.out.println("Table Creation SQL for " + className + " is:\n" + tableCreate);
            }
        }
    }

    private static String getConstraints(Constraints con) {
        String constraints = "";
        if (!con.allowNull())
            constraints += " NOT NULL";
        if (con.primaryKey())
            constraints += " PRIMARY KEY";
        if (con.unique())
            constraints += " UNIQUE";
        return constraints;
    }
}
```











## 3. 使用 javac 处理注解

> #### 通过 `javac` 可以通过创建编译时注解处理器在 Java 源文件上使用注解，而不是编译之后的 `class` 文件。但是，我们不能通过处理器来改变源代码，唯一影响输出的方式就是创建新文件。
>
> #### 如果注解处理器创建了新的源文件，在新一轮处理中注解会检查源文件本身。工具会持续循环检测，直到不再有新的源文件产生。然后它编译所有源文件。

> #### 每个注解都需要处理器，但 `javac` 可以非常容易的将多个注解处理器合并在一起。可以指定多个需要处理的类，并且可以添加监听器用于监听注解完成后接到通知。

### (1) 最简单的处理器

```
package annotations.simplest;
import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import java.util.*;
@SupportedAnnotationTypes(
        "annotations.simplest.Simple")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class SimpleProcessor
        extends AbstractProcessor {
    @Override
    public boolean process(
            Set<? extends TypeElement> annotations,
            RoundEnvironment env) {
        for(TypeElement t : annotations)
            System.out.println(t);
        for(Element el :
                env.getElementsAnnotatedWith(Simple.class))
            display(el);
        return false;
    }
    private void display(Element el) {
        System.out.println("==== " + el + " ====");
        System.out.println(el.getKind() +
                " : " + el.getModifiers() +
                " : " + el.getSimpleName() +
                " : " + el.asType());
        if(el.getKind().equals(ElementKind.CLASS)) {
            TypeElement te = (TypeElement)el;
            System.out.println(te.getQualifiedName());
            System.out.println(te.getSuperclass());
            System.out.println(te.getEnclosedElements());
        }
        if(el.getKind().equals(ElementKind.METHOD)) {
            ExecutableElement ex = (ExecutableElement)el;
            System.out.print(ex.getReturnType() + " ");
            System.out.print(ex.getSimpleName() + "(");
            System.out.println(ex.getParameters() + ")");
        }
    }
}
```







### (2) 更复杂的处理器

```
package annotations.ifx;
import java.lang.annotation.*;
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface ExtractInterface {
    String interfaceName() default "-!!-";
}
package annotations.ifx;
@ExtractInterface(interfaceName="IMultiplier")
public class Multiplier {
    public boolean flag = false;
    private int n = 0;
    public int multiply(int x, int y) {
        int total = 0;
        for(int i = 0; i < x; i++)
            total = add(total, y);
        return total;
    }
    public int fortySeven() { return 47; }
    private int add(int x, int y) {
        return x + y;
    }
    public double timesTen(double arg) {
        return arg * 10;
    }
    public static void main(String[] args) {
        Multiplier m = new Multiplier();
        System.out.println(
                "11 * 16 = " + m.multiply(11, 16));
    }
}
```



```
package annotations.ifx;
import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.util.*;
import java.util.*;
import java.util.stream.*;
import java.io.*;
@SupportedAnnotationTypes(
        "annotations.ifx.ExtractInterface")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class IfaceExtractorProcessor
        extends AbstractProcessor {
    private ArrayList<Element>
            interfaceMethods = new ArrayList<>();
    Elements elementUtils;
    private ProcessingEnvironment processingEnv;
    @Override
    public void init(
            ProcessingEnvironment processingEnv) {
        this.processingEnv = processingEnv;
        elementUtils = processingEnv.getElementUtils();
    }
    @Override
    public boolean process(
            Set<? extends TypeElement> annotations,
            RoundEnvironment env) {
        for(Element elem:env.getElementsAnnotatedWith(
                ExtractInterface.class)) {
            String interfaceName = elem.getAnnotation(
                    ExtractInterface.class).interfaceName();
            for(Element enclosed :
                    elem.getEnclosedElements()) {
                if(enclosed.getKind()
                        .equals(ElementKind.METHOD) &&
                        enclosed.getModifiers()
                                .contains(Modifier.PUBLIC) &&
                        !enclosed.getModifiers()
                                .contains(Modifier.STATIC)) {
                    interfaceMethods.add(enclosed);
                }
            }
            if(interfaceMethods.size() > 0)
                writeInterfaceFile(interfaceName);
        }
        return false;
    }
    private void
    writeInterfaceFile(String interfaceName) {
        try(
                Writer writer = processingEnv.getFiler()
                        .createSourceFile(interfaceName)
                        .openWriter()
        ) {
            String packageName = elementUtils
                    .getPackageOf(interfaceMethods
                            .get(0)).toString();
            writer.write(
                    "package " + packageName + ";\n");
            writer.write("public interface " +
                    interfaceName + " {\n");
            for(Element elem : interfaceMethods) {
                ExecutableElement method =
                        (ExecutableElement)elem;
                String signature = " public ";
                signature += method.getReturnType() + " ";
                signature += method.getSimpleName();
                signature += createArgList(
                        method.getParameters());
                System.out.println(signature);
                writer.write(signature + ";\n");
            }
            writer.write("}");
        } catch(Exception e) {
            throw new RuntimeException(e);
        }
    }
    private String createArgList(
            List<? extends VariableElement> parameters) {
        String args = parameters.stream()
                .map(p -> p.asType() + " " + p.getSimpleName())
                .collect(Collectors.joining(", "));
        return "(" + args + ")";
    }
}
```











## 4. 基于注解的单元测试(略)











## 5. 本章小结

> #### 注解是 `Java` 引入的一项非常受欢迎的补充，它提供了一种结构化、并且具有类型检查能力的新途径，从而使得我们能够为代码中加入元数据而不会导致代码杂乱并难以阅读。使用注解能够帮助我们避免编写累赘的部署描述性文件以及其它的生成文件。
>
> #### `Java` 提供了很少的内置注解。这意味着如果在别处找不到可用的类库，那么就只能自己创建新的注解以及相应的处理器。通过将注解处理器连接到 `javac` ，我们可以进一步完成编译新生成的文件，简化构造过程。

















# [第二十四章 并发编程](https://njuics.github.io/OnJava8/#/book/24-Concurrent-Programming?id=第二十四章-并发编程)

> #### 更多繁琐和底层的细节，请参阅附录：[并发底层原理](https://github.com/LingCoder/OnJava8/blob/master/docs/book/Appendix-Low-Level-Concurrency.md)。要进一步深入这个领域，你还必须阅读 *`Brian Goetz`* 等人的 `《Java Concurrency in Practice》`。理想情况下，本章和上述附录是阅读该书的良好前提。另外，*`Bill Venner`* 的 `《Inside the Java Virtual Machine》`也很值得一看。它详细描述了包括线程在内的 JVM 的内部工作方式。

## 1. 术语问题

> #### ***`并发`*** 通常表示：***不止一个任务正在执行***。而 ***`并行`*** 几乎总是代表：***不止一个任务同时执行***。
>
> - #### ***`并发`*** ：同时完成多任务。无需等待当前任务完成即可执行其他任务。
>
> - #### ***`并行`*** ：同时在多个位置完成多任务。
>
> #### 两者的核心都是 ***“同时完成多个任务”*** ，不过并行增加了跨多个处理器的分布。

> #### 可以尝试以更细的粒度去定义(然而这不是标准化的术语)：
>
> - #### **`纯并发`**：仍然在单个 CPU 上运行任务。纯并发系统比时序系统更快地产生结果，但是它的运行速度不会因为处理器的增加而变得更快。
>
> - #### **`并发-并行`**：使用并发技术，结果程序可以利用多处理器更快地产生结果。
>
> - #### **`并行-并发`**：使用并行编程技术编写，即使只有一个处理器，结果程序仍然可以运行（Java 8 **Streams** 就是一个很好的例子）。
>
> - #### **`纯并行`**：只有多个处理器的情况下才能运行。

> #### ***`抽象泄露`*** ：抽象的目标是“抽象”掉那些对手头的想法不重要的部分，以屏蔽不必要的细节所带来的影响。如果抽象发生泄露，那么即使费很大功夫去隐藏它们，这些细枝末节也总会不断凸显出自己是重要的。

### (1) 并发的新定义

> #### ***`并发性`*** 是一系列专注于减少等待的性能技术：
>
> - #### 这是一个`集合`：包含许多不同的方法来解决这个问题。因为技术差异很大，这是使定义并发性如此具有挑战性的问题之一。
>
> - #### 这些是`性能技术`：并发的关键点在于让程序运行得更快。
>
> - #### `减少等待` 部分很重要而且微妙。无论程序运行在多少个CPU上，你只能在等待发生时产生效益。并发的唯一机会是程序的某些部分被迫等待。等待会以多种形式出现 - 这解释了为什么存在多种不同的并发方法。











## 2. 并发的超能力

> #### 当“同时”执行的任务相互干扰时，就会出现问题。这可能以一种微妙而偶然的方式发生，因此可以说并发是 “***可以论证的确定性，但实际上是不确定性的”*** 。
>
> #### 并发似乎充满了危险，如果这让你有点害怕，这可能是一件好事。尽管 Java 8 在并发性方面做出了很大改进，但仍然没有像编译时验证 或受检查的异常那样的安全网来告诉你何时出现错误。

> #### 关于并发，你只能依靠自己，只有知识渊博、保持怀疑和积极进取的人，才能用 Java 编写可靠的并发代码。











## 3. 并发为速度而生

> #### 并发并不是值得的，除非程序运行速度不够快。不要随便跳进并发编程的悲痛之中。有在显然没有其他选择时才开始使用并发，然后仅在必要的地方去使用它。
>
> #### 如果程序中的某个任务由于程序控制之外的某种情况而无法继续（通常是 I/O），我们就称该任务或线程已 ***`阻塞`*** 。如果没有并发，整个程序就会停下来，直到外部条件发生变化。但是，如果使用并发编写程序，则当一个任务被阻塞时，程序中的其他任务可以继续执行，因此整个程序得以继续运行。

> #### 实现并发的一种简单方式是使用操作系统级别的进程。
>
> - #### 与线程不同，`进程` 是在其自己的地址空间中运行的独立程序。进程的优势在于，因为操作系统通常将一个进程与另一个进程隔离，因此它们不会相互干扰，这使得进程编程相对容易。
>
> - #### 相比之下，`线程` 之间会共享内存和 I/O 等资源，因此编写多线程程序最基本的困难，在于协调不同线程驱动的任务之间对这些资源的使用，以免这些资源同时被多个任务访问。

> #### 一些编程语言旨在将并发任务彼此隔离。这些通常被称为*函数式语言*，其中每个函数调用不产生副作用，所以可以作为独立的任务来驱动。
>
> #### 如果发现程序的某一部分必须大量使用并发，并且在尝试构建该部分时遇到了过多的问题，那么可以考虑使用这些专用的并发语言创建程序的这个部分。

> #### Java 采用了更传统的方法：在顺序语言之上添加对线程的支持而非在多任务操作系统中分叉外部进程，线程是在表示执行程序的单个进程内创建任务。











## 4. Java 并发的四句格言

> - #### 不要用它（避免使用并发）
>
> - #### 没有什么是真的，一切可能都有问题
>
> - #### 仅仅是它能运行，并不意味着它没有问题
>
> - #### 你必须理解它（逃不掉并发）

### (1) 不要用它

> #### 避免陷入并发所带来的玄奥问题的最简单方法就是不要用它。使用并发唯一的正当理由是速度。如果你被迫使用并发，请采取最简单，最安全的方法来解决问题。使用知名的库并尽可能少地自己编写代码。







### (2) 没有什么是真的，一切可能都有问题

> #### 在并发领域，有些事情可能是真的而有些事情却不是，以至于你必须假设没有什么是真的。你必须质疑一切。







### (3) 仅仅是它能运行，并不意味着它没有问题

> - #### 你不能验证出并发程序是正确的，你只能（有时）验证出它是不正确的。
>
> - #### 大多数情况下你甚至没办法验证：如果它出问题了，你可能无法检测到它。
>
> - #### 你通常无法编写有用的测试，因此你必须依靠代码检查和对并发的深入了解来发现错误。
>
> - #### 即使是有效的程序也只能在其设计参数下工作。当超出这些设计参数时，大多数并发程序会以某种方式失败。







### (4) 你必须理解它

> #### 你不能轻易逃脱：
>
> - #### 即使你从未显示地创建一个线程，你使用的框架也可能——例如，`Swing` `GUI`库，或者像 **Timer** 类那样简单的东西。
>
> - #### 最糟糕的是：当你创建组件时，必须假设这些组件可能会在多线程环境中重用。即使你的解决方案是放弃并声明你的组件是“非线程安全的”，你仍然必须充分了解这样一个语句的重要性及其含义。











## 5. 残酷的真相

> #### Java 是在充满自信，热情和睿智的氛围中创建的。在发明一种编程语言时，很容易感觉语言的初始可塑性会持续存在一样，你可以把某些东西拿出来，如果不能解决问题，那么就修复它。编程语言以这种方式是独一无二的 - 它们经历了类似水的改变：气态，液态和最终的固态。在气态阶段，灵活性似乎是无限的，并且很容易认为它总是那样。一旦人们开始使用你的语言，变化就会变得更加严重，环境变得更加粘稠。语言设计的过程本身就是一门艺术。

> #### 热情使原始 Java 设计师加入了一些似乎有必要的特性。信心让他们认为任何问题随后都可以解决。在时间轴的某个地方，有人认为任何加入 Java 的东西是固定的和永久性的 -他们非常有信心，并相信第一个决定永远是正确的，因此我们看到 Java 的体系中充斥着糟糕的决策。

> #### 线程包含在 Java 1.0 中。像 C 这样的其他语言能够将线程视为一个附加功能，因此 Java 设计师也纷纷效仿，包括一个 Thread 类和必要的 JVM 支持（这比你想象的要复杂得多）。
>
> #### 当采用原始模型并将其粘贴到复杂语言中时，Java 的大规模扩展迅速暴露了基本问题。在 Thread 类中的许多方法的弃用以及后续的高级库浪潮中，这种情况变得明显，这些库试图提供更好的并发抽象。

> #### Java 实验告诉我们，结果是悄然灾难性的。程序员很容易陷入认为 Java 线程并不那么困难的陷阱。表面上看起来正常工作的程序实际上充满了微妙的并发 bug。
>
> #### 为了获得正确的并发性，语言功能必须从头开始设计并考虑并发性。木已成舟；Java 将`不再是为并发而设计的语言`，而`是一种允许并发的语言`。











## 6. 本章其余部分

> #### 本章的重点是最新的高级 Java 并发结构。相比于旧的替代品，使用这些会使你的生活更加轻松。但是，我们仍会在遗留代码中遇到一些低级工具。

> - #### ***`并行流`*** ： Java 8 Streams 提供的改进语法。可以通过简单地将 `parallel()` 添加到表达式来并行化流。这是一种简单、强大的利用多处理器的惊人方式。
>
> - #### ***`创建和运行任务`*** ： 为了解释创建和运行任务的一些基础知识，本节介绍了一种比并行流或 `CompletableFutures` 更简单的机制：`Executor`。执行者管理一些低级 `Thread` 对象。你创建一个任务，然后将其交给 Executor 去运行。
>
> - #### ***`终止长时间运行的任务`*** ： 典型地方法使用了一个标志，这引入了共享内存问题，我们将使用 Java 的 `Atomic` 库来回避它。
>
> - #### ***`Completable Futures`*** ： Java 5 中引入 `Future` 方法。Java 8 的 `CompletableFuture` 是一个更好的解决方案：它允许你将操作链接在一起，因此你不必将代码写入接口排序操作。
>
> - #### ***`死锁`*** ： 某些任务必须去 `等待-阻塞` 来获得其它任务的结果。被组织的任务有可能等待另一个被阻止的任务等等。如果被阻止的任务链循环到第一个，就会陷入死锁。
>
> - #### ***`努力、复杂、成本`*** ： 我们将会探索应该投入多少工作来使程序变得更快。











## 7. 并行流

> #### Java 8 流的一个显著优点是，在某些情况下，它们可以很容易地`并行化`。这来自库的仔细设计，特别是流使用`内部迭代`的方式。特别是，他们使用一种特殊的迭代器，称为 `Spliterator`，它被限制为易于自动分割。调用 `.parallel()` 后，流中的所有内容都作为一组并行任务运行。

```
import java.util.*;
import java.util.stream.*;
import static java.util.stream.LongStream.*;
import java.io.*;
import java.nio.file.*;
import onjava.Timer;

public class ParallelPrime {
    static final int COUNT = 100_000;
    public static boolean isPrime(long n){
        return rangeClosed(2, (long)Math.sqrt(n)).noneMatch(i -> n % i == 0);
        }
    public static void main(String[] args) throws IOException {
        Timer timer = new Timer();
        List<String> primes =
            iterate(2, i -> i + 1)
                .parallel()              // [1]
                .filter(ParallelPrime::isPrime)
                .limit(COUNT)
                .mapToObj(Long::toString)
                .collect(Collectors.toList());
        System.out.println(timer.duration());
        Files.write(Paths.get("primes.txt"), primes, StandardOpenOption.CREATE);
        }
    }
```

> #### 并行流似乎是一个甜蜜的交易。你所需要做的就是将编程问题转换成流，然后插入 `parallel()` 以加快速度。实际上有时候这很容易，但遗憾的是有很多陷阱：
>
> - #### `parallel()` 不是灵丹妙药 ： 应用 **`parallel()`** 是一个合理的尝试，但会产生令人惊讶的结果。
>
> - #### 流并行性将输入数据分成多个部分，因此算法可以应用于那些单独的部分。
>
> - #### 数组分割成本低，分割均匀且对分割的大小有着完美的掌控。
>
> - #### 链表没有这些属性;“拆分”一个链表仅仅意味着把它分成“第一元素”和“其余元素”，这相对无用。
>
> - #### 无状态生成器的行为类似于数组;**`range()`** 就是无状态的。
>
> - #### 迭代生成器的行为类似于链表; **`iterate()`** 是一个迭代生成器。

### (1) parallel()/limit() 交点

> #### 如果拥有有限数量的元素，则可以使用集合以及为有限大小的集合设计的关联算法。如果使用无限流，则使用针对流优化的算法。
>
> #### Java 8 将两者合并起来。例如，`Collections` 没有内置的 `map()` 操作。在 `Collection` 和 `Map` 中唯一类似流的批处理操作是 `forEach()` 。如果要执行 `map()` 和 `reduce()` 等操作，必须首先将 `Collection` 转换为存在这些操作的 `Stream` ：

```
import onjava.*;
import java.util.*;
import java.util.stream.*;
public class CollectionIntoStream {
    public static void main(String[] args) {
    List<String> strings = Stream.generate(new Rand.String(5))
    							 .limit(10)
    							 .collect(Collectors.toList());
    strings.forEach(System.out::println);
    // Convert to a Stream for many more options:
    String result = strings.stream()
    					   .map(String::toUpperCase)
    					   .map(s -> s.substring(2))
    					   .reduce(":", (s1, s2) -> s1 + s2);
    System.out.println(result);
    }
}
```

> #### 有时将 `Stream` 和 `Collection` 混合会产生意想不到的结果。

```
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
public class ParallelStreamPuzzle {
    static class IntGenerator
    implements Supplier<Integer> {
        private int current = 0;
        @Override
        public Integer get() { return current++; }
    }
    public static void main(String[] args) {
        List<Integer> x = Stream.generate(new IntGenerator())
        						.limit(10)
        						.parallel()
        						.collect(Collectors.toList());
        System.out.println(x);
    }
}
```

> #### 为了处理线程，我们必须将任何跟踪信息捕获到并发数据结构中。在这里我们使用 `ConcurrentLinkedDeque` ：

```
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.nio.file.*;
public class ParallelStreamPuzzle2 {
    public static final Deque<String> TRACE = new ConcurrentLinkedDeque<>();
    static class IntGenerator implements Supplier<Integer> {
        private AtomicInteger current = new AtomicInteger();
        @Override
        public Integer get() {
            TRACE.add(current.get() + ": " +Thread.currentThread().getName());
            return current.getAndIncrement();
        }
    }
    
    public static void main(String[] args) throws Exception {
    List<Integer> x = Stream.generate(newIntGenerator())
    						.limit(10)
    						.parallel()
    						.collect(Collectors.toList());
    System.out.println(x);
    Files.write(Paths.get("PSP2.txt"), TRACE);
    }
}
```

> #### `current` 是使用线程安全的 **`AtomicInteger`** 类定义的，可以防止竞争条件；**`parallel()`** 允许多个线程调用 **`get()`** 。

> #### 更合理的解决方法是，如果你想生成一个 int 流，可以使用 `IntStream.range()` ：

```
import java.util.*;
import java.util.stream.*;
public class ParallelStreamPuzzle3 {
    public static void main(String[] args) {
    List<Integer> x = IntStream.range(0, 30)
        .peek(e -> System.out.println(e + ": " +Thread.currentThread()
        .getName()))
        .limit(10)
        .parallel()
        .boxed()
        .collect(Collectors.toList());
        System.out.println(x);
    }
}
```

> #### 请记住这句格言 ———— ***“首先使它工作，然后使它更快地工作，只有当你必须这样做时。”***







### (2) 并行流只是看起来容易

> #### 在许多情况下，并行流确实可以轻松地产生结果。但仅仅将 `parallel()` 加到你的 `Stream` 操作上并不一定是安全的事情。在使用 **`parallel()`** 之前，你必须了解并行性如何帮助或损害你的操作。











## 8. 创建和运行任务

> #### Java 并发的历史始于非常原始和有问题的机制，并且充满了各种尝试的改进。这些主要归入附录：[低级并发](https://njuics.github.io/OnJava8/#/./Appendix-Low-Level-Concurrency)。在这里，我们将展示一个规范形式，表示创建和运行任务的最简单、最好的方法。

### (1) Tasks and Executors

> #### 早期 Java 版本中，可以通过直接创建 `Thread` 对象来使用线程，即手动调用构造函数并自己启动了线程。
>
> #### Java 5 中，添加了类来为我们处理线程池。可以将任务创建为单独的类型，然后将其交给 `ExecutorService` 以运行该任务。`ExecutorService` 为我们管理线程，并且在运行任务后重新循环线程而不是丢弃线程。

```
import onjava.Nap;
public class NapTask implements Runnable {
    final int id;
    public NapTask(int id) {
        this.id = id;
        }
    @Override
    public void run() {
        new Nap(0.1);// Seconds
        System.out.println(this + " "+ Thread.currentThread().getName());
        }
    @Override
    public String toString() { return"NapTask[" + id + "]"; }
}
package onjava;
import java.util.concurrent.*;
public class Nap {
    public Nap(double t) { // Seconds
        try { TimeUnit.MILLISECONDS.sleep((int)(1000 * t)); }
        catch(InterruptedException e){ throw new RuntimeException(e); }
    }
    public Nap(double t, String msg) {
        this(t);
        System.out.println(msg);
    }
}
```

> #### 对 **`TimeUnit.MILLISECONDS.sleep()`** 的调用获取“当前线程”并在参数中将其置于休眠状态，这意味着该线程被挂起。

> #### 要执行任务，我们从最简单的方法 ———— `SingleThreadExecutor` 开始：

```
import java.util.concurrent.*;
import java.util.stream.*;
import onjava.*;
public class SingleThreadExecutor {
    public static void main(String[] args) {
        ExecutorService exec =  Executors.newSingleThreadExecutor();
        IntStream.range(0, 10)
            .mapToObj(NapTask::new)
            .forEach(exec::execute);
        System.out.println("All tasks submitted");
        exec.shutdown();
        while(!exec.isTerminated()) {
            System.out.println( Thread.currentThread().getName()+ " awaiting termination");
            new Nap(0.1);
        }
    }
}
```

> #### 没有 **`SingleThreadExecutor`** 类。**`newSingleThreadExecutor()`** 是 **`Executors`** 中的一个工厂方法，它创建特定类型的 **`ExecutorService`**  。
>
> #### 当我运行 `callexec.shutdown()` 时，它告诉 `ExecutorService` 完成已经提交的任务，但不接受任何新任务，此时尝试提交新任务将抛出 `RejectedExecutionException` 。**`exec.shutdownNow()`** 除了不接受新任务外，还会尝试通过中断任务来停止任何当前正在运行的任务。
>
> #### 通过检查 `exec.isTerminated()` 来判断所有任务是否完成。







### (2) 使用更多线程

> #### `CachedThreadPool`：

```
import java.util.concurrent.*;
import java.util.stream.*;
public class CachedThreadPool {
    public static void main(String[] args) {
        ExecutorService exec =Executors.newCachedThreadPool();
        IntStream.range(0, 10)
        .mapToObj(NapTask::new)
        .forEach(exec::execute);
        exec.shutdown();
    }
}
```

> #### `CachedThreadPool` 与 `SingleThreadExecutor` 的区别：

```
import java.util.concurrent.*;
import java.util.stream.*;
public class CachedThreadPool2 {
    public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();
    IntStream.range(0, 10)
    .mapToObj(InterferingTask::new)
    .forEach(exec::execute);
    exec.shutdown();
    }
}
/*
0 pool-1-thread-1 200
1 pool-1-thread-2 200
4 pool-1-thread-5 300
5 pool-1-thread-6 400
8 pool-1-thread-9 500
9 pool-1-thread-10 600
2 pool-1-thread-3 700
7 pool-1-thread-8 800
3 pool-1-thread-4 900
6 pool-1-thread-7 1000
*/
import java.util.concurrent.*;
import java.util.stream.*;
public class SingleThreadExecutor3 {
    public static void main(String[] args)throws InterruptedException {
        ExecutorService exec = Executors.newSingleThreadExecutor();
        IntStream.range(0, 10)
        .mapToObj(InterferingTask::new)
        .forEach(exec::execute);
        exec.shutdown();
    }
}
/*
0 pool-1-thread-1 100
1 pool-1-thread-1 200
2 pool-1-thread-1 300
3 pool-1-thread-1 400
4 pool-1-thread-1 500
5 pool-1-thread-1 600
6 pool-1-thread-1 700
7 pool-1-thread-1 800
8 pool-1-thread-1 900
9 pool-1-thread-1 1000
*/
```

> #### 这是 `SingleThreadExecutor` 的主要好处 ———— 因为它一次运行一个任务，这些任务不会相互干扰，因此强加了线程安全性。这种现象称为线程封闭，因为在单线程上运行任务限制了它们的影响。线程封闭限制了加速，但可以节省很多困难的调试和重写。







### (3) 产生结果

> #### 因为 **`InterferingTask`** 是一个 **`Runnable`** ，它没有返回值，因此只能使用副作用产生结果 ———— 操纵缓冲值而不是返回结果。副作用是并发编程中的主要问题之一。
>
> #### 使用 `InterferingTask` ，最好删除副作用并返回任务结果。为此我们创建 `Callable` 而不是 `Runnable`：

```
import java.util.concurrent.*;
public class CountingTask implements Callable<Integer> {
    final int id;
    public CountingTask(int id) { this.id = id; }
    @Override
    public Integer call() {
        Integer val = 0;
        for(int i = 0; i < 100; i++) val++;
        System.out.println(id + " " + Thread.currentThread().getName() + " " + val);
        return val;
    }
}
```

> #### **`call()` 完全独立于所有其他 `CountingTasks` 生成其结果**，这意味着没有可变的共享状态。
>
> #### **`ExecutorService`** 允许你使用 **`invokeAll()`** 启动集合中的每个 `Callable`，只有在所有任务完成后， `invokeAll()` 才会返回一个 `Future` 列表。

```
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;
public class CachedThreadPool3 {
    public static Integer extractResult(Future<Integer> f) {
        try { return f.get(); } 
       `Future` 是 Java5 引入的机制，允许你提交任务而无需等待它完成。 catch(Exception e) { throw new RuntimeException(e); }
    }
    public static void main(String[] args)throws InterruptedException {
    ExecutorService exec = Executors.newCachedThreadPool();
    List<CountingTask> tasks = IntStream.range(0, 10).mapToObj(CountingTask::new)
            										 .collect(Collectors.toList());
        List<Future<Integer>> futures = exec.invokeAll(tasks);
        Integer sum = futures.stream()
            				 .map(CachedThreadPool3::extractResult)
            				 .reduce(0, Integer::sum);
        System.out.println("sum = " + sum);
        exec.shutdown();
    }
}
```

> #### **`Future`** 是 Java 5 中引入的机制，允许你提交任务而无需等待它完成。在这里，我们使用 `ExecutorService.submit()` :

```
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;
public class Futures {
    public static void main(String[] args)throws InterruptedException, ExecutionException {
    ExecutorService exec = Executors.newSingleThreadExecutor();
    Future<Integer> f = exec.submit(newCountingTask(99));
    System.out.println(f.get()); // [1] 当你的任务在尚未完成的 Future 上调用 get() 时，调用会阻塞（等待）直到结果可用。
    exec.shutdown();
    }
}
```

> #### 因为当你调用 **`get()`** 时，**`Future`** 会阻塞，所以它只能解决等待任务完成才暴露问题。最终，**`Futures`** 被认为是一种无效的解决方案，现在不鼓励，我们推荐 Java 8 的 **`CompletableFuture`** 。







### (4) Lambda 和方法引用作为任务

> #### 处理使用 `Runnable` 和 `Callable` ，java8的 **`lambdas`** 和 `方法引用` 可以通过匹配方法签名来使用，故可以将非  **`Runnable`** 或 **`Callable`** 的参数传递给 `ExecutorService` :

```
import java.util.concurrent.*;
class NotRunnable {
    public void go() { System.out.println("NotRunnable"); }
}
class NotCallable {
    public Integer get() {
        System.out.println("NotCallable");
        return 1;
    }
}
public class LambdasAndMethodReferences {
    public static void main(String[] args)throws InterruptedException {
        ExecutorService exec = Executors.newCachedThreadPool();
        exec.submit(() -> System.out.println("Lambda1"));
        exec.submit(new NotRunnable()::go);
        exec.submit(() -> {
            System.out.println("Lambda2");
            return 1;
        });
        exec.submit(new NotCallable()::get);
        exec.shutdown();
    }
}
```











## 9. 终止耗时任务

> #### 可运行的任务有时寿命很长，甚至是永远运行的后台程序。我们需要一种方法在正常完成之前停止 `Runnable` 和 `Callable` 任务。
>
> #### 最初的 Java 设计提供了中断运行任务的机制(为了向后兼容，仍然存在)；使用中断被视为反对模式，因为中断任务乱而复杂。

> #### 任务终止的最佳方法是 ***设置任务周期性检查标志*** 。然后任务可以通过自己的 `shutdown` 进程并正常终止。不是在任务中随机关闭线程，而是要求任务在到达了一个较好时自动终止。 但这会存在任务检查标志的***碰撞问题***。经常使用 `volatile` 关键字解决该问题。
>
> #### Java 5 引入了 `Atomic` 类，它提供了一组可以使用的类型，而不必担心并发问题。所以我们可以添加 `AtomicBoolean` 标志，告诉任务清理自己并退出

```
import java.util.concurrent.atomic.AtomicBoolean;
import onjava.Nap;
public class QuittableTask implements Runnable {
    final int id;
    public QuittableTask(int id) { this.id = id; }
    private AtomicBoolean running = new AtomicBoolean(true);
    public void quit() { running.set(false); }
    @Override
    public void run() {
        while(running.get())         // [1]
            new Nap(0.1);
        System.out.print(id + " ");  // [2]
    }
}
```

> #### `AtomicBoolean` 可以防止多个任务同时实际修改 `running` ，从而使 `quit()` 方法称为线程安全的。
>
> #### 实际上，在这个例子中，你可能永远不会有任何问题 ———— 但代码仍然是不安全的。编写表明该问题的测试可能很困难或不可能。因此，你没有任何反馈来告诉你已经做错了。通常，你编写线程安全代码的唯一方法就是 ***通过了解事情可能出错的所有细微之处***。











## 10. CompletableFuture 类

```
import java.util.*;
import java.util.stream.*;
import java.util.concurrent.*;
import onjava.Nap;
public class QuittingCompletable {
    public static void main(String[] args) {
    	List<QuittableTask> tasks =
        IntStream.range(1, QuittingTasks.COUNT)
            	 .mapToObj(QuittableTask::new)
            	 .collect(Collectors.toList());
        List<CompletableFuture<Void>> cfutures =
        tasks.stream()
             .map(CompletableFuture::runAsync)
             .collect(Collectors.toList());
        new Nap(1);
        tasks.forEach(QuittableTask::quit);
        cfutures.forEach(CompletableFuture::join);
    }
}
```

> #### 任务 `tasks` 是一个 `List<QuittableTask>` ，在创建 `cfutures` 期间，我们将 `tasks` 列表转化为流，并将其中每个任务都交给 `CompletableFuture::runAsync` 。它将会执行 `VerifyTask.run()` 并返回 `CompletableFuture<Void>` 。由于 `run()` 不返回任何内容，所以在这种情况下我们只使用 `CompletableFuture::join` 来等待它完成。
>
> #### 在本例中，我们运行任务不需要使用 `ExecutorService` ，而是直接交给 `CompletableFuture` 管理(但我们可以向它提供自己定义的 `ExecutorService`)。而且也不需要调用 `shutdown()` 。

### (1) 基本用法

```
// concurrent/Machina.java
import onjava.Nap;
public class Machina {
    public enum State {
        START, ONE, TWO, THREE, END;
        State step() {
            if(equals(END))
            return END;
          return values()[ordinal() + 1];
        }
    }
    private State state = State.START;
    private final int id;
    public Machina(int id) { this.id = id; }
    public static Machina work(Machina m) {
        if(!m.state.equals(State.END)){
            new Nap(0.1);
            m.state = m.state.step();
        }
        System.out.println(m);
        return m;
    }
    @Override
    public String toString() {
        return"Machina" + id + ": " + (state.equals(State.END)? "complete" : state);
    }
}
```

> #### **`CompletableFuture`** 可以使用 **`completedFuture()`** 将它感兴趣的对象进行包装。

```
import java.util.concurrent.*;
public class CompletedMachina {
    public static void main(String[] args) {
        CompletableFuture<Machina> cf =
        CompletableFuture.completedFuture(
            new Machina(0));
        try {
            Machina m = cf.get();  // Doesn't block
        } catch(InterruptedException | ExecutionException e) {
        	throw new RuntimeException(e);
        }
    }
}
```

> #### **`completedFuture()`** 创建一个“已经完成”的 **`CompletableFuture`** 。注意 **`CompletableFuture`** 被输入到它包含的对象。这个很重要。
>
> #### 当我们将 **`handle()`** 包装在 **`CompletableFuture`** 中时，发现我们可以在 **`CompletableFuture`** 上添加操作来处理所包含的对象:

```
import java.util.concurrent.*;
public class CompletableApply {
    public static void main(String[] args) {
        CompletableFuture<Machina> cf =
        CompletableFuture.completedFuture(new Machina(0));
        CompletableFuture<Machina> cf2 = cf.thenApply(Machina::work);
        CompletableFuture<Machina> cf3 = cf2.thenApply(Machina::work);
        CompletableFuture<Machina> cf4 = cf3.thenApply(Machina::work);
        CompletableFuture<Machina> cf5 = cf4.thenApply(Machina::work);
    }
}
```

> #### 我们可以消除中间变量并将操作链接在一起，就像我们使用 `Streams` 一样：

```
import onjava.Timer;
public class CompletableApplyChained {
    public static void main(String[] args) {
        Timer timer = new Timer();
        CompletableFuture<Machina> cf =
        CompletableFuture.completedFuture(new Machina(0))
                  .thenApply(Machina::work)
                  .thenApply(Machina::work)
                  .thenApply(Machina::work)
                  .thenApply(Machina::work);
        System.out.println(timer.duration());
    }
}
```

> #### **`CompletableFutures`** 的一个重要好处是它们鼓励使用私有子类原则（不共享任何东西）。默认情况下，使用 **`thenApply()`** 来应用一个不对外通信的函数 ———— 它只需要一个参数并返回一个结果。

> #### 回调 `thenApply()` 一旦开始一个操作，在完成所有任务之前，不会完成 **`CompletableFuture`** 的构建。但当我们想要继续前进并执行其他操作时，可以通过 `thenApplyAsync()` 来实现此目的：

```
// concurrent/CompletableApplyAsync.java
import java.util.concurrent.*;
import onjava.*;
public class CompletableApplyAsync {
    public static void main(String[] args) {
        Timer timer = new Timer();
        CompletableFuture<Machina> cf =
            CompletableFuture.completedFuture(new Machina(0))
                .thenApplyAsync(Machina::work)
                .thenApplyAsync(Machina::work)
                .thenApplyAsync(Machina::work)
                .thenApplyAsync(Machina::work);
        System.out.println(timer.duration());
        System.out.println(cf.join());
        System.out.println(timer.duration());
    }
}
```

> #### `同步调用` 意味着：“当你完成工作时，才返回”，而 `异步调用` 以意味着： “立刻返回并继续后续工作”。
>
> #### 如果没有回调 `cf.join()` 方法，程序会在完成其工作之前退出。而 `cf.join()` 直到 cf 操作完成之前，阻止 `main()` 进程结束。

> #### 当你查看`CompletableFuture`的 `Javadoc` 时，你会看到它有很多方法，但这个方法的大部分来自不同操作的变体。
>
> #### 下面的示例展示了所有"基本"操作，这些操作既不涉及组合两个 `CompletableFuture`，也不涉及异常

```
package onjava;
import java.util.concurrent.*;

public class CompletableUtilities {
  public static void showr(CompletableFuture<?> c) {
    try { System.out.println(c.get()); } 
    catch(InterruptedException | ExecutionException e) {
    	throw new RuntimeException(e);
    }
  }
  public static void voidr(CompletableFuture<Void> c) {
    try { c.get(); } 
    catch(InterruptedException | ExecutionException e) {
      	throw new RuntimeException(e);
    }
  }
}
import java.util.concurrent.*;
import static onjava.CompletableUtilities.*;

public class CompletableOperations {
    static CompletableFuture<Integer> cfi(int i) {
        return CompletableFuture.completedFuture( Integer.valueOf(i));
    }

    public static void main(String[] args) {
        showr(cfi(1)); // Basic test
        voidr(cfi(2).runAsync(() ->
                System.out.println("runAsync")));
        voidr(cfi(3).thenRunAsync(() ->
                System.out.println("thenRunAsync")));
        voidr(CompletableFuture.runAsync(() ->
                System.out.println("runAsync is static")));
        showr(CompletableFuture.supplyAsync(() -> 99));
        voidr(cfi(4).thenAcceptAsync(i ->
                System.out.println("thenAcceptAsync: " + i)));
        showr(cfi(5).thenApplyAsync(i -> i + 42));
        showr(cfi(6).thenComposeAsync(i -> cfi(i + 99)));
        CompletableFuture<Integer> c = cfi(7);
        c.obtrudeValue(111);
        showr(c);
        showr(cfi(8).toCompletableFuture());
        c = new CompletableFuture<>();
        c.complete(9);
        showr(c);
        c = new CompletableFuture<>();
        c.cancel(true);
        System.out.println("cancelled: " +
                c.isCancelled());
        System.out.println("completed exceptionally: " +
                c.isCompletedExceptionally());
        System.out.println("done: " + c.isDone());
        System.out.println(c);
        c = new CompletableFuture<>();
        System.out.println(c.getNow(777));
        c = new CompletableFuture<>();
        c.thenApplyAsync(i -> i + 42)
                .thenApplyAsync(i -> i * 12);
        System.out.println("dependents: " +
                c.getNumberOfDependents());
        c.thenApplyAsync(i -> i / 2);
        System.out.println("dependents: " +
                c.getNumberOfDependents());
    }
}
```







### (2) 结合 CompletableFuture

> #### 第二种类型的 `CompletableFuture` 方法采用两种 `CompletableFuture` 并以各异方式将它们组合在一起。就像两个人在比赛一样, 一个`CompletableFuture`通常比另一个更早地到达终点。

```
// concurrent/Workable.java
import java.util.concurrent.*;
import onjava.Nap;

public class Workable {
    String id;
    final double duration;

    public Workable(String id, double duration) {
        this.id = id;
        this.duration = duration;
    }

    @Override
    public String toString() { return "Workable[" + id + "]"; }

    public static Workable work(Workable tt) {
        new Nap(tt.duration); // Seconds
        tt.id = tt.id + "W";
        System.out.println(tt);
        return tt;
    }

    public static CompletableFuture<Workable> make(String id, double duration) {
        return CompletableFuture
                .completedFuture(new Workable(id, duration))
                .thenApplyAsync(Workable::work);
    }
}
```

> #### 现在我们创建多个竞争的 `CompletableFuture` ，并使用 `CompletableFuture` 库中的各种方法进行操作：

```
import java.util.concurrent.*;
import static onjava.CompletableUtilities.*;

public class DualCompletableOperations {
    static CompletableFuture<Workable> cfA, cfB;

    static void init() {
        cfA = Workable.make("A", 0.15);
        cfB = Workable.make("B", 0.10); // Always wins
    }

    static void join() {
        cfA.join();
        cfB.join();
        System.out.println("*****************");
    }

    public static void main(String[] args) {
        init();
        voidr(cfA.runAfterEitherAsync(cfB, () ->
                System.out.println("runAfterEither")));
        join();

        init();
        voidr(cfA.runAfterBothAsync(cfB, () ->
                System.out.println("runAfterBoth")));
        join();

        init();
        showr(cfA.applyToEitherAsync(cfB, w -> {
            System.out.println("applyToEither: " + w);
            return w;
        }));
        join();

        init();
        voidr(cfA.acceptEitherAsync(cfB, w -> {
            System.out.println("acceptEither: " + w);
        }));
        join();

        init();
        voidr(cfA.thenAcceptBothAsync(cfB, (w1, w2) -> {
            System.out.println("thenAcceptBoth: "
                    + w1 + ", " + w2);
        }));
        join();

        init();
        showr(cfA.thenCombineAsync(cfB, (w1, w2) -> {
            System.out.println("thenCombine: "
                    + w1 + ", " + w2);
            return w1;
        }));
        join();

        init();
        CompletableFuture<Workable>
                cfC = Workable.make("C", 0.08),
                cfD = Workable.make("D", 0.09);
        CompletableFuture.anyOf(cfA, cfB, cfC, cfD)
                .thenRunAsync(() ->
                        System.out.println("anyOf"));
        join();

        init();
        cfC = Workable.make("C", 0.08);
        cfD = Workable.make("D", 0.09);
        CompletableFuture.allOf(cfA, cfB, cfC, cfD)
                .thenRunAsync(() ->
                        System.out.println("allOf"));
        join();
    }
}
```







### (3) 模拟

> #### 模拟制作蛋糕的过程：

```
import java.util.concurrent.*;
import onjava.Nap;

public class Batter {
    static class Eggs {}

    static class Milk {}

    static class Sugar {}

    static class Flour {}

    static <T> T prepare(T ingredient) {
        new Nap(0.1);
        return ingredient;
    }

    static <T> CompletableFuture<T> prep(T ingredient) {
        return CompletableFuture
                .completedFuture(ingredient)
                .thenApplyAsync(Batter::prepare);
    }

    public static CompletableFuture<Batter> mix() {
        CompletableFuture<Eggs> eggs = prep(new Eggs());
        CompletableFuture<Milk> milk = prep(new Milk());
        CompletableFuture<Sugar> sugar = prep(new Sugar());
        CompletableFuture<Flour> flour = prep(new Flour());
        CompletableFuture
                .allOf(eggs, milk, sugar, flour)
                .join();
        new Nap(0.1); // Mixing time
        return CompletableFuture.completedFuture(new Batter());
    }
}
```

> #### 每种原料都需要一些时间来准备。`allOf()` 等待所有的配料都准备好，然后使用更多些的时间将其混合成面糊。接下来，我们把单批面糊放入四个平底锅中烘烤。产品作为 `CompletableFutures` 流返回：

```
import java.util.concurrent.*;
import java.util.stream.*;
import onjava.Nap;

public class Baked {
    static class Pan {}

    static Pan pan(Batter b) {
        new Nap(0.1);
        return new Pan();
    }

    static Baked heat(Pan p) {
        new Nap(0.1);
        return new Baked();
    }

    static CompletableFuture<Baked> bake(CompletableFuture<Batter> cfb) {
        return cfb
                .thenApplyAsync(Baked::pan)
                .thenApplyAsync(Baked::heat);
    }

    public static Stream<CompletableFuture<Baked>> batch() {
        CompletableFuture<Batter> batter = Batter.mix();
        return Stream.of(
                bake(batter),
                bake(batter),
                bake(batter),
                bake(batter)
        );
    }
}
```

> #### 最后，我们制作了一批糖，并用它对蛋糕进行糖化：

```
import java.util.concurrent.*;
import java.util.stream.*;
import onjava.Nap;

final class Frosting {
    private Frosting() {}

    static CompletableFuture<Frosting> make() {
        new Nap(0.1);
        return CompletableFuture
                .completedFuture(new Frosting());
    }
}

public class FrostedCake {
    public FrostedCake(Baked baked, Frosting frosting) { new Nap(0.1); }

    @Override
    public String toString() { return "FrostedCake"; }

    public static void main(String[] args) {
        Baked.batch().forEach(
                baked -> baked
                        .thenCombineAsync(Frosting.make(),
                                (cake, frosting) ->
                                        new FrostedCake(cake, frosting))
                        .thenAcceptAsync(System.out::println)
                        .join());
    }
}
```







### (4) 异常

> #### `CompletableFuture` 也会缓冲异常。这些在处理时调用者是无感的，仅当你尝试提取结果时才会被告知。

```
import java.util.concurrent.*;
public class Breakable {
    String id;
    private int failcount;

    public Breakable(String id, int failcount) {
        this.id = id;
        this.failcount = failcount;
    }

    @Override
    public String toString() { return "Breakable_" + id + " [" + failcount + "]"; }

    public static Breakable work(Breakable b) {
        if (--b.failcount == 0) {
            System.out.println("Throwing Exception for " + b.id + "");
            throw new RuntimeException("Breakable_" + b.id + " failed");
        }
        System.out.println(b);
        return b;
    }
}
```

> #### 在下面示例 `test()` 方法中，在测试`A`到`E`中，你可以从输出中看到抛出了异常，但它们从未出现:

```
import java.util.concurrent.*;
public class CompletableExceptions {
    static CompletableFuture<Breakable> test(String id, int failcount) {
        return CompletableFuture.completedFuture(
                new Breakable(id, failcount))
                .thenApply(Breakable::work)
                .thenApply(Breakable::work)
                .thenApply(Breakable::work)
                .thenApply(Breakable::work);
    }

    public static void main(String[] args) {
        // Exceptions don't appear ...
        test("A", 1);
        test("B", 2);
        test("C", 3);
        test("D", 4);
        test("E", 5);
        // ... until you try to fetch the value:
        try {
            test("F", 2).get(); // or join()
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        // Test for exceptions:
        System.out.println(test("G", 2).isCompletedExceptionally());
        // Counts as "done":
        System.out.println(test("H", 2).isDone());
        // Force an exception:
        CompletableFuture<Integer> cfi = new CompletableFuture<>();
        System.out.println("done? " + cfi.isDone());
        cfi.completeExceptionally(new RuntimeException("forced"));
        try {
            cfi.get();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
```

> #### 在连接或获取结果时，我们使用 `CompletableFuture` 提供的更复杂的机制来自动响应异常，而不是使用粗糙的 `try-catch`。

> #### 你可以使用与我们看到的所有 `CompletableFuture` 相同的表单来完成此操作:在链中插入一个 `CompletableFuture` 调用。有三个选项 `exceptionally()`，`handle()`， `whenComplete()`:

```
import java.util.concurrent.*;
public class CatchCompletableExceptions {
    static void handleException(int failcount) {
        CompletableExceptions
                .test("exceptionally", failcount)
                .exceptionally((ex) -> { // Function
                    if (ex == null)
                        System.out.println("I don't get it yet");
                    return new Breakable(ex.getMessage(), 0);
                })
                .thenAccept(str ->
                        System.out.println("result: " + str));

        // Create a new result (recover):
        CompletableExceptions
                .test("handle", failcount)
                .handle((result, fail) -> { // BiFunction
                    if (fail != null)
                        return "Failure recovery object";
                    else
                        return result + " is good";
                })
                .thenAccept(str ->
                        System.out.println("result: " + str));

        // Do something but pass the same result through:
        CompletableExceptions
                .test("whenComplete", failcount)
                .whenComplete((result, fail) -> { // BiConsumer
                    if (fail != null)
                        System.out.println("It failed");
                    else
                        System.out.println(result + " OK");
                })
                .thenAccept(r ->
                        System.out.println("result: " + r));
    }

    public static void main(String[] args) {
        System.out.println("**** Failure Mode ****");
        handleException(2);
        System.out.println("**** Success Mode ****");
        handleException(0);
    }
}
```

> - #### `exceptionally()` 参数仅在出现异常时才运行。`exceptionally()` 局限性在于，该函数只能返回输入类型相同的值。
>
> - #### `exceptionally()` 通过将一个好的对象插入到流中来恢复到一个可行的状态。
>
> - #### `handle()` 一致被调用来查看是否发生异常（必须检查 fail 是否为 true）。
>
>     - ##### 但是 `handle()` 可以生成任何新类型，所以它允许执行处理，而不是像使用 `exceptionally()`那样简单地恢复。
>
>     - ##### `whenComplete()` 类似于 handle()，同样必须测试它是否失败，但是参数是一个消费者，并且不修改传递给它的结果对象。







### (5) 流异常

> #### 看看 **`CompletableFuture`** 异常与流异常有何不同：

```
import java.util.concurrent.*;
import java.util.stream.*;
public class StreamExceptions {
    
    static Stream<Breakable> test(String id, int failcount) {
        return Stream.of(new Breakable(id, failcount))
                .map(Breakable::work)
                .map(Breakable::work)
                .map(Breakable::work)
                .map(Breakable::work);
    }

    public static void main(String[] args) {
        // No operations are even applied ...
        test("A", 1);
        test("B", 2);
        Stream<Breakable> c = test("C", 3);
        test("D", 4);
        test("E", 5);
        // ... until there's a terminal operation:
        System.out.println("Entering try");
        try {
            c.forEach(System.out::println);   // [1]
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
```

> #### 使用 `CompletableFuture` ，我们可以看到测试A到E的进展，但是使用流，在你应用一个终端操作(e.g. `forEach()`) 之前，什么都不会暴露给客户。







### (6) 检查性异常

> #### `CompletableFuture` 和 `parallel Stream` 都不支持包含检查性异常的操作。相反，你必须在调用操作时处理检查到的异常，这会产生不太优雅的代码：

```
// concurrent/ThrowsChecked.java
import java.util.stream.*;
import java.util.concurrent.*;

public class ThrowsChecked {
    class Checked extends Exception {}

    static ThrowsChecked nochecked(ThrowsChecked tc) { return tc; }

    static ThrowsChecked withchecked(ThrowsChecked tc) throws Checked {
        return tc;
    }

    static void testStream() {
        Stream.of(new ThrowsChecked())
                .map(ThrowsChecked::nochecked)
                // .map(ThrowsChecked::withchecked); // [1]
                .map(
                        tc -> {
                            try {
                                return withchecked(tc);
                            } catch (Checked e) {
                                throw new RuntimeException(e);
                            }
                        });
    }

    static void testCompletableFuture() {
        CompletableFuture
                .completedFuture(new ThrowsChecked())
                .thenApply(ThrowsChecked::nochecked)
                // .thenApply(ThrowsChecked::withchecked); // [2]
                .thenApply(
                        tc -> {
                            try {
                                return withchecked(tc);
                            } catch (Checked e) {
                                throw new RuntimeException(e);
                            }
                        });
    }
}
```











## 11. 死锁

> #### 得到了一个任务之间相互等待的连续循环， 没有哪个线程能继续， 这称之为 ***`死锁`*** 。
>
> #### 真正的问题在于，程序看起来工作良好，但是具有潜在的死锁危险。这时，死锁可能发生，而事先却没有任何征兆。

> #### 哲学家问题：**`StickHolder`** 类通过将单根筷子保持在大小为 1 的 **`BlockingQueue`** 中来管理它：

```
import java.util.concurrent.*;
public class StickHolder {
    private static class Chopstick {}

    private Chopstick stick = new Chopstick();
    private BlockingQueue<Chopstick> holder = new ArrayBlockingQueue<>(1);

    public StickHolder() { putDown(); }

    public void pickUp() {
        try {
            holder.take(); // Blocks if unavailable
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    public void putDown() {
        try {
            holder.put(stick);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
```

> #### 上述类中的所有线程安全都是通过 `BlockingQueue` 实现的。

```
public class Philosopher implements Runnable {
    private final int seat;
    private final StickHolder left, right;

    public Philosopher(int seat, StickHolder left, StickHolder right) {
        this.seat = seat;
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() { return "P" + seat; }

    @Override
    public void run() {
        while (true) {
            // System.out.println("Thinking");   // [1]
            right.pickUp();
            left.pickUp();
            System.out.println(this + " eating");
            right.putDown();
            left.putDown();
        }
    }
}
```

> #### 结果是一个看似无辜的程序陷入了死锁：

```
import java.util.*;
import java.util.concurrent.*;
import onjava.Nap;

public class DiningPhilosophers {
    private StickHolder[] sticks;
    private Philosopher[] philosophers;

    public DiningPhilosophers(int n) {
        sticks = new StickHolder[n];
        Arrays.setAll(sticks, i -> new StickHolder());
        philosophers = new Philosopher[n];
        Arrays.setAll(philosophers, i ->
                new Philosopher(i, sticks[i], sticks[(i + 1) % n]));    // [1]
        // Fix by reversing stick order for this one:
        // philosophers[1] =                     // [2]
        //   new Philosopher(0, sticks[0], sticks[1]);
        Arrays.stream(philosophers)
                .forEach(CompletableFuture::runAsync); // [3]
    }

    public static void main(String[] args) {
        // Returns right away:
        new DiningPhilosophers(5);               // [4]
        // Keeps main() from exiting:
        new Nap(3, "Shutdown");
    }
}
```

> #### 当以下四个条件同时满足时，就会发生死锁：
>
> - #### 互斥条件。任务使用的资源中至少有一个不能共享的。 这里，一根筷子一次就只能被一个哲学家使用。
>
> - #### 至少有一个任务它必须持有一个资源且正在等待获取一个被当前别的任务持有的资源。也就是说，要发生死锁，哲学家必须拿着一根筷子并且等待另一根。
>
> - #### 资源不能被任务抢占， 任务必须把资源释放当作普通事件。哲学家很有礼貌，他们不会从其它哲学家那里抢筷子。
>
> - #### 必须有循环等待， 这时，一个任务等待其它任务所持有的资源， 后者又在等待另一个任务所持有的资源， 这样一直下去，知道有一个任务在等待第一个任务所持有的资源， 使得大家都被锁住。
>
> #### 防止死锁的一种简单方法是打破第四个条件。











## 12. 构造方法非线程安全

> #### 对象的构造过程如其他操作一样，也会受到共享内存并发问题的影响，只是作用机制可能更微妙罢了。

```
public interface HasID {
    int getID();
}
public class StaticIDField implements HasID {
    private static int counter = 0;
    private int id = counter++;
    public int getID() { return id; }
}
```

> #### 当我们运行多个用于创建此类对象的线程时：

```
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import java.util.concurrent.*;
import com.google.common.collect.Sets;
public class IDChecker {
    public static final int SIZE = 100_000;

    static class MakeObjects implements Supplier<List<Integer>> {
        private Supplier<HasID> gen;

        MakeObjects(Supplier<HasID> gen) { this.gen = gen; }

        @Override 
        public List<Integer> get() {
            return Stream.generate(gen)
            .limit(SIZE)
            .map(HasID::getID)
            .collect(Collectors.toList());
        }
    }

    public static void test(Supplier<HasID> gen) {
        CompletableFuture<List<Integer>>
        groupA = CompletableFuture.supplyAsync(new MakeObjects(gen)),
        groupB = CompletableFuture.supplyAsync(new MakeObjects(gen));

        groupA.thenAcceptBoth(groupB, (a, b) -> {
            System.out.println(
                Sets.intersection(
                Sets.newHashSet(a),
                Sets.newHashSet(b)).size());
            }).join();
    }
}
```

> #### **`MakeObjects`** 类是一个生产者类，包含一个能够产生 List< Intege > 类型的列表对象的 `get()` 方法。通过从每个 `HasID` 对象提取 `ID` 并放入列表中来生成这个列表对象。
>
> #### 而 `test()` 方法则创建了两个并行的 **CompletableFuture** 对象，用于运行 **MakeObjects** 生产者类，然后获取运行结果。
>
> #### 使用 `Guava` 库中的 `Sets.intersection()` 方法，计算出这两个返回的 List< Integer > 对象中有多少相同的 `ID`

```
public class TestStaticIDField {
    public static void main(String[] args) {
        IDChecker.test(StaticIDField::new);
    }
}
/*Outpit: 13287*/
```

> #### 显然纯静态 `int` 用于构造过程并不是线程安全的。让我们使用 `AtomicInteger` 来使其变为线程安全的：

```
import java.util.concurrent.atomic.*;
public class GuardedIDField implements HasID {  
    private static AtomicInteger counter = new  AtomicInteger();

    private int id = counter.getAndIncrement();

    public int getID() { return id; }

    public static void main(String[] args) {                
        IDChecker.test(GuardedIDField::new);
    }
}
/*Output: 0*/
```

> #### 同步构造器并不被 java 语言所支持，但是通过使用同步语块来创建你自己的同步构造器是可能的。构造器实际上只是一个静态方法，因此同步构造器实际上会锁定该类的 Class 对象。

```
import java.util.concurrent.atomic.*;

class SyncConstructor implements HasID{
    private final int id;
    private static Object constructorLock = new Object();

    SyncConstructor(SharedArg sa){
        synchronized (constructorLock){ id = sa.get(); }
    }

    @Override
    public int getID(){ return id; }
}

public class SynchronizedConstructor{
    public static void main(String[] args){
        Unsafe unsafe = new Unsafe();
        IDChecker.test(() -> new SyncConstructor(unsafe));
    }
}
/*Output: 0*/
```

> #### **`Unsafe`** 类的共享使用现在就变得安全了。另一种方法是将构造器设为私有，并提供一个静态 `Factory` 方法来生成新对象：

```
// concurrent/SynchronizedFactory.java
import java.util.concurrent.atomic.*;

final class SyncFactory implements HasID{
    private final int id;

    private SyncFactory(SharedArg sa){ id = sa.get(); }

    @Override
    public int getID(){ return id; }

    public static synchronized SyncFactory factory(SharedArg sa){ return new SyncFactory(sa); }
}

public class SynchronizedFactory{
    public static void main(String[] args){
        Unsafe unsafe = new Unsafe();
        IDChecker.test(() -> SyncFactory.factory(unsafe));
    }
}
/*Output: 0*/
```











## 13. 复杂性和代价

> #### 假设我们正在做披萨：

```
import onjava.Nap;
public class Pizza{
    public enum Step{
        DOUGH(4), ROLLED(1), SAUCED(1), CHEESED(2),
        TOPPED(5), BAKED(2), SLICED(1), BOXED(0);
        int effort;// Needed to get to the next step 

        Step(int effort){ this.effort = effort; }

        Step forward(){
            if (equals(BOXED)) return BOXED;
            new Nap(effort * 0.1);
            return values()[ordinal() + 1];
        }
    }

    private Step step = Step.DOUGH;
    private final int id;

    public Pizza(int id){ this.id = id; }

    public Pizza next(){
        step = step.forward();
        System.out.println("Pizza " + id + ": " + step);
        return this;
    }

    public Pizza next(Step previousStep){
        if (!step.equals(previousStep))
            throw new IllegalStateException("Expected " + previousStep + " but found " + step);
        return next();
    }

    public Pizza roll(){ return next(Step.DOUGH); }

    public Pizza sauce(){ return next(Step.ROLLED); }

    public Pizza cheese(){ return next(Step.SAUCED); }

    public Pizza toppings(){ return next(Step.CHEESED); }

    public Pizza bake(){ return next(Step.TOPPED); }

    public Pizza slice(){ return next(Step.BAKED); }

    public Pizza box(){ return next(Step.SLICED); }

    public boolean complete(){ return step.equals(Step.BOXED); }

    @Override
    public String toString(){
        return "Pizza" + id + ": " + (step.equals(Step.BOXED) ? "complete" : step);
    }
}
```

> #### 如果只有一个人在做披萨，那么所有步骤都是线性进行的：

```
import onjava.Timer;

public class OnePizza{
    public static void main(String[] args){
        Pizza za = new Pizza(0);
        System.out.println(Timer.duration(() -> {
            while (!za.complete()) za.next();
        }));
    }
}
```

> #### 为了加快速度，我们可以从尝试并行流方法开始：

```
import onjava.Timer;

public class PizzaStreams{
    static final int QUANTITY = 5;

    public static void main(String[] args){
        Timer timer = new Timer();
        IntStream.range(0, QUANTITY)
            .mapToObj(Pizza::new)
            .parallel()
            .forEach(za -> { while(!za.complete()) za.next(); });             
        System.out.println(timer.duration());
    }
}
```

> #### **`PizzaStreams`** 类产生的每个并行流在 `forEach()` 内完成所有工作，如果我们将各个步骤用映射的方式一步步处理，情况会有所不同吗？

```
import java.util.*;
import java.util.stream.*;
import onjava.Timer;

public class PizzaParallelSteps{
    static final int QUANTITY = 5;

    public static void main(String[] args){
        Timer timer = new Timer();
        IntStream.range(0, QUANTITY)
            .mapToObj(Pizza::new)
            .parallel()
            .map(Pizza::roll)
            .map(Pizza::sauce)
            .map(Pizza::cheese)
            .map(Pizza::toppings)
            .map(Pizza::bake)
            .map(Pizza::slice)
            .map(Pizza::box)
            .forEach(za -> System.out.println(za));
        System.out.println(timer.duration());
    }
} 
```

> #### 结果是并不会有不同，因为每个披萨都需要按顺序执行步骤。因此，没法通过分步执行操作来进一步提高速度。
>
> #### 我们可以使用 `CompletableFutures` 重写这个例子：

```
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;
import onjava.Timer;

public class CompletablePizza{
    static final int QUANTITY = 5;

    public static CompletableFuture<Pizza> makeCF(Pizza za){
        return CompletableFuture
                .completedFuture(za)
            .thenApplyAsync(Pizza::roll)
            .thenApplyAsync(Pizza::sauce)
            .thenApplyAsync(Pizza::cheese)
            .thenApplyAsync(Pizza::toppings)
            .thenApplyAsync(Pizza::bake)
            .thenApplyAsync(Pizza::slice)
            .thenApplyAsync(Pizza::box);
    }

    public static void show(CompletableFuture<Pizza> cf){
        try{
            System.out.println(cf.get());
        } catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args){
        Timer timer = new Timer();
        List<CompletableFuture<Pizza>> pizzas =
        	IntStream.range(0, QUANTITY)
            	.mapToObj(Pizza::new)
            	.map(CompletablePizza::makeCF)
            	.collect(Collectors.toList());
        System.out.println(timer.duration());
        pizzas.forEach(CompletablePizza::show);
        System.out.println(timer.duration());
    }
}
```

> #### ***`并行流`*** 和 ***`CompletableFutures`*** 是 Java 并发工具箱中最先进发达的技术。 你应该始终首先选择其中之一。
>
> - #### 当一个问题很容易并行处理时，或者说，很容易把数据分解成相同的、易于处理的各个部分时，使用并行流方法处理最为合适。
>
> - #### 而当工作的各个部分内容各不相同时，使用 **`CompletableFutures`** 是最好的选择。比起面向数据，**`CompletableFutures`** 更像是面向任务。











## 14. 本章小结

> #### 如果并发很容易，则没有理由拒绝并发。正因为并发实际上很难，所以应该仔细考虑是否值得为此付出努力，并考虑能否以其他方式提升速度。

### (1) 缺点

> #### 并发编程的主要缺点是：
>
> - #### 在线程等待共享资源时会降低速度。
>
> - #### 线程管理产生额外 CPU 开销。
>
> - #### 糟糕的设计决策带来无法弥补的复杂性。
>
> - #### 诸如饥饿，竞速，死锁和活锁之类的问题。
>
> - #### 跨平台的不一致。







### (2) 共享内存陷阱

> #### 并发性的主要困难之一是因为可能有多个任务共享一个资源，并且必须确保多个任务不会同时读取和更改该资源。
>
> #### 众所周知的并发原则之一是：永远无法相信使用共享内存并发的程序可以正常工作。可以轻易发现它是错误的，但永远无法证明它是正确的。 







### (3) This Albatross is Big

> #### 事实证明，在 Java 的后续版本中添加的许多库解决方案都是无效的，甚至是无用的。 幸运的是，Java 8 中的并行 **`Streams`** 和 **`CompletableFutures`** 都非常有价值。但是当你使用旧代码时，仍然会遇到旧的解决方案。







### (4) 其它类库

> #### 本章重点介绍了相对安全易用的并行工具流和 **`CompletableFutures`** ，并且仅涉及 Java 标准库中一些更细粒度的工具。
>
> #### 附录：[并发底层原理 ](https://njuics.github.io/OnJava8/#/./Appendix-Low-Level-Concurrency)涵盖了其他一些内容，但是你还可以探索 **`java.util.concurrent`** 的 `Javadocs`。 但是要小心，因为某些库组件已被新的更好的组件所取代。







### (5) 考虑为并发设计的语言

> #### 请谨慎地使用并发。 如果需要使用它，请尝试使用最现代的方法：并行流或 **`CompletableFutures`** 。
>
> #### 如果你的并发问题变得比高级 Java 构造所支持的问题更大且更复杂，请考虑使用专为并发设计的语言，仅在需要并发的程序部分中使用这种语言是有可能的。







### (6) 拓展阅读

> - #### `《Java Concurrency in Practice》`，出自 Brian Goetz，Tim Peierls， Joshua Bloch，Joseph Bowbeer，David Holmes 和 Doug Lea (Addison Wesley，2006 年)
>
> - #### `《Java Concurrency in Practice》第二版`，出自 Doug Lea (Addison-Wesley，2000 年)















# [第二十五章 设计模式](https://njuics.github.io/OnJava8/#/book/25-Patterns?id=第二十五章-设计模式)

## 1. 概念

> #### 最初，你可以将模式视为解决特定类问题的一种特别巧妙且有深刻见解的方法。
>
> #### 式在程序中体现了一个完整的思想，因此它有时会出现在分析阶段或高级设计阶段。因为模式在代码中有一个直接的实现，所以你可能不会期望模式在低级设计或实现之前出现。

> #### 模式的基本概念也可以看作是程序设计的基本概念: ***添加抽象层*** 。为了 ***将易变的事物与不变的事物分开*** ，我们会剥离特定的细节，从而抽象一些东西。
>
> #### 另一种方法是，一旦你发现程序的某些部分可能因某种原因而发生变化，你要保持这些变化不会引起整个代码中其他变化。
>
> #### 设计模式的目标是隔离代码中的更改。

> #### 有些人断言： ***设计模式代表语言的失败*** 。这是因为一个模式在 C++ 有意义，可能在 JAVA 或者其他语言中就没有意义。出于这个原因，当一个模式出现在设计模式书上，不意味着应用于你的编程语言是有用的。
>
> #### 但这个观点过于简单化。

### (1) 单例模式

> #### 也许单例模式是最简单的设计模式，它是一种提供一个且只有一个对象实例的方法。

```
interface Resource {
    int getValue();
    void setValue(int x);
}

/*
* 由于这不是从Cloneable基类继承而且没有添加可克隆性，
* 因此将其设置为final可防止通过继承添加可克隆性。
* 这也实现了线程安全的延迟初始化：
*/
final class Singleton {
    private static final class ResourceImpl implements Resource {
        private int i;
        private ResourceImpl(int i) { this.i = i; }
        public synchronized int getValue() { return i; }
        public synchronized void setValue(int x) { i = x; }
    }

    private static class ResourceHolder { private static Resource resource = new ResourceImpl(47); }
    public static Resource getResource() { return ResourceHolder.resource; }
}

public class SingletonPattern {
    public static void main(String[] args) {
        Resource r = Singleton.getResource();
        System.out.println(r.getValue());
        Resource s2 = Singleton.getResource();
        s2.setValue(9);
        System.out.println(r.getValue());
        try {     
             // 不能这么做，会发生：compile-time error（编译时错误）.     
             // Singleton s3 = (Singleton)s2.clone();    
             } catch(Exception e) {      
                 throw new RuntimeException(e);    
             }  
        }
} /* Output: 47 9 */
```

> #### 创建单例的关键是防止客户端程序员直接创建对象。这里是通过在 `Singleton` 类中将 `Resource` 的实现作为私有类来实现的，这样 `Resource` 类将会在 `Singleton` 类第一次被访问时创建，由于它是私有的，只能通过 `public getResource()` 方法访问。







### (2) 模式分类

> - #### ***`创建型`*** ： 如何创建对象。这通常涉及隔离对象创建的细节，这样你的代码就不依赖于具体的对象的类型。
>
> - #### ***`构造型`*** ： 设计对象以满足特定的项目约束。它们处理对象与其他对象连接的方式，以确保系统中的更改不需要更改这些连接。
>
> - #### ***`行为型`*** ： 处理程序中特定类型的操作的对象。这些封装要执行的过程，例如解释语言、实现请求、遍历序列或实现算法。











## 2. 构建应用程序框架

> #### 应用程序框架允许你从一个类或一组类开始，构建一个新的应用程序，重用现有类中的大部分代码，并根据需要覆盖一个或多个方法来定制应用程序。

### (1) 模板方法模式

> #### 应用程序框架中的一个基本概念是 ***`模板方法模式`*** ，它通常隐藏在底层，通过调用基类中的各种方法来驱动应用程序。
>
> #### `模板方法模式` 的一个重要特征是它是在基类中定义的，并且不能更改。它有时是一个 `private` 方法，但实际上总是 `final` 。它调用其它基类方法来完成它的工作。

```
abstract class ApplicationFramework {
    ApplicationFramework() { templateMethod(); }

    abstract void customize1();

    abstract void customize2();

    private void templateMethod() {
        IntStream.range(0, 5).forEach(
                n -> {
                    customize1();
                    customize2();
                });
    }
}

class MyApp extends ApplicationFramework {
    @Override
    void customize1() {  System.out.print("Hello "); }

    @Override
    void customize2() { System.out.println("World!"); }
}

public class TemplateMethod {
    public static void main(String[] args) {  new MyApp(); }
}
/* Output:
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
*/
```











## 2. 面向实现

> #### `代理模式` 和 `桥接模式` 都提供了在代码中使用的代理类;完成工作的真正类隐藏在这个代理类的后面。代理模式只是桥接模式的一种特殊情况。
>
> #### 基本思想很简单:从基类派生代理，同时派生一个或多个提供实现的类:创建代理对象时，给它一个可以调用实际工作类的方法的实现。
>
> #### 代理模式只有一个实现，而桥接模式有多个实现。

### (1) 代理模式

```
interface ProxyBase {
    void f();
    void g();
    void h();
}

class Proxy implements ProxyBase {
    private ProxyBase implementation;

    Proxy() { implementation = new Implementation(); }
    // Pass method calls to the implementation:
    @Override
    public void f() { implementation.f(); }
    @Override
    public void g() { implementation.g(); }
    @Override
    public void h() { implementation.h(); }
}

class Implementation implements ProxyBase {
    public void f() { System.out.println("Implementation.f()"); }

    public void g() { System.out.println("Implementation.g()"); }

    public void h() { System.out.println("Implementation.h()"); }
}

public class ProxyDemo {
    public static void main(String[] args) {
        Proxy p = new Proxy();
        p.f();
        p.g();
        p.h();
    }
}
/*
Output:
Implementation.f()
Implementation.g()
Implementation.h()
*/
```

> #### 具体实现不需要与代理对象具有相同的接口，只要代理对象以某种方式 ***代表具体实现的方法调用*** ，那么基本思想就算实现了。







### (2) 状态模式

> #### `状态模式` 向代理对象添加了更多的实现，以及在代理对象的生命周期内从一个实现切换到另一种实现的方法:

```
interface StateBase {
    void f();
    void g();
    void h();
    void changeImp(StateBase newImp);
}

class State implements StateBase {
    private StateBase implementation;

    State(StateBase imp) { implementation = imp; }

    @Override
    public void changeImp(StateBase newImp) { implementation = newImp; }
    @Override
    public void f() { implementation.f(); }
    @Override
    public void g() { implementation.g(); }
    @Override
    public void h() { implementation.h(); }
}

class Implementation1 implements StateBase {
    @Override
    public void f() { System.out.println("Implementation1.f()"); }
    @Override
    public void g() { System.out.println("Implementation1.g()"); }
    @Override
    public void h() { System.out.println("Implementation1.h()"); }
    @Override
    public void changeImp(StateBase newImp) { }
}

class Implementation2 implements StateBase {
    @Override
    public void f() { System.out.println("Implementation2.f()"); }
    @Override
    public void g() { System.out.println("Implementation2.g()"); }
    @Override
    public void h() { System.out.println("Implementation2.h()"); }
    @Override
    public void changeImp(StateBase newImp) { }
}

public class StateDemo {
    static void test(StateBase b) {
        b.f();
        b.g();
        b.h();
    }

    public static void main(String[] args) {
        StateBase b = new State(new Implementation1());
        test(b);
        b.changeImp(new Implementation2());
        test(b);
    }
}
/* Output:
Implementation1.f()
Implementation1.g()
Implementation1.h()
Implementation2.f()
Implementation2.g()
Implementation2.h()
*/
```

> #### 设计模式中描述的代理模式的常见用途如下:
>
> - #### `远程代理`。它在不同的地址空间中代理对象。远程方法调用(RMI)编译器rmic会自动为您创建一个远程代理。
>
> - #### `虚拟代理`。这提供了“懒加载”来根据需要创建“昂贵”的对象。
>
> - #### `保护代理`。当您希望对代理对象有权限访问控制时使用。
>
> - #### `智能引用`。要在被代理的对象被访问时添加其他操作。







### (3) 状态机

> #### ***`状态机`*** 利用一个结构自动地将实现更改到下一个。当前实现表示系统所处的状态，系统在不同状态下的行为不同。基本上，这是一个利用对象的“状态机”。

```
package patterns.state;

import onjava.Nap;

interface State { void run(); }

abstract class StateMachine {
    protected State currentState;

    protected abstract boolean changeState();

    protected final void runAll() {
        while (changeState()) currentState.run();
    }
}

class Wash implements State {
    @Override
    public void run() {
        System.out.println("Washing");
        new Nap(0.5);
    }
}

class Spin implements State {
    @Override
    public void run() {
        System.out.println("Spinning");
        new Nap(0.5);
    }
}

class Rinse implements State {
    @Override
    public void run() {
        System.out.println("Rinsing");
        new Nap(0.5);
    }
}

class Washer extends StateMachine {
    private int i = 0;
    private State[] states = {
            new Wash(), new Spin(),
            new Rinse(), new Spin(),
    };

    Washer() { runAll(); }

    @Override
    public boolean changeState() {
        if (i < states.length) {
            currentState = states[i++];
            return true;
        } else return false;
    }
}

public class StateMachineDemo {
    public static void main(String[] args) { new Washer(); }
}
/* Output:
Washing
Spinning
Rinsing
Spinning
*/
```











## 3. 工厂模式

> #### 如果创建对象的代码分布在整个应用程序中，那么在添加新类型时，我们将遇到相同的问题 ———— 我们仍然必须追查代码中新类型碍事的所有地方。恰好是类型的创建碍事，而不是类型的使用。但效果是一样的：添加了新类型可能会引起问题。
>
> #### 解决方案是强制对象的创建都通过通用工厂进行，而不是允许创建代码在整个系统中传播。
>
> #### 如果你程序中的所有代码都必须执行通过该工厂创建你的一个对象，那么在添加新类时只需要修改工厂即可。

```
public class BadShapeCreation extends RuntimeException {
    public BadShapeCreation(String msg) { super(msg); }
}
package patterns.shapes;
public class Shape {
    private static int counter = 0;
    private int id = counter++;
    @Override
    public String toString(){ return getClass().getSimpleName() + "[" + id + "]"; }
    
    public void draw() { System.out.println(this + " draw"); }
    
    public void erase() { System.out.println(this + " erase"); }
}
package patterns.shapes;
public class Circle extends Shape {}
package patterns.shapes;
public class Square extends Shape {}
package patterns.shapes;
public class Triangle extends Shape {} 
```

> #### 工厂是具有能够创建对象的方法的类。

```
package patterns.shapes;
public interface FactoryMethod { Shape create(String type); }
package patterns.shapes;
import java.util.stream.*;
public class FactoryTest {
    public static void test(FactoryMethod factory) {
        Stream.of("Circle", "Square", "Triangle",
                  "Square", "Circle", "Circle", "Triangle")
        .map(factory::create)
        .peek(Shape::draw)
        .peek(Shape::erase)
        .count(); // Terminal operation
    }
} 
```

> #### 创建工厂的一种方法是显式创建每种类型：

```
import java.util.*;
import java.util.stream.*;
import patterns.shapes.*;
public class ShapeFactory1 implements FactoryMethod {
    public Shape create(String type) {
        switch(type) {
            case "Circle": return new Circle();
            case "Square": return new Square();
            case "Triangle": return new Triangle();
            default: throw new BadShapeCreation(type);
        }
    }
    public static void main(String[] args) {
        FactoryTest.test(new ShapeFactory1());
    }
}
```

### (1) 动态工厂

> #### 前面例子中的静态 `create()` 方法强制所有创建操作都集中在一个位置，因此这是添加新类型的 `Shape` 时唯一必须更改代码的地方。
>
> #### 以下版本使用反射在首次需要时将 `Shape` 的构造器动态加载到工厂列表中：

```
import java.util.*;
import java.lang.reflect.*;
import java.util.stream.*;
import patterns.shapes.*;
public class ShapeFactory2 implements FactoryMethod {
    Map<String, Constructor> factories = new HashMap<>();
    static Constructor load(String id) {
        System.out.println("loading " + id);
        try {
            return Class.forName("patterns.shapes." + id)
                .getConstructor();
        } catch(ClassNotFoundException |
                NoSuchMethodException e) {
            throw new BadShapeCreation(id);
        }
    }
    public Shape create(String id) {
        try {
            return (Shape)factories
                .computeIfAbsent(id, ShapeFactory2::load)
                .newInstance();
        } catch(InstantiationException |
                IllegalAccessException |
                InvocationTargetException e) {
            throw new BadShapeCreation(id);
        }
    }
    public static void main(String[] args) {
        FactoryTest.test(new ShapeFactory2());
    }
}
```

> #### `create()`方法基于你传递给它的 **`String`** 参数生成新的 **`Shape`** ，但是在这里，它是通过在 **`HashMap`** 中查找作为键的 **`String`** 来实现的。 返回的值是一个构造器，该构造器用于通过调用 `newInstance()` 创建新的 **`Shape`** 对象。
>
> #### `create()`使用`map`的`computeIfAbsent()`方法来查找构造器。如果不存在则使用`load()`计算出该构造器，并将其插入到`map`中。







### (2) 多态工厂

> #### 我们可以从基本工厂中继承出不同类型的工厂。

```
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import patterns.shapes.*;
interface PolymorphicFactory { Shape create(); }
class RandomShapes implements Supplier<Shape> {
    private final PolymorphicFactory[] factories;
    private Random rand = new Random(42);
    
    RandomShapes(PolymorphicFactory... factories){ this.factories = factories; }
    
    public Shape get() {
        return factories[ rand.nextInt(factories.length)].create();
    }
}
public class ShapeFactory3 {
    public static void main(String[] args) {
        RandomShapes rs = new RandomShapes(
            Circle::new,
            Square::new,
            Triangle::new);
        Stream.generate(rs)
            .limit(6)
            .peek(Shape::draw)
            .peek(Shape::erase)
            .count();
    }
}
```

> #### **`RandomShapes`** 实现了 **`Supplier <Shape>`** ，因此可通过 `Stream.generate()` 创建 **`Stream`** 。 它的构造器采用 **`PolymorphicFactory`** 对象的可变参数列表。 变量参数列表以数组形式出现，因此列表是以数组形式在内部存储的。
>
> - #### `get()`方法随机获取此数组中一个对象的索引，并在结果上调用`create()`以产生新的**Shape**对象。 
>
> - #### 添加新类型的 **`Shape`** 时，**`RandomShapes`** 构造器是唯一需要更改的地方。 请注意，此构造器需要**`Supplier <Shape>`**。

> #### **`ShapeFactory2.java`** 可能会抛出异常，而使用此方法则没有任何异常 ———— 它在编译时完全确定。







### (3) 抽象工厂

> #### ***`抽象工厂模式`*** 看起来像我们之前所见的工厂对象，但拥有不是一个工厂方法而是几个工厂方法， 每个工厂方法都会创建不同种类的对象。
>
> #### 假设你正在创建一个通用游戏环境来支持不同类型的游戏。 使用抽象工厂看起来就像下文那样：

```
package patterns.abstractfactory;
import java.util.function.*;
interface Obstacle { void action(); }

interface Player { void interactWith(Obstacle o); }

class Kitty implements Player {
    @Override
    public void interactWith(Obstacle ob) {
        System.out.print("Kitty has encountered a ");
        ob.action();
    }
}

class KungFuGuy implements Player {
    @Override
    public void interactWith(Obstacle ob) {
        System.out.print("KungFuGuy now battles a ");
        ob.action();
    }
}

class Puzzle implements Obstacle {
    @Override
    public void action() { System.out.println("Puzzle"); }
}

class NastyWeapon implements Obstacle {
    @Override
    public void action() { System.out.println("NastyWeapon"); }
}
// The Abstract Factory:
class GameElementFactory {
    Supplier<Player> player;
    Supplier<Obstacle> obstacle;
}
// Concrete factories:
class KittiesAndPuzzles extends GameElementFactory {
    KittiesAndPuzzles() {
        player = Kitty::new;
        obstacle = Puzzle::new;
    }
}

class KillAndDismember extends GameElementFactory {
    KillAndDismember() {
        player = KungFuGuy::new;
        obstacle = NastyWeapon::new;
    }
}

public class GameEnvironment {
    private Player p;
    private Obstacle ob;

    public GameEnvironment(GameElementFactory factory) {
        p = factory.player.get();
        ob = factory.obstacle.get();
    }
    public void play() { p.interactWith(ob); }
    
    public static void main(String[] args) {
        GameElementFactory kp = new KittiesAndPuzzles(), kd = new KillAndDismember();
        GameEnvironment g1 = new GameEnvironment(kp), g2 = new GameEnvironment(kd);
        g1.play();
        g2.play();
    }
}
```

> #### 在游戏环境中， **`Player`** 对象与 **`Obstacle`** 对象进行交互，但是根据你所玩游戏的类型，存在不同类型的玩家和障碍物。 你可以通过选择特定的 **`GameElementFactory`** 来确定游戏的类型，然后 **`GameEnvironment`** 控制游戏的设置和玩法。











## 5. 函数对象

> #### 一个 ***`函数对象`*** 封装了一个函数。其特点就是将 ***被调用函数的选择*** 与那个 ***函数被调用的位置*** 进行解耦。

### (1) 命令模式

> #### ***`命令模式`*** 就是一个函数对象：一个作为对象的函数。我们可以将 ***`函数对象`*** 作为参数传递给其它方法或者对象，来执行特定的操作。

> - #### Java 8 之前，想要产生单个函数的效果，我们必须明确将方法包含在对象中，而这需要太多仪式；
>
> - #### 利用 Java 8 的 `lambda` 特性，命令模式的是心啊僵尸微不足道的

```
import java.util.*;

public class CommandPattern {
  public static void main(String[] args) {
    List<Runnable> macro = Arrays.asList(
      () -> System.out.print("Hello "),
      () -> System.out.print("World! "),
      () -> System.out.print("I'm the command pattern!")
    );
    macro.forEach(Runnable::run);
  }
}
/* Output:
Hello World! I'm the command pattern!
*/
```

> #### 命令模式的主要特点是 ***`允许向一个方法或者对象传递一个想要的动作`*** 。命令模式提供了将一系列需要一起执行的动作集进行排队的方法。







### (2) 策略模式

> #### ***`策略模式`*** 看起来像是从同一个基类继承而来的一系列 ***命令类*** 。但是`策略模式`具有和`命令模式`相同的结构 ———— ***一系列分层次的函数对象*** 。不同之处在于，这些函数对象的用法和策略模式不同。
>
> #### `命令模式` 在编码阶段提供了灵活性，而 `策略模式` 的灵活性在运行时才会体现出来。尽管如此，这种区别是非常模糊的。
>
> #### 而且 ***`策略模式`*** 可以添加一个 “上下文” ，这个上下文可以是一个代理类，用来控制对某个特定策略对象的选择和使用。就像 ***`桥接模式`*** 一样。

```
package patterns.strategy;
import java.util.function.*;
import java.util.*;

class FindMinima {
  	Function<List<Double>, List<Double>> algorithm;
}

class LeastSquares extends FindMinima {
  	LeastSquares() { algorithm = (line) -> Arrays.asList(1.1, 2.2); }
}

class Perturbation extends FindMinima {
  	Perturbation() { algorithm = (line) -> Arrays.asList(3.3, 4.4); }
}

class Bisection extends FindMinima {
  	Bisection() { algorithm = (line) -> Arrays.asList(5.5, 6.6); }
}

// The "Context" controls the strategy:
class MinimaSolver {
  	private FindMinima strategy;
    
  	MinimaSolver(FindMinima strat) { strategy = strat; }
    
  	List<Double> minima(List<Double> line) {
 		return strategy.algorithm.apply(line);
  }
  	void changeAlgorithm(FindMinima newAlgorithm) { strategy = newAlgorithm; }
}

public class StrategyPattern {
  	public static void main(String[] args) {
   		MinimaSolver solver = new MinimaSolver(new LeastSquares());
    	List<Double> line = Arrays.asList(
      			1.0, 2.0, 1.0, 2.0, -1.0,
     			3.0, 4.0, 5.0, 4.0 );
   		System.out.println(solver.minima(line)); 
    	solver.changeAlgorithm(new Bisection()); 
    	System.out.println(solver.minima(line));
  }
}
/* Output:
[1.1, 2.2]
[5.5, 6.6]
*/
```

> #### 我们可以通过将上下文注入到 `FindMinima` 中来简化我们的解决方法。

```
package patterns.strategy;
import java.util.function.*;
import java.util.*;

// "Context" is now incorporated:
class FindMinima2 {
  Function<List<Double>, List<Double>> algorithm;
  FindMinima2() { leastSquares(); } // default
  // The various strategies:
  void leastSquares() { algorithm = (line) -> Arrays.asList(1.1, 2.2); }
    
  void perturbation() { algorithm = (line) -> Arrays.asList(3.3, 4.4); }
    
  void bisection() { algorithm = (line) -> Arrays.asList(5.5, 6.6); }
    
  List<Double> minima(List<Double> line) { return algorithm.apply(line); }
}

public class StrategyPattern2 {
  public static void main(String[] args) {
    FindMinima2 solver = new FindMinima2();
    List<Double> line = Arrays.asList(
      1.0, 2.0, 1.0, 2.0, -1.0,
      3.0, 4.0, 5.0, 4.0 );
    System.out.println(solver.minima(line));
    solver.bisection();
    System.out.println(solver.minima(line));
  }
}
/* Output:
[1.1, 2.2]
[5.5, 6.6]
*/
```







### (3) 责任链模式

> #### ***`责任链模式`*** 可以被看作一个使用了策略对象的“递归的动态一般化”。 假设我们进行一次调用，在一个链序列中的每个策略都试图满足这个调用，这个过程知道有一个策略成功满足该调用或者到达链序列的末尾才结束。
>
> #### 使用责任链，一个方法会调用相同的基类方法，这个基类方法会调用基类方法的其他实现，如此反复直到达到某个终止条件。



```
package patterns.chain;
import java.util.*;
import java.util.function.*;

class Result {
  boolean success;
  List<Double> line;
  Result(List<Double> data) {
    success = true;
    line = data;
  }
  Result() {
    success = false;
    line = Collections.<Double>emptyList();
  }
}

class Fail extends Result {}

interface Algorithm { Result algorithm(List<Double> line); }

class FindMinima {
  public static Result leastSquares(List<Double> line) {
    System.out.println("LeastSquares.algorithm");
    boolean weSucceed = false;
    if(weSucceed) // Actual test/calculation here
      return new Result(Arrays.asList(1.1, 2.2));
    else // Try the next one in the chain:
      return new Fail();
  }
  public static Result perturbation(List<Double> line) {
    System.out.println("Perturbation.algorithm");
    boolean weSucceed = false;
    if(weSucceed) // Actual test/calculation here
      return new Result(Arrays.asList(3.3, 4.4));
    else
      return new Fail();
  }
  public static Result bisection(List<Double> line) {
    System.out.println("Bisection.algorithm");
    boolean weSucceed = true;
    if(weSucceed) // Actual test/calculation here
      return new Result(Arrays.asList(5.5, 6.6));
    else
      return new Fail();
    }
  static List<Function<List<Double>, Result>>
    algorithms = Arrays.asList(
      FindMinima::leastSquares,
      FindMinima::perturbation,
      FindMinima::bisection
    );
  public static Result minima(List<Double> line) {
    for(Function<List<Double>, Result> alg :
        algorithms) {
      Result result = alg.apply(line);
      if(result.success)
        return result;
    }
    return new Fail();
  }
}

public class ChainOfResponsibility {
  public static void main(String[] args) {
    FindMinima solver = new FindMinima();
    List<Double> line = Arrays.asList(
      1.0, 2.0, 1.0, 2.0, -1.0,
      3.0, 4.0, 5.0, 4.0);
    Result result = solver.minima(line);
    if(result.success)
      System.out.println(result.line);
    else
      System.out.println("No algorithm found");
  }
}
/* Output:
LeastSquares.algorithm
Perturbation.algorithm
Bisection.algorithm
[5.5, 6.6]
*/
```











## 6. 改变接口

> - #### ***`适配器模式`*** 接受一种类型并且提供一个对其他类型的接口；
>
> - #### ***`外观模式`***   为一组类创建了一个接口，这样做只是为了提供一种更方便的方法来处理库或资源。

### (1) 适配器模式

> #### 当我们手头有某个类，而我们需要的却是另外一个类，我们就可以通过 ***`适配器模式`*** 来解决问题。

```
package patterns.adapt;

class WhatIHave {
    public void g() {}
    public void h() {}
}

interface WhatIWant {
    void f();
}

class ProxyAdapter implements WhatIWant {
    WhatIHave whatIHave;
    ProxyAdapter(WhatIHave wih) { whatIHave = wih; }
    @Override
    public void f() {
        whatIHave.g();
        whatIHave.h();
    }
}

class WhatIUse {
    public void op(WhatIWant wiw) { wiw.f(); }
}

// Approach 2: build adapter use into op():
class WhatIUse2 extends WhatIUse {
    public void op(WhatIHave wih) { new ProxyAdapter(wih).f(); }
}

// Approach 3: build adapter into WhatIHave:
class WhatIHave2 extends WhatIHave implements WhatIWant {
    @Override
    public void f() {
        g();
        h();
    }
}

// Approach 4: use an inner class:
class WhatIHave3 extends WhatIHave {
    private class InnerAdapter implements WhatIWant {
        @Override
        public void f() {
            g();
            h();
        }
    }
    public WhatIWant whatIWant() { return new InnerAdapter(); }
}

public class Adapter {
    public static void main(String[] args) {
        WhatIUse whatIUse = new WhatIUse();
        WhatIHave whatIHave = new WhatIHave();
        WhatIWant adapt= new ProxyAdapter(whatIHave);
        whatIUse.op(adapt);
        // Approach 2:
        WhatIUse2 whatIUse2 = new WhatIUse2();
        whatIUse2.op(whatIHave);
        // Approach 3:
        WhatIHave2 whatIHave2 = new WhatIHave2();
        whatIUse.op(whatIHave2);
        // Approach 4:
        WhatIHave3 whatIHave3 = new WhatIHave3();
        whatIUse.op(whatIHave3.whatIWant());
    }
}
```







### (2) 外观模式

> #### ***`外观模式`*** 所干的事基本上就是 ***“把所有丑陋的东西都隐藏到对象里去”*** 。
>
> #### 外观模式经常被实现为一个符合单例模式的抽象工厂，可以通过创建包含静态工厂方法的类来达到上述效果：

```
class A { A(int x) {} }

class B { B(long x) {} }

class C { C(double x) {} }

public class Facade {
  static A makeA(int x) { return new A(x); }
  static B makeB(long x) { return new B(x); }
  static C makeC(double x) { return new C(x); }
  public static void main(String[] args) {
    A a = Facade.makeA(1);
    B b = Facade.makeB(1);
    C c = Facade.makeC(1.0);
  }
}
```







### (3) 包作为外观模式的变体

> #### ***`外观模式`*** 更倾向于“过程式的”(即非面向对象的)：我们是通过调用某些函数才得到对象。而`外观模式`的关键一点是隐藏某个库的一部分类，是他们对于客户端程序员不可见，这样那些类的接口就更加简练和易于理解了。
>
> #### 这也正是 Java 的包的功能所完成的事情：在库以外，我们只能创建和使用被声明为公共的那些类；所有非公共的类只能被同一 `package` 的类使用。











## 7. 解释器：运行时的弹性

> #### 如果程序的用户需要更好的运行时弹性，例如创建脚本来增加需要的系统功能，可以使用 ***`解释器设计模式`*** 。该模式下可以创建一个语言解释器并将它嵌入程序中。

> #### 有一个完全使用 `Java` 字节码实现的 `Python` 版本（叫做 `Jython`）， 能够轻易地合并到 `Java` 程序中。